
Eyantra solution.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800200  000036d0  00003764  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000036d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000030e  00800236  00800236  0000379a  2**0
                  ALLOC
  3 .stab         00003a38  00000000  00000000  0000379c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b91  00000000  00000000  000071d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000108  00000000  00000000  00007d68  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a28  00000000  00000000  00007e70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000050b  00000000  00000000  0000a898  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000102e  00000000  00000000  0000ada3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000748  00000000  00000000  0000bdd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000799  00000000  00000000  0000c51c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000023b8  00000000  00000000  0000ccb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0000f06d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 7c 14 	jmp	0x28f8	; 0x28f8 <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__vector_5>
      18:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 a3 13 	jmp	0x2746	; 0x2746 <__vector_35>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <path_find+0x148>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e0 ed       	ldi	r30, 0xD0	; 208
     17e:	f6 e3       	ldi	r31, 0x36	; 54
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a6 33       	cpi	r26, 0x36	; 54
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	15 e0       	ldi	r17, 0x05	; 5
     192:	a6 e3       	ldi	r26, 0x36	; 54
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a4 34       	cpi	r26, 0x44	; 68
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 eb 15 	call	0x2bd6	; 0x2bd6 <main>
     1a4:	0c 94 66 1b 	jmp	0x36cc	; 0x36cc <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <def>:
*/

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	30 e0       	ldi	r19, 0x00	; 0
* Logic:			All the nodes of the arena are accessed and given null value (more specifically null character)
* Example Call:		def();
*
*/

void def(void)
     1b0:	40 e0       	ldi	r20, 0x00	; 0
     1b2:	50 e0       	ldi	r21, 0x00	; 0
     1b4:	0a c0       	rjmp	.+20     	; 0x1ca <def+0x1e>
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<=maximum_number_of_nodes;j++)	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	graph[i][j]='\0';
     1b6:	11 92       	st	Z+, r1

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<=maximum_number_of_nodes;j++)	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1b8:	01 96       	adiw	r24, 0x01	; 1
     1ba:	8a 31       	cpi	r24, 0x1A	; 26
     1bc:	91 05       	cpc	r25, r1
     1be:	d9 f7       	brne	.-10     	; 0x1b6 <def+0xa>
*/

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1c0:	2f 5f       	subi	r18, 0xFF	; 255
     1c2:	3f 4f       	sbci	r19, 0xFF	; 255
     1c4:	2a 31       	cpi	r18, 0x1A	; 26
     1c6:	31 05       	cpc	r19, r1
     1c8:	89 f0       	breq	.+34     	; 0x1ec <def+0x40>
* Logic:			All the nodes of the arena are accessed and given null value (more specifically null character)
* Example Call:		def();
*
*/

void def(void)
     1ca:	f9 01       	movw	r30, r18
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	e2 0f       	add	r30, r18
     1d2:	f3 1f       	adc	r31, r19
     1d4:	ee 0f       	add	r30, r30
     1d6:	ff 1f       	adc	r31, r31
     1d8:	ee 0f       	add	r30, r30
     1da:	ff 1f       	adc	r31, r31
     1dc:	ee 0f       	add	r30, r30
     1de:	ff 1f       	adc	r31, r31
     1e0:	e2 0f       	add	r30, r18
     1e2:	f3 1f       	adc	r31, r19
     1e4:	e0 56       	subi	r30, 0x60	; 96
     1e6:	fd 4f       	sbci	r31, 0xFD	; 253
     1e8:	ca 01       	movw	r24, r20
     1ea:	e5 cf       	rjmp	.-54     	; 0x1b6 <def+0xa>
     1ec:	08 95       	ret

000001ee <sppeed>:
*
*/

void sppeed(unsigned int l,unsigned int r) 
{
	cli();
     1ee:	f8 94       	cli
	OCR5A=l;		// OCR5A = for left motor
     1f0:	90 93 29 01 	sts	0x0129, r25
     1f4:	80 93 28 01 	sts	0x0128, r24
	OCR5B=r;		// OCR5B = for right motor
     1f8:	70 93 2b 01 	sts	0x012B, r23
     1fc:	60 93 2a 01 	sts	0x012A, r22
	sei();
     200:	78 94       	sei
}
     202:	08 95       	ret

00000204 <navigate>:
*
*/

void navigate(void) 
{
	cli();
     204:	f8 94       	cli
	if(navigation_in_degrees==0)
     206:	80 91 2a 02 	lds	r24, 0x022A
     20a:	90 91 2b 02 	lds	r25, 0x022B
     20e:	00 97       	sbiw	r24, 0x00	; 0
     210:	39 f4       	brne	.+14     	; 0x220 <navigate+0x1c>
	navigation_pointer="East ";
     212:	80 e0       	ldi	r24, 0x00	; 0
     214:	92 e0       	ldi	r25, 0x02	; 2
     216:	90 93 93 02 	sts	0x0293, r25
     21a:	80 93 92 02 	sts	0x0292, r24
     21e:	39 c0       	rjmp	.+114    	; 0x292 <navigate+0x8e>
	else if(abs(navigation_in_degrees)==270)
     220:	9c 01       	movw	r18, r24
     222:	99 23       	and	r25, r25
     224:	24 f4       	brge	.+8      	; 0x22e <navigate+0x2a>
     226:	22 27       	eor	r18, r18
     228:	33 27       	eor	r19, r19
     22a:	28 1b       	sub	r18, r24
     22c:	39 0b       	sbc	r19, r25
     22e:	41 e0       	ldi	r20, 0x01	; 1
     230:	2e 30       	cpi	r18, 0x0E	; 14
     232:	34 07       	cpc	r19, r20
     234:	89 f4       	brne	.+34     	; 0x258 <navigate+0x54>
	{
		if(navigation_in_degrees>0)
     236:	18 16       	cp	r1, r24
     238:	19 06       	cpc	r1, r25
     23a:	3c f4       	brge	.+14     	; 0x24a <navigate+0x46>
		navigation_pointer="South";
     23c:	86 e0       	ldi	r24, 0x06	; 6
     23e:	92 e0       	ldi	r25, 0x02	; 2
     240:	90 93 93 02 	sts	0x0293, r25
     244:	80 93 92 02 	sts	0x0292, r24
     248:	24 c0       	rjmp	.+72     	; 0x292 <navigate+0x8e>
		else
		navigation_pointer="North";
     24a:	8c e0       	ldi	r24, 0x0C	; 12
     24c:	92 e0       	ldi	r25, 0x02	; 2
     24e:	90 93 93 02 	sts	0x0293, r25
     252:	80 93 92 02 	sts	0x0292, r24
     256:	1d c0       	rjmp	.+58     	; 0x292 <navigate+0x8e>
	}
	else if(abs(navigation_in_degrees)==180)
     258:	24 3b       	cpi	r18, 0xB4	; 180
     25a:	31 05       	cpc	r19, r1
     25c:	39 f4       	brne	.+14     	; 0x26c <navigate+0x68>
	{
		navigation_pointer="West ";
     25e:	82 e1       	ldi	r24, 0x12	; 18
     260:	92 e0       	ldi	r25, 0x02	; 2
     262:	90 93 93 02 	sts	0x0293, r25
     266:	80 93 92 02 	sts	0x0292, r24
     26a:	13 c0       	rjmp	.+38     	; 0x292 <navigate+0x8e>
	}
	else if(abs(navigation_in_degrees)==90)
     26c:	2a 35       	cpi	r18, 0x5A	; 90
     26e:	31 05       	cpc	r19, r1
     270:	81 f4       	brne	.+32     	; 0x292 <navigate+0x8e>
	{
		if(navigation_in_degrees>0)
     272:	18 16       	cp	r1, r24
     274:	19 06       	cpc	r1, r25
     276:	3c f4       	brge	.+14     	; 0x286 <navigate+0x82>
		navigation_pointer="North";
     278:	8c e0       	ldi	r24, 0x0C	; 12
     27a:	92 e0       	ldi	r25, 0x02	; 2
     27c:	90 93 93 02 	sts	0x0293, r25
     280:	80 93 92 02 	sts	0x0292, r24
     284:	06 c0       	rjmp	.+12     	; 0x292 <navigate+0x8e>
		else
		navigation_pointer="South";
     286:	86 e0       	ldi	r24, 0x06	; 6
     288:	92 e0       	ldi	r25, 0x02	; 2
     28a:	90 93 93 02 	sts	0x0293, r25
     28e:	80 93 92 02 	sts	0x0292, r24
	}
	sei();
     292:	78 94       	sei
}
     294:	08 95       	ret

00000296 <enqueue>:
* Example Call:			enqueue(10);
*
*/

void enqueue(int node_added)
{
     296:	0f 93       	push	r16
     298:	1f 93       	push	r17
     29a:	cf 93       	push	r28
     29c:	df 93       	push	r29
     29e:	8c 01       	movw	r16, r24
	struct queue *newnode;
	if(root==NULL)
     2a0:	c0 91 38 02 	lds	r28, 0x0238
     2a4:	d0 91 39 02 	lds	r29, 0x0239
     2a8:	20 97       	sbiw	r28, 0x00	; 0
     2aa:	a9 f4       	brne	.+42     	; 0x2d6 <enqueue+0x40>
	{
		root=(struct queue*)malloc(sizeof(struct queue));
     2ac:	86 e0       	ldi	r24, 0x06	; 6
     2ae:	90 e0       	ldi	r25, 0x00	; 0
     2b0:	0e 94 37 1a 	call	0x346e	; 0x346e <malloc>
     2b4:	e8 2f       	mov	r30, r24
     2b6:	f9 2f       	mov	r31, r25
     2b8:	f0 93 39 02 	sts	0x0239, r31
     2bc:	e0 93 38 02 	sts	0x0238, r30
		root->num=node_added;
     2c0:	15 83       	std	Z+5, r17	; 0x05
     2c2:	04 83       	std	Z+4, r16	; 0x04
		root->next=NULL;
     2c4:	11 82       	std	Z+1, r1	; 0x01
     2c6:	10 82       	st	Z, r1
		root->prev=NULL;
     2c8:	13 82       	std	Z+3, r1	; 0x03
     2ca:	12 82       	std	Z+2, r1	; 0x02
		end=root;
     2cc:	f0 93 37 02 	sts	0x0237, r31
     2d0:	e0 93 36 02 	sts	0x0236, r30
     2d4:	19 c0       	rjmp	.+50     	; 0x308 <enqueue+0x72>
	}
	else
	{
		newnode=(struct queue*)malloc(sizeof(struct queue));
     2d6:	86 e0       	ldi	r24, 0x06	; 6
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	0e 94 37 1a 	call	0x346e	; 0x346e <malloc>
     2de:	e8 2f       	mov	r30, r24
     2e0:	f9 2f       	mov	r31, r25
		newnode->num=node_added;
     2e2:	15 83       	std	Z+5, r17	; 0x05
     2e4:	04 83       	std	Z+4, r16	; 0x04
		root->next=newnode;
     2e6:	f9 83       	std	Y+1, r31	; 0x01
     2e8:	e8 83       	st	Y, r30
		newnode->prev=root;
     2ea:	a0 91 38 02 	lds	r26, 0x0238
     2ee:	b0 91 39 02 	lds	r27, 0x0239
     2f2:	b3 83       	std	Z+3, r27	; 0x03
     2f4:	a2 83       	std	Z+2, r26	; 0x02
		root=root->next;
     2f6:	8d 91       	ld	r24, X+
     2f8:	9c 91       	ld	r25, X
     2fa:	11 97       	sbiw	r26, 0x01	; 1
     2fc:	90 93 39 02 	sts	0x0239, r25
     300:	80 93 38 02 	sts	0x0238, r24
		newnode->next=NULL;
     304:	11 82       	std	Z+1, r1	; 0x01
     306:	10 82       	st	Z, r1
	}
	que_length++;			//que_length -> length of the queue
     308:	80 91 45 02 	lds	r24, 0x0245
     30c:	90 91 46 02 	lds	r25, 0x0246
     310:	01 96       	adiw	r24, 0x01	; 1
     312:	90 93 46 02 	sts	0x0246, r25
     316:	80 93 45 02 	sts	0x0245, r24
}
     31a:	df 91       	pop	r29
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	08 95       	ret

00000324 <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     324:	86 e6       	ldi	r24, 0x66	; 102
     326:	9e e0       	ldi	r25, 0x0E	; 14
     328:	01 97       	sbiw	r24, 0x01	; 1
     32a:	f1 f7       	brne	.-4      	; 0x328 <lcd_set_4bit+0x4>
     32c:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     32e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     330:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     332:	80 e3       	ldi	r24, 0x30	; 48
     334:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     336:	42 9a       	sbi	0x08, 2	; 8
     338:	ef ef       	ldi	r30, 0xFF	; 255
     33a:	f7 e4       	ldi	r31, 0x47	; 71
     33c:	31 97       	sbiw	r30, 0x01	; 1
     33e:	f1 f7       	brne	.-4      	; 0x33c <lcd_set_4bit+0x18>
     340:	00 c0       	rjmp	.+0      	; 0x342 <lcd_set_4bit+0x1e>
     342:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     344:	42 98       	cbi	0x08, 2	; 8
     346:	e6 e6       	ldi	r30, 0x66	; 102
     348:	fe e0       	ldi	r31, 0x0E	; 14
     34a:	31 97       	sbiw	r30, 0x01	; 1
     34c:	f1 f7       	brne	.-4      	; 0x34a <lcd_set_4bit+0x26>
     34e:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     350:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     352:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     354:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     356:	42 9a       	sbi	0x08, 2	; 8
     358:	ef ef       	ldi	r30, 0xFF	; 255
     35a:	f7 e4       	ldi	r31, 0x47	; 71
     35c:	31 97       	sbiw	r30, 0x01	; 1
     35e:	f1 f7       	brne	.-4      	; 0x35c <lcd_set_4bit+0x38>
     360:	00 c0       	rjmp	.+0      	; 0x362 <lcd_set_4bit+0x3e>
     362:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     364:	42 98       	cbi	0x08, 2	; 8
     366:	e6 e6       	ldi	r30, 0x66	; 102
     368:	fe e0       	ldi	r31, 0x0E	; 14
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	f1 f7       	brne	.-4      	; 0x36a <lcd_set_4bit+0x46>
     36e:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     370:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     372:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     374:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     376:	42 9a       	sbi	0x08, 2	; 8
     378:	8f ef       	ldi	r24, 0xFF	; 255
     37a:	97 e4       	ldi	r25, 0x47	; 71
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	f1 f7       	brne	.-4      	; 0x37c <lcd_set_4bit+0x58>
     380:	00 c0       	rjmp	.+0      	; 0x382 <lcd_set_4bit+0x5e>
     382:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     384:	42 98       	cbi	0x08, 2	; 8
     386:	e6 e6       	ldi	r30, 0x66	; 102
     388:	fe e0       	ldi	r31, 0x0E	; 14
     38a:	31 97       	sbiw	r30, 0x01	; 1
     38c:	f1 f7       	brne	.-4      	; 0x38a <lcd_set_4bit+0x66>
     38e:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     390:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     392:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     394:	80 e2       	ldi	r24, 0x20	; 32
     396:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     398:	42 9a       	sbi	0x08, 2	; 8
     39a:	8f ef       	ldi	r24, 0xFF	; 255
     39c:	97 e4       	ldi	r25, 0x47	; 71
     39e:	01 97       	sbiw	r24, 0x01	; 1
     3a0:	f1 f7       	brne	.-4      	; 0x39e <lcd_set_4bit+0x7a>
     3a2:	00 c0       	rjmp	.+0      	; 0x3a4 <lcd_set_4bit+0x80>
     3a4:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     3a6:	42 98       	cbi	0x08, 2	; 8

	
}
     3a8:	08 95       	ret

000003aa <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     3aa:	98 b1       	in	r25, 0x08	; 8
     3ac:	9f 70       	andi	r25, 0x0F	; 15
     3ae:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     3b0:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     3b2:	28 2f       	mov	r18, r24
     3b4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     3b6:	92 2b       	or	r25, r18
     3b8:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     3ba:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     3bc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     3be:	42 9a       	sbi	0x08, 2	; 8
     3c0:	ef ef       	ldi	r30, 0xFF	; 255
     3c2:	f7 e4       	ldi	r31, 0x47	; 71
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	f1 f7       	brne	.-4      	; 0x3c4 <lcd_wr_command+0x1a>
     3c8:	00 c0       	rjmp	.+0      	; 0x3ca <lcd_wr_command+0x20>
     3ca:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     3cc:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     3ce:	98 b1       	in	r25, 0x08	; 8
     3d0:	9f 70       	andi	r25, 0x0F	; 15
     3d2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     3d4:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     3d6:	82 95       	swap	r24
     3d8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     3da:	89 2b       	or	r24, r25
     3dc:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     3de:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     3e0:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     3e2:	42 9a       	sbi	0x08, 2	; 8
     3e4:	8f ef       	ldi	r24, 0xFF	; 255
     3e6:	97 e4       	ldi	r25, 0x47	; 71
     3e8:	01 97       	sbiw	r24, 0x01	; 1
     3ea:	f1 f7       	brne	.-4      	; 0x3e8 <lcd_wr_command+0x3e>
     3ec:	00 c0       	rjmp	.+0      	; 0x3ee <lcd_wr_command+0x44>
     3ee:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     3f0:	42 98       	cbi	0x08, 2	; 8
}
     3f2:	08 95       	ret

000003f4 <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     3f4:	0e 94 92 01 	call	0x324	; 0x324 <lcd_set_4bit>
     3f8:	86 e6       	ldi	r24, 0x66	; 102
     3fa:	9e e0       	ldi	r25, 0x0E	; 14
     3fc:	01 97       	sbiw	r24, 0x01	; 1
     3fe:	f1 f7       	brne	.-4      	; 0x3fc <lcd_init+0x8>
     400:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     402:	88 e2       	ldi	r24, 0x28	; 40
     404:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
	lcd_wr_command(0x01);
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
	lcd_wr_command(0x06);
     40e:	86 e0       	ldi	r24, 0x06	; 6
     410:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
	lcd_wr_command(0x0E);
     414:	8e e0       	ldi	r24, 0x0E	; 14
     416:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
	lcd_wr_command(0x80);
     41a:	80 e8       	ldi	r24, 0x80	; 128
     41c:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
		
}
     420:	08 95       	ret

00000422 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     422:	98 b1       	in	r25, 0x08	; 8
     424:	9f 70       	andi	r25, 0x0F	; 15
     426:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     428:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     42a:	28 2f       	mov	r18, r24
     42c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     42e:	92 2b       	or	r25, r18
     430:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     432:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     434:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     436:	42 9a       	sbi	0x08, 2	; 8
     438:	ef ef       	ldi	r30, 0xFF	; 255
     43a:	f7 e4       	ldi	r31, 0x47	; 71
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	f1 f7       	brne	.-4      	; 0x43c <lcd_wr_char+0x1a>
     440:	00 c0       	rjmp	.+0      	; 0x442 <lcd_wr_char+0x20>
     442:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     444:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     446:	98 b1       	in	r25, 0x08	; 8
     448:	9f 70       	andi	r25, 0x0F	; 15
     44a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     44c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     44e:	82 95       	swap	r24
     450:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     452:	89 2b       	or	r24, r25
     454:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     456:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     458:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     45a:	42 9a       	sbi	0x08, 2	; 8
     45c:	8f ef       	ldi	r24, 0xFF	; 255
     45e:	97 e4       	ldi	r25, 0x47	; 71
     460:	01 97       	sbiw	r24, 0x01	; 1
     462:	f1 f7       	brne	.-4      	; 0x460 <lcd_wr_char+0x3e>
     464:	00 c0       	rjmp	.+0      	; 0x466 <lcd_wr_char+0x44>
     466:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     468:	42 98       	cbi	0x08, 2	; 8
}
     46a:	08 95       	ret

0000046c <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     46c:	80 e8       	ldi	r24, 0x80	; 128
     46e:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
}
     472:	08 95       	ret

00000474 <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     474:	cf 93       	push	r28
     476:	df 93       	push	r29
     478:	ec 01       	movw	r28, r24
	while(*str != '\0')
     47a:	88 81       	ld	r24, Y
     47c:	88 23       	and	r24, r24
     47e:	31 f0       	breq	.+12     	; 0x48c <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     480:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     482:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     486:	89 91       	ld	r24, Y+
     488:	88 23       	and	r24, r24
     48a:	d9 f7       	brne	.-10     	; 0x482 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     48c:	df 91       	pop	r29
     48e:	cf 91       	pop	r28
     490:	08 95       	ret

00000492 <lcd_showvalue>:

void lcd_showvalue(unsigned char num)	//prints the decimal 3digit value of num
{
     492:	1f 93       	push	r17
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
     498:	c8 2f       	mov	r28, r24
	unsigned char H=0,T=0,O=0;
	H=num/100;
     49a:	64 e6       	ldi	r22, 0x64	; 100
     49c:	0e 94 04 1a 	call	0x3408	; 0x3408 <__udivmodqi4>
     4a0:	d8 2f       	mov	r29, r24
	T=(num - (H*100))/10;
     4a2:	48 2f       	mov	r20, r24
     4a4:	50 e0       	ldi	r21, 0x00	; 0
     4a6:	2c e9       	ldi	r18, 0x9C	; 156
     4a8:	3f ef       	ldi	r19, 0xFF	; 255
     4aa:	42 9f       	mul	r20, r18
     4ac:	c0 01       	movw	r24, r0
     4ae:	43 9f       	mul	r20, r19
     4b0:	90 0d       	add	r25, r0
     4b2:	52 9f       	mul	r21, r18
     4b4:	90 0d       	add	r25, r0
     4b6:	11 24       	eor	r1, r1
     4b8:	8c 0f       	add	r24, r28
     4ba:	91 1d       	adc	r25, r1
     4bc:	6a e0       	ldi	r22, 0x0A	; 10
     4be:	70 e0       	ldi	r23, 0x00	; 0
     4c0:	0e 94 24 1a 	call	0x3448	; 0x3448 <__divmodhi4>
     4c4:	16 2f       	mov	r17, r22
	O=(num - (H*100) - (T*10));
	
	lcd_wr_char(H+48);
     4c6:	8d 2f       	mov	r24, r29
     4c8:	80 5d       	subi	r24, 0xD0	; 208
     4ca:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
	lcd_wr_char(T+48);
     4ce:	81 2f       	mov	r24, r17
     4d0:	80 5d       	subi	r24, 0xD0	; 208
     4d2:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
void lcd_showvalue(unsigned char num)	//prints the decimal 3digit value of num
{
	unsigned char H=0,T=0,O=0;
	H=num/100;
	T=(num - (H*100))/10;
	O=(num - (H*100) - (T*10));
     4d6:	c0 5d       	subi	r28, 0xD0	; 208
     4d8:	8c e9       	ldi	r24, 0x9C	; 156
     4da:	d8 9f       	mul	r29, r24
     4dc:	d0 2d       	mov	r29, r0
     4de:	11 24       	eor	r1, r1
     4e0:	8c 2f       	mov	r24, r28
     4e2:	8d 0f       	add	r24, r29
     4e4:	11 0f       	add	r17, r17
     4e6:	91 2f       	mov	r25, r17
     4e8:	99 0f       	add	r25, r25
     4ea:	99 0f       	add	r25, r25
     4ec:	19 0f       	add	r17, r25
	
	lcd_wr_char(H+48);
	lcd_wr_char(T+48);
	lcd_wr_char(O+48);
     4ee:	81 1b       	sub	r24, r17
     4f0:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
}
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	1f 91       	pop	r17
     4fa:	08 95       	ret

000004fc <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     4fc:	82 30       	cpi	r24, 0x02	; 2
     4fe:	79 f0       	breq	.+30     	; 0x51e <lcd_cursor+0x22>
     500:	83 30       	cpi	r24, 0x03	; 3
     502:	18 f4       	brcc	.+6      	; 0x50a <lcd_cursor+0xe>
     504:	81 30       	cpi	r24, 0x01	; 1
     506:	c9 f4       	brne	.+50     	; 0x53a <lcd_cursor+0x3e>
     508:	05 c0       	rjmp	.+10     	; 0x514 <lcd_cursor+0x18>
     50a:	83 30       	cpi	r24, 0x03	; 3
     50c:	69 f0       	breq	.+26     	; 0x528 <lcd_cursor+0x2c>
     50e:	84 30       	cpi	r24, 0x04	; 4
     510:	a1 f4       	brne	.+40     	; 0x53a <lcd_cursor+0x3e>
     512:	0f c0       	rjmp	.+30     	; 0x532 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     514:	86 2f       	mov	r24, r22
     516:	81 58       	subi	r24, 0x81	; 129
     518:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
     51c:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     51e:	86 2f       	mov	r24, r22
     520:	81 54       	subi	r24, 0x41	; 65
     522:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
     526:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     528:	86 2f       	mov	r24, r22
     52a:	8d 56       	subi	r24, 0x6D	; 109
     52c:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
     530:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     532:	86 2f       	mov	r24, r22
     534:	8d 52       	subi	r24, 0x2D	; 45
     536:	0e 94 d5 01 	call	0x3aa	; 0x3aa <lcd_wr_command>
     53a:	08 95       	ret

0000053c <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     53c:	0f 93       	push	r16
     53e:	1f 93       	push	r17
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	8a 01       	movw	r16, r20
     546:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     548:	88 23       	and	r24, r24
     54a:	11 f0       	breq	.+4      	; 0x550 <lcd_print+0x14>
     54c:	66 23       	and	r22, r22
     54e:	19 f4       	brne	.+6      	; 0x556 <lcd_print+0x1a>
	{
		lcd_home();
     550:	0e 94 36 02 	call	0x46c	; 0x46c <lcd_home>
     554:	02 c0       	rjmp	.+4      	; 0x55a <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     556:	0e 94 7e 02 	call	0x4fc	; 0x4fc <lcd_cursor>
	}
	if(digits==5 || flag==1)
     55a:	c5 30       	cpi	r28, 0x05	; 5
     55c:	d1 05       	cpc	r29, r1
     55e:	71 f4       	brne	.+28     	; 0x57c <lcd_print+0x40>
	{
		million=value/10000+48;
     560:	c8 01       	movw	r24, r16
     562:	60 e1       	ldi	r22, 0x10	; 16
     564:	77 e2       	ldi	r23, 0x27	; 39
     566:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     56a:	cb 01       	movw	r24, r22
     56c:	c0 96       	adiw	r24, 0x30	; 48
     56e:	90 93 95 02 	sts	0x0295, r25
     572:	80 93 94 02 	sts	0x0294, r24
		lcd_wr_char(million);
     576:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
     57a:	03 c0       	rjmp	.+6      	; 0x582 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     57c:	c4 30       	cpi	r28, 0x04	; 4
     57e:	d1 05       	cpc	r29, r1
     580:	b9 f4       	brne	.+46     	; 0x5b0 <lcd_print+0x74>
	{
		temp = value/1000;
     582:	c8 01       	movw	r24, r16
     584:	68 ee       	ldi	r22, 0xE8	; 232
     586:	73 e0       	ldi	r23, 0x03	; 3
     588:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     58c:	cb 01       	movw	r24, r22
     58e:	70 93 97 02 	sts	0x0297, r23
     592:	60 93 96 02 	sts	0x0296, r22
		thousand = temp%10 + 48;
     596:	6a e0       	ldi	r22, 0x0A	; 10
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     59e:	c0 96       	adiw	r24, 0x30	; 48
     5a0:	90 93 3f 05 	sts	0x053F, r25
     5a4:	80 93 3e 05 	sts	0x053E, r24
		lcd_wr_char(thousand);
     5a8:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
		flag=1;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	01 c0       	rjmp	.+2      	; 0x5b2 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     5b0:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     5b2:	c3 30       	cpi	r28, 0x03	; 3
     5b4:	d1 05       	cpc	r29, r1
     5b6:	11 f0       	breq	.+4      	; 0x5bc <lcd_print+0x80>
     5b8:	81 30       	cpi	r24, 0x01	; 1
     5ba:	b1 f4       	brne	.+44     	; 0x5e8 <lcd_print+0xac>
	{
		temp = value/100;
     5bc:	c8 01       	movw	r24, r16
     5be:	64 e6       	ldi	r22, 0x64	; 100
     5c0:	70 e0       	ldi	r23, 0x00	; 0
     5c2:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     5c6:	cb 01       	movw	r24, r22
     5c8:	70 93 97 02 	sts	0x0297, r23
     5cc:	60 93 96 02 	sts	0x0296, r22
		hundred = temp%10 + 48;
     5d0:	6a e0       	ldi	r22, 0x0A	; 10
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     5d8:	c0 96       	adiw	r24, 0x30	; 48
     5da:	90 93 19 05 	sts	0x0519, r25
     5de:	80 93 18 05 	sts	0x0518, r24
		lcd_wr_char(hundred);
     5e2:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
		flag=1;
     5e6:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     5e8:	c2 30       	cpi	r28, 0x02	; 2
     5ea:	d1 05       	cpc	r29, r1
     5ec:	11 f0       	breq	.+4      	; 0x5f2 <lcd_print+0xb6>
     5ee:	81 30       	cpi	r24, 0x01	; 1
     5f0:	b1 f4       	brne	.+44     	; 0x61e <lcd_print+0xe2>
	{
		temp = value/10;
     5f2:	2a e0       	ldi	r18, 0x0A	; 10
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	c8 01       	movw	r24, r16
     5f8:	b9 01       	movw	r22, r18
     5fa:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     5fe:	cb 01       	movw	r24, r22
     600:	70 93 97 02 	sts	0x0297, r23
     604:	60 93 96 02 	sts	0x0296, r22
		tens = temp%10 + 48;
     608:	b9 01       	movw	r22, r18
     60a:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     60e:	c0 96       	adiw	r24, 0x30	; 48
     610:	90 93 12 05 	sts	0x0512, r25
     614:	80 93 11 05 	sts	0x0511, r24
		lcd_wr_char(tens);
     618:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
		flag=1;
     61c:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     61e:	c1 30       	cpi	r28, 0x01	; 1
     620:	d1 05       	cpc	r29, r1
     622:	11 f0       	breq	.+4      	; 0x628 <lcd_print+0xec>
     624:	81 30       	cpi	r24, 0x01	; 1
     626:	61 f4       	brne	.+24     	; 0x640 <lcd_print+0x104>
	{
		unit = value%10 + 48;
     628:	c8 01       	movw	r24, r16
     62a:	6a e0       	ldi	r22, 0x0A	; 10
     62c:	70 e0       	ldi	r23, 0x00	; 0
     62e:	0e 94 10 1a 	call	0x3420	; 0x3420 <__udivmodhi4>
     632:	c0 96       	adiw	r24, 0x30	; 48
     634:	90 93 3d 05 	sts	0x053D, r25
     638:	80 93 3c 05 	sts	0x053C, r24
		lcd_wr_char(unit);
     63c:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
	}
	if(digits>5)
     640:	c6 30       	cpi	r28, 0x06	; 6
     642:	d1 05       	cpc	r29, r1
     644:	1c f0       	brlt	.+6      	; 0x64c <lcd_print+0x110>
	{
		lcd_wr_char('E');
     646:	85 e4       	ldi	r24, 0x45	; 69
     648:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
	}
	
}
     64c:	df 91       	pop	r29
     64e:	cf 91       	pop	r28
     650:	1f 91       	pop	r17
     652:	0f 91       	pop	r16
     654:	08 95       	ret

00000656 <struct_config>:
*
*/

void struct_config(void)
{
	cli();                       // Clears the global interrupt
     656:	f8 94       	cli
	def();						 // User defined function which gives null value to all the nodes of the arena
     658:	0e 94 d6 00 	call	0x1ac	; 0x1ac <def>
	graph[0][1]='N';
     65c:	2e e4       	ldi	r18, 0x4E	; 78
     65e:	20 93 a1 02 	sts	0x02A1, r18
	graph[0][2]='S';
     662:	33 e5       	ldi	r19, 0x53	; 83
     664:	30 93 a2 02 	sts	0x02A2, r19
	graph[0][6]='E';
     668:	95 e4       	ldi	r25, 0x45	; 69
     66a:	90 93 a6 02 	sts	0x02A6, r25
	graph[0][10]='W';
     66e:	87 e5       	ldi	r24, 0x57	; 87
     670:	80 93 aa 02 	sts	0x02AA, r24
	graph[1][0]='S';
     674:	30 93 b9 02 	sts	0x02B9, r19
	graph[2][0]='N';
     678:	20 93 d2 02 	sts	0x02D2, r18
	graph[2][3]='S';
     67c:	30 93 d5 02 	sts	0x02D5, r19
	graph[2][4]='W';
     680:	80 93 d6 02 	sts	0x02D6, r24
	graph[3][2]='N';
     684:	20 93 ed 02 	sts	0x02ED, r18
	graph[3][5]='W';
     688:	80 93 f0 02 	sts	0x02F0, r24
	graph[4][2]='E';
     68c:	90 93 06 03 	sts	0x0306, r25
	graph[5][3]='E';
     690:	90 93 20 03 	sts	0x0320, r25
	graph[6][0]='W';
     694:	80 93 36 03 	sts	0x0336, r24
	graph[6][19]='N';
     698:	20 93 49 03 	sts	0x0349, r18
	graph[6][18]='S';
     69c:	30 93 48 03 	sts	0x0348, r19
	graph[7][19]='W';
     6a0:	80 93 62 03 	sts	0x0362, r24
	graph[7][20]='E';
     6a4:	90 93 63 03 	sts	0x0363, r25
	graph[8][20]='N';
     6a8:	20 93 7c 03 	sts	0x037C, r18
	graph[9][18]='W';
     6ac:	80 93 93 03 	sts	0x0393, r24
	graph[10][0]='E';
     6b0:	90 93 9a 03 	sts	0x039A, r25
	graph[10][11]='N';
     6b4:	20 93 a5 03 	sts	0x03A5, r18
	graph[10][13]='S';
     6b8:	30 93 a7 03 	sts	0x03A7, r19
	graph[10][16]='W';
     6bc:	80 93 aa 03 	sts	0x03AA, r24
	graph[11][14]='E';
     6c0:	90 93 c1 03 	sts	0x03C1, r25
	graph[11][10]='S';
     6c4:	30 93 bd 03 	sts	0x03BD, r19
	graph[11][12]='N';
     6c8:	20 93 bf 03 	sts	0x03BF, r18
	graph[12][15]='W';
     6cc:	80 93 db 03 	sts	0x03DB, r24
	graph[12][11]='S';
     6d0:	30 93 d7 03 	sts	0x03D7, r19
	graph[13][10]='N';
     6d4:	20 93 ef 03 	sts	0x03EF, r18
	graph[13][17]='W';
     6d8:	80 93 f6 03 	sts	0x03F6, r24
	graph[14][11]='W';
     6dc:	80 93 09 04 	sts	0x0409, r24
	graph[15][12]='E';
     6e0:	90 93 23 04 	sts	0x0423, r25
	graph[16][10]='E';
     6e4:	90 93 3a 04 	sts	0x043A, r25
	graph[17][13]='E';
     6e8:	90 93 56 04 	sts	0x0456, r25
	graph[19][7]='E';
     6ec:	90 93 82 04 	sts	0x0482, r25
	graph[19][6]='S';
     6f0:	30 93 81 04 	sts	0x0481, r19
	graph[18][6]='N';
     6f4:	20 93 68 04 	sts	0x0468, r18
	graph[18][9]='E';
     6f8:	90 93 6b 04 	sts	0x046B, r25
	graph[20][8]='S';
     6fc:	30 93 9c 04 	sts	0x049C, r19
	graph[20][7]='W';
     700:	80 93 9b 04 	sts	0x049B, r24
	graph[7][21]='N';
     704:	20 93 64 03 	sts	0x0364, r18
	graph[8][22]='E';
     708:	90 93 7e 03 	sts	0x037E, r25
	graph[9][23]='S';
     70c:	30 93 98 03 	sts	0x0398, r19
	graph[21][7]='S';
     710:	30 93 b4 04 	sts	0x04B4, r19
	graph[22][8]='W';
     714:	80 93 ce 04 	sts	0x04CE, r24
	graph[23][9]='N';
     718:	20 93 e8 04 	sts	0x04E8, r18
	sei();					//Enables all the global interrupt
     71c:	78 94       	sei
}
     71e:	08 95       	ret

00000720 <path_logic>:
* Example Call:		path_logic(7,10);
*
*/

int path_logic(int curr_node, int req_node) 
{
     720:	8f 92       	push	r8
     722:	9f 92       	push	r9
     724:	af 92       	push	r10
     726:	bf 92       	push	r11
     728:	cf 92       	push	r12
     72a:	df 92       	push	r13
     72c:	ef 92       	push	r14
     72e:	ff 92       	push	r15
     730:	0f 93       	push	r16
     732:	1f 93       	push	r17
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	5c 01       	movw	r10, r24
     73a:	4b 01       	movw	r8, r22
	if(curr_node==req_node && found==0)  //found is the variable to check the bot's traversal
     73c:	86 17       	cp	r24, r22
     73e:	97 07       	cpc	r25, r23
     740:	69 f4       	brne	.+26     	; 0x75c <path_logic+0x3c>
     742:	80 91 3a 05 	lds	r24, 0x053A
     746:	90 91 3b 05 	lds	r25, 0x053B
     74a:	00 97       	sbiw	r24, 0x00	; 0
     74c:	39 f4       	brne	.+14     	; 0x75c <path_logic+0x3c>
	{
		found++;
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	90 93 3b 05 	sts	0x053B, r25
     756:	80 93 3a 05 	sts	0x053A, r24
		return(1);
     75a:	51 c0       	rjmp	.+162    	; 0x7fe <path_logic+0xde>
					According to that it updates the path string(global variable)
* Example Call:		path_logic(7,10);
*
*/

int path_logic(int curr_node, int req_node) 
     75c:	85 01       	movw	r16, r10
     75e:	00 0f       	add	r16, r16
     760:	11 1f       	adc	r17, r17
     762:	0a 0d       	add	r16, r10
     764:	1b 1d       	adc	r17, r11
     766:	00 0f       	add	r16, r16
     768:	11 1f       	adc	r17, r17
     76a:	00 0f       	add	r16, r16
     76c:	11 1f       	adc	r17, r17
     76e:	00 0f       	add	r16, r16
     770:	11 1f       	adc	r17, r17
     772:	0a 0d       	add	r16, r10
     774:	1b 1d       	adc	r17, r11
     776:	00 56       	subi	r16, 0x60	; 96
     778:	1d 4f       	sbci	r17, 0xFD	; 253
     77a:	ee 24       	eor	r14, r14
     77c:	ff 24       	eor	r15, r15
     77e:	c0 e0       	ldi	r28, 0x00	; 0
     780:	d0 e0       	ldi	r29, 0x00	; 0
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
	{
		if(graph[curr_node][j]!='\0' && previous_node!=j)
		{
			p[path_index]=graph[curr_node][j];  //path index -> index of the path string
     782:	0f 2e       	mov	r0, r31
     784:	f1 e7       	ldi	r31, 0x71	; 113
     786:	cf 2e       	mov	r12, r31
     788:	f2 e0       	ldi	r31, 0x02	; 2
     78a:	df 2e       	mov	r13, r31
     78c:	f0 2d       	mov	r31, r0
	int j,r=0;							//r stores the value of return
	
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
	{
		if(graph[curr_node][j]!='\0' && previous_node!=j)
     78e:	f8 01       	movw	r30, r16
     790:	21 91       	ld	r18, Z+
     792:	8f 01       	movw	r16, r30
     794:	22 23       	and	r18, r18
     796:	f1 f0       	breq	.+60     	; 0x7d4 <path_logic+0xb4>
     798:	80 91 13 05 	lds	r24, 0x0513
     79c:	90 91 14 05 	lds	r25, 0x0514
     7a0:	8c 17       	cp	r24, r28
     7a2:	9d 07       	cpc	r25, r29
     7a4:	b9 f0       	breq	.+46     	; 0x7d4 <path_logic+0xb4>
		{
			p[path_index]=graph[curr_node][j];  //path index -> index of the path string
     7a6:	80 91 47 02 	lds	r24, 0x0247
     7aa:	90 91 48 02 	lds	r25, 0x0248
     7ae:	f6 01       	movw	r30, r12
     7b0:	e8 0f       	add	r30, r24
     7b2:	f9 1f       	adc	r31, r25
     7b4:	20 83       	st	Z, r18
			path_index=path_index+1;
     7b6:	01 96       	adiw	r24, 0x01	; 1
     7b8:	90 93 48 02 	sts	0x0248, r25
     7bc:	80 93 47 02 	sts	0x0247, r24
			previous_node=curr_node;					//previous_node  -> previous node
     7c0:	b0 92 14 05 	sts	0x0514, r11
     7c4:	a0 92 13 05 	sts	0x0513, r10
			r=r+path_logic(j,req_node);
     7c8:	ce 01       	movw	r24, r28
     7ca:	b4 01       	movw	r22, r8
     7cc:	0e 94 90 03 	call	0x720	; 0x720 <path_logic>
     7d0:	e8 0e       	add	r14, r24
     7d2:	f9 1e       	adc	r15, r25
		return(1);
	}
	int j,r=0;							//r stores the value of return
	
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
     7d4:	21 96       	adiw	r28, 0x01	; 1
     7d6:	c9 31       	cpi	r28, 0x19	; 25
     7d8:	d1 05       	cpc	r29, r1
     7da:	c9 f6       	brne	.-78     	; 0x78e <path_logic+0x6e>
			path_index=path_index+1;
			previous_node=curr_node;					//previous_node  -> previous node
			r=r+path_logic(j,req_node);
		}
	}
	if(r>0)
     7dc:	1e 14       	cp	r1, r14
     7de:	1f 04       	cpc	r1, r15
     7e0:	64 f0       	brlt	.+24     	; 0x7fa <path_logic+0xda>
	{
		return(1);
	}
	else
	{
		path_index--;
     7e2:	80 91 47 02 	lds	r24, 0x0247
     7e6:	90 91 48 02 	lds	r25, 0x0248
     7ea:	01 97       	sbiw	r24, 0x01	; 1
     7ec:	90 93 48 02 	sts	0x0248, r25
     7f0:	80 93 47 02 	sts	0x0247, r24
		return(0);
     7f4:	80 e0       	ldi	r24, 0x00	; 0
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	02 c0       	rjmp	.+4      	; 0x7fe <path_logic+0xde>
			r=r+path_logic(j,req_node);
		}
	}
	if(r>0)
	{
		return(1);
     7fa:	81 e0       	ldi	r24, 0x01	; 1
     7fc:	90 e0       	ldi	r25, 0x00	; 0
	else
	{
		path_index--;
		return(0);
	}
}
     7fe:	df 91       	pop	r29
     800:	cf 91       	pop	r28
     802:	1f 91       	pop	r17
     804:	0f 91       	pop	r16
     806:	ff 90       	pop	r15
     808:	ef 90       	pop	r14
     80a:	df 90       	pop	r13
     80c:	cf 90       	pop	r12
     80e:	bf 90       	pop	r11
     810:	af 90       	pop	r10
     812:	9f 90       	pop	r9
     814:	8f 90       	pop	r8
     816:	08 95       	ret

00000818 <path_find>:
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
{
     818:	0f 93       	push	r16
     81a:	1f 93       	push	r17
     81c:	cf 93       	push	r28
     81e:	df 93       	push	r29
     820:	bc 01       	movw	r22, r24
	int i; 
	if(node_number==8 && req_node==23) // special case for the traversal of the bot from node 8 to node 23.
     822:	80 91 4d 02 	lds	r24, 0x024D
     826:	90 91 4e 02 	lds	r25, 0x024E
     82a:	88 30       	cpi	r24, 0x08	; 8
     82c:	91 05       	cpc	r25, r1
     82e:	a1 f4       	brne	.+40     	; 0x858 <path_find+0x40>
     830:	67 31       	cpi	r22, 0x17	; 23
     832:	71 05       	cpc	r23, r1
     834:	89 f4       	brne	.+34     	; 0x858 <path_find+0x40>
	{
		path[1]='S';
     836:	83 e5       	ldi	r24, 0x53	; 83
     838:	80 93 58 02 	sts	0x0258, r24
		path[2]='W';
     83c:	97 e5       	ldi	r25, 0x57	; 87
     83e:	90 93 59 02 	sts	0x0259, r25
		path[3]='S';
     842:	80 93 5a 02 	sts	0x025A, r24
		path[4]='\0';
     846:	10 92 5b 02 	sts	0x025B, r1
		path_index=1;
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	90 93 48 02 	sts	0x0248, r25
     852:	80 93 47 02 	sts	0x0247, r24
     856:	d0 c0       	rjmp	.+416    	; 0x9f8 <path_find+0x1e0>
	}
	
	else if(path[path_index]=='\0')
     858:	e0 91 47 02 	lds	r30, 0x0247
     85c:	f0 91 48 02 	lds	r31, 0x0248
     860:	e9 5a       	subi	r30, 0xA9	; 169
     862:	fd 4f       	sbci	r31, 0xFD	; 253
     864:	80 81       	ld	r24, Z
     866:	88 23       	and	r24, r24
     868:	09 f0       	breq	.+2      	; 0x86c <path_find+0x54>
     86a:	c3 c0       	rjmp	.+390    	; 0x9f2 <path_find+0x1da>
	{
		cli();
     86c:	f8 94       	cli
		destinationn_node=req_node;
     86e:	70 93 4c 02 	sts	0x024C, r23
     872:	60 93 4b 02 	sts	0x024B, r22
		previous_node=node_number;
     876:	20 91 4d 02 	lds	r18, 0x024D
     87a:	30 91 4e 02 	lds	r19, 0x024E
     87e:	30 93 14 05 	sts	0x0514, r19
     882:	20 93 13 05 	sts	0x0513, r18
     886:	c7 e5       	ldi	r28, 0x57	; 87
     888:	d2 e0       	ldi	r29, 0x02	; 2
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     88a:	8e 01       	movw	r16, r28
     88c:	ce 01       	movw	r24, r28
     88e:	4a 96       	adiw	r24, 0x1a	; 26
     890:	fe 01       	movw	r30, r28
		destinationn_node=req_node;
		previous_node=node_number;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<maximum_number_of_nodes+1;i++)
		path[i]='\0';
     892:	11 92       	st	Z+, r1
		cli();
		destinationn_node=req_node;
		previous_node=node_number;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<maximum_number_of_nodes+1;i++)
     894:	e8 17       	cp	r30, r24
     896:	f9 07       	cpc	r31, r25
     898:	e1 f7       	brne	.-8      	; 0x892 <path_find+0x7a>
		path[i]='\0';
		path_index=1;
     89a:	81 e0       	ldi	r24, 0x01	; 1
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	90 93 48 02 	sts	0x0248, r25
     8a2:	80 93 47 02 	sts	0x0247, r24
		found=0;
     8a6:	10 92 3b 05 	sts	0x053B, r1
     8aa:	10 92 3a 05 	sts	0x053A, r1
		path_logic(node_number,req_node);
     8ae:	c9 01       	movw	r24, r18
     8b0:	0e 94 90 03 	call	0x720	; 0x720 <path_logic>
		path_index--;
     8b4:	20 91 47 02 	lds	r18, 0x0247
     8b8:	30 91 48 02 	lds	r19, 0x0248
     8bc:	21 50       	subi	r18, 0x01	; 1
     8be:	30 40       	sbci	r19, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     8c0:	05 5e       	subi	r16, 0xE5	; 229
     8c2:	1f 4f       	sbci	r17, 0xFF	; 255
		path_index--;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<=maximum_number_of_nodes+1;i++)
		{
			path[i]='\0';
     8c4:	19 92       	st	Y+, r1
		found=0;
		path_logic(node_number,req_node);
		path_index--;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<=maximum_number_of_nodes+1;i++)
     8c6:	c0 17       	cp	r28, r16
     8c8:	d1 07       	cpc	r29, r17
     8ca:	e1 f7       	brne	.-8      	; 0x8c4 <path_find+0xac>
		{
			path[i]='\0';
		}
		
		//i: will iterate from 1 to the length of the path index
		for(i=1;i<=path_index;i++)  
     8cc:	12 16       	cp	r1, r18
     8ce:	13 06       	cpc	r1, r19
     8d0:	64 f4       	brge	.+24     	; 0x8ea <path_find+0xd2>
     8d2:	e2 e7       	ldi	r30, 0x72	; 114
     8d4:	f2 e0       	ldi	r31, 0x02	; 2
     8d6:	a8 e5       	ldi	r26, 0x58	; 88
     8d8:	b2 e0       	ldi	r27, 0x02	; 2
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	90 e0       	ldi	r25, 0x00	; 0
		{
			path[i]=p[i];
     8de:	41 91       	ld	r20, Z+
     8e0:	4d 93       	st	X+, r20
		{
			path[i]='\0';
		}
		
		//i: will iterate from 1 to the length of the path index
		for(i=1;i<=path_index;i++)  
     8e2:	01 96       	adiw	r24, 0x01	; 1
     8e4:	28 17       	cp	r18, r24
     8e6:	39 07       	cpc	r19, r25
     8e8:	d4 f7       	brge	.-12     	; 0x8de <path_find+0xc6>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     8ea:	80 91 58 02 	lds	r24, 0x0258
     8ee:	88 23       	and	r24, r24
     8f0:	31 f4       	brne	.+12     	; 0x8fe <path_find+0xe6>
		for(i=1;i<=path_index;i++)  
		{
			path[i]=p[i];
		}
		path_index=1;
		i=1;
     8f2:	21 e0       	ldi	r18, 0x01	; 1
     8f4:	30 e0       	ldi	r19, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     8f6:	f9 01       	movw	r30, r18
     8f8:	e9 5a       	subi	r30, 0xA9	; 169
     8fa:	fd 4f       	sbci	r31, 0xFD	; 253
     8fc:	2d c0       	rjmp	.+90     	; 0x958 <path_find+0x140>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     8fe:	a8 e5       	ldi	r26, 0x58	; 88
     900:	b2 e0       	ldi	r27, 0x02	; 2
     902:	ed 01       	movw	r28, r26
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	61 e0       	ldi	r22, 0x01	; 1
     90a:	70 e0       	ldi	r23, 0x00	; 0
		for(i=1;i<=path_index;i++)  
		{
			path[i]=p[i];
		}
		path_index=1;
		i=1;
     90c:	21 e0       	ldi	r18, 0x01	; 1
     90e:	30 e0       	ldi	r19, 0x00	; 0
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
		{
			if((path[i]=='E' && path[i+1]=='W') || (path[i]=='W' && path[i+1]=='E'))
			path_index=path_index+2;
			path[i]=path[path_index];
     910:	47 e5       	ldi	r20, 0x57	; 87
     912:	52 e0       	ldi	r21, 0x02	; 2
     914:	01 c0       	rjmp	.+2      	; 0x918 <path_find+0x100>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     916:	bc 01       	movw	r22, r24
		{
			if((path[i]=='E' && path[i+1]=='W') || (path[i]=='W' && path[i+1]=='E'))
     918:	ed 91       	ld	r30, X+
     91a:	e5 34       	cpi	r30, 0x45	; 69
     91c:	21 f4       	brne	.+8      	; 0x926 <path_find+0x10e>
     91e:	ec 91       	ld	r30, X
     920:	e7 35       	cpi	r30, 0x57	; 87
     922:	41 f4       	brne	.+16     	; 0x934 <path_find+0x11c>
     924:	05 c0       	rjmp	.+10     	; 0x930 <path_find+0x118>
     926:	e7 35       	cpi	r30, 0x57	; 87
     928:	29 f4       	brne	.+10     	; 0x934 <path_find+0x11c>
     92a:	ec 91       	ld	r30, X
     92c:	e5 34       	cpi	r30, 0x45	; 69
     92e:	11 f4       	brne	.+4      	; 0x934 <path_find+0x11c>
			path_index=path_index+2;
     930:	cb 01       	movw	r24, r22
     932:	02 96       	adiw	r24, 0x02	; 2
			path[i]=path[path_index];
     934:	fa 01       	movw	r30, r20
     936:	e8 0f       	add	r30, r24
     938:	f9 1f       	adc	r31, r25
     93a:	60 81       	ld	r22, Z
     93c:	69 93       	st	Y+, r22
			i++;
     93e:	2f 5f       	subi	r18, 0xFF	; 255
     940:	3f 4f       	sbci	r19, 0xFF	; 255
			path_index++;
     942:	01 96       	adiw	r24, 0x01	; 1
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     944:	fa 01       	movw	r30, r20
     946:	e8 0f       	add	r30, r24
     948:	f9 1f       	adc	r31, r25
     94a:	60 81       	ld	r22, Z
     94c:	66 23       	and	r22, r22
     94e:	19 f7       	brne	.-58     	; 0x916 <path_find+0xfe>
			i++;
			path_index++;
		}
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
     950:	2b 31       	cpi	r18, 0x1B	; 27
     952:	31 05       	cpc	r19, r1
     954:	84 f2       	brlt	.-96     	; 0x8f6 <path_find+0xde>
     956:	06 c0       	rjmp	.+12     	; 0x964 <path_find+0x14c>
		path[path_index]='\0';
     958:	11 92       	st	Z+, r1
			i++;
			path_index++;
		}
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
     95a:	2f 5f       	subi	r18, 0xFF	; 255
     95c:	3f 4f       	sbci	r19, 0xFF	; 255
     95e:	2b 31       	cpi	r18, 0x1B	; 27
     960:	31 05       	cpc	r19, r1
     962:	d4 f3       	brlt	.-12     	; 0x958 <path_find+0x140>
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     964:	80 91 58 02 	lds	r24, 0x0258
     968:	88 23       	and	r24, r24
     96a:	31 f4       	brne	.+12     	; 0x978 <path_find+0x160>
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
     96c:	41 e0       	ldi	r20, 0x01	; 1
     96e:	50 e0       	ldi	r21, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     970:	fa 01       	movw	r30, r20
     972:	e9 5a       	subi	r30, 0xA9	; 169
     974:	fd 4f       	sbci	r31, 0xFD	; 253
     976:	2f c0       	rjmp	.+94     	; 0x9d6 <path_find+0x1be>
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     978:	a8 e5       	ldi	r26, 0x58	; 88
     97a:	b2 e0       	ldi	r27, 0x02	; 2
     97c:	ed 01       	movw	r28, r26
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	21 e0       	ldi	r18, 0x01	; 1
     984:	30 e0       	ldi	r19, 0x00	; 0
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
     986:	41 e0       	ldi	r20, 0x01	; 1
     988:	50 e0       	ldi	r21, 0x00	; 0
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
		{
			if((path[i]=='S' && path[i+1]=='N') || (path[i]=='N' && path[i+1]=='S'))
			path_index=path_index+2;
			path[i]=path[path_index];
     98a:	67 e5       	ldi	r22, 0x57	; 87
     98c:	72 e0       	ldi	r23, 0x02	; 2
     98e:	01 c0       	rjmp	.+2      	; 0x992 <path_find+0x17a>
			i++;
			path_index++;
     990:	c9 01       	movw	r24, r18
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
		{
			if((path[i]=='S' && path[i+1]=='N') || (path[i]=='N' && path[i+1]=='S'))
     992:	ed 91       	ld	r30, X+
     994:	e3 35       	cpi	r30, 0x53	; 83
     996:	21 f4       	brne	.+8      	; 0x9a0 <path_find+0x188>
     998:	ec 91       	ld	r30, X
     99a:	ee 34       	cpi	r30, 0x4E	; 78
     99c:	41 f4       	brne	.+16     	; 0x9ae <path_find+0x196>
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <path_find+0x192>
     9a0:	ee 34       	cpi	r30, 0x4E	; 78
     9a2:	29 f4       	brne	.+10     	; 0x9ae <path_find+0x196>
     9a4:	ec 91       	ld	r30, X
     9a6:	e3 35       	cpi	r30, 0x53	; 83
     9a8:	11 f4       	brne	.+4      	; 0x9ae <path_find+0x196>
			path_index=path_index+2;
     9aa:	c9 01       	movw	r24, r18
     9ac:	02 96       	adiw	r24, 0x02	; 2
			path[i]=path[path_index];
     9ae:	fb 01       	movw	r30, r22
     9b0:	e8 0f       	add	r30, r24
     9b2:	f9 1f       	adc	r31, r25
     9b4:	20 81       	ld	r18, Z
     9b6:	29 93       	st	Y+, r18
			i++;
     9b8:	4f 5f       	subi	r20, 0xFF	; 255
     9ba:	5f 4f       	sbci	r21, 0xFF	; 255
			path_index++;
     9bc:	9c 01       	movw	r18, r24
     9be:	2f 5f       	subi	r18, 0xFF	; 255
     9c0:	3f 4f       	sbci	r19, 0xFF	; 255
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     9c2:	fb 01       	movw	r30, r22
     9c4:	e2 0f       	add	r30, r18
     9c6:	f3 1f       	adc	r31, r19
     9c8:	80 81       	ld	r24, Z
     9ca:	88 23       	and	r24, r24
     9cc:	09 f7       	brne	.-62     	; 0x990 <path_find+0x178>
			path[i]=path[path_index];
			i++;
			path_index++;
		}
		
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)
     9ce:	4b 31       	cpi	r20, 0x1B	; 27
     9d0:	51 05       	cpc	r21, r1
     9d2:	74 f2       	brlt	.-100    	; 0x970 <path_find+0x158>
     9d4:	06 c0       	rjmp	.+12     	; 0x9e2 <path_find+0x1ca>
		path[path_index]='\0';
     9d6:	11 92       	st	Z+, r1
			path[i]=path[path_index];
			i++;
			path_index++;
		}
		
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)
     9d8:	4f 5f       	subi	r20, 0xFF	; 255
     9da:	5f 4f       	sbci	r21, 0xFF	; 255
     9dc:	4b 31       	cpi	r20, 0x1B	; 27
     9de:	51 05       	cpc	r21, r1
     9e0:	d4 f3       	brlt	.-12     	; 0x9d6 <path_find+0x1be>
		path[path_index]='\0';
		
		path_index=1;
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	90 93 48 02 	sts	0x0248, r25
     9ea:	80 93 47 02 	sts	0x0247, r24
		sei();
     9ee:	78 94       	sei
     9f0:	03 c0       	rjmp	.+6      	; 0x9f8 <path_find+0x1e0>
	}
	else
	{
		enqueue(req_node);   //If the path string is fully occupied then it stores the node( which the bot will traverse) in the queue.
     9f2:	cb 01       	movw	r24, r22
     9f4:	0e 94 4b 01 	call	0x296	; 0x296 <enqueue>
	}
}
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	1f 91       	pop	r17
     9fe:	0f 91       	pop	r16
     a00:	08 95       	ret

00000a02 <enq_end>:
* Example Call:				enq_end(10);
*
*/

void enq_end(int node_added_start)
{
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	8c 01       	movw	r16, r24
	struct queue *newnode;
	if(end==NULL)
     a0c:	c0 91 36 02 	lds	r28, 0x0236
     a10:	d0 91 37 02 	lds	r29, 0x0237
     a14:	20 97       	sbiw	r28, 0x00	; 0
     a16:	a9 f4       	brne	.+42     	; 0xa42 <enq_end+0x40>
	{
		end=(struct queue*)malloc(sizeof(struct queue));
     a18:	86 e0       	ldi	r24, 0x06	; 6
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	0e 94 37 1a 	call	0x346e	; 0x346e <malloc>
     a20:	e8 2f       	mov	r30, r24
     a22:	f9 2f       	mov	r31, r25
     a24:	f0 93 37 02 	sts	0x0237, r31
     a28:	e0 93 36 02 	sts	0x0236, r30
		end->num=node_added_start;
     a2c:	15 83       	std	Z+5, r17	; 0x05
     a2e:	04 83       	std	Z+4, r16	; 0x04
		end->next=NULL;
     a30:	11 82       	std	Z+1, r1	; 0x01
     a32:	10 82       	st	Z, r1
		end->prev=NULL;
     a34:	13 82       	std	Z+3, r1	; 0x03
     a36:	12 82       	std	Z+2, r1	; 0x02
		root=end;
     a38:	f0 93 39 02 	sts	0x0239, r31
     a3c:	e0 93 38 02 	sts	0x0238, r30
     a40:	14 c0       	rjmp	.+40     	; 0xa6a <enq_end+0x68>
	}
	else
	{
		newnode=(struct queue*)malloc(sizeof(struct queue));
     a42:	86 e0       	ldi	r24, 0x06	; 6
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	0e 94 37 1a 	call	0x346e	; 0x346e <malloc>
     a4a:	e8 2f       	mov	r30, r24
     a4c:	f9 2f       	mov	r31, r25
		newnode->num=node_added_start;
     a4e:	15 83       	std	Z+5, r17	; 0x05
     a50:	04 83       	std	Z+4, r16	; 0x04
		end->prev=newnode;
     a52:	fb 83       	std	Y+3, r31	; 0x03
     a54:	ea 83       	std	Y+2, r30	; 0x02
		newnode->next=end;
     a56:	d1 83       	std	Z+1, r29	; 0x01
     a58:	c0 83       	st	Z, r28
		end=end->prev;
     a5a:	8a 81       	ldd	r24, Y+2	; 0x02
     a5c:	9b 81       	ldd	r25, Y+3	; 0x03
     a5e:	90 93 37 02 	sts	0x0237, r25
     a62:	80 93 36 02 	sts	0x0236, r24
		newnode->prev=NULL;
     a66:	13 82       	std	Z+3, r1	; 0x03
     a68:	12 82       	std	Z+2, r1	; 0x02
	}
	que_length++;
     a6a:	80 91 45 02 	lds	r24, 0x0245
     a6e:	90 91 46 02 	lds	r25, 0x0246
     a72:	01 96       	adiw	r24, 0x01	; 1
     a74:	90 93 46 02 	sts	0x0246, r25
     a78:	80 93 45 02 	sts	0x0245, r24
}
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	1f 91       	pop	r17
     a82:	0f 91       	pop	r16
     a84:	08 95       	ret

00000a86 <dequeue>:
*
*/

void dequeue(void)
{
	if(que_length!=0)
     a86:	80 91 45 02 	lds	r24, 0x0245
     a8a:	90 91 46 02 	lds	r25, 0x0246
     a8e:	00 97       	sbiw	r24, 0x00	; 0
     a90:	b1 f0       	breq	.+44     	; 0xabe <dequeue+0x38>
	{
		struct queue *newnode;
		newnode=end;
     a92:	80 91 36 02 	lds	r24, 0x0236
     a96:	90 91 37 02 	lds	r25, 0x0237
		end=end->next;
     a9a:	fc 01       	movw	r30, r24
     a9c:	20 81       	ld	r18, Z
     a9e:	31 81       	ldd	r19, Z+1	; 0x01
     aa0:	30 93 37 02 	sts	0x0237, r19
     aa4:	20 93 36 02 	sts	0x0236, r18
		free(newnode);
     aa8:	0e 94 cd 1a 	call	0x359a	; 0x359a <free>
		que_length--;
     aac:	80 91 45 02 	lds	r24, 0x0245
     ab0:	90 91 46 02 	lds	r25, 0x0246
     ab4:	01 97       	sbiw	r24, 0x01	; 1
     ab6:	90 93 46 02 	sts	0x0246, r25
     aba:	80 93 45 02 	sts	0x0245, r24
     abe:	08 95       	ret

00000ac0 <buzzer>:
*
*/

void buzzer(int a)
{
	DDRC=0xFF;			  //Buzzer is connected to pin no 3 of port c
     ac0:	2f ef       	ldi	r18, 0xFF	; 255
     ac2:	27 b9       	out	0x07, r18	; 7
	if(a==1)
     ac4:	81 30       	cpi	r24, 0x01	; 1
     ac6:	91 05       	cpc	r25, r1
     ac8:	11 f4       	brne	.+4      	; 0xace <buzzer+0xe>
	PORTC=PORTC|0b00001000;
     aca:	43 9a       	sbi	0x08, 3	; 8
     acc:	08 95       	ret
	else if(a==0)
     ace:	00 97       	sbiw	r24, 0x00	; 0
     ad0:	09 f4       	brne	.+2      	; 0xad4 <buzzer+0x14>
	PORTC=PORTC & 0b11110111;
     ad2:	43 98       	cbi	0x08, 3	; 8
     ad4:	08 95       	ret

00000ad6 <lcd_port_config>:
*
*/

void lcd_port_config (void)
{
	cli();
     ad6:	f8 94       	cli
	DDRC = DDRC | 0xF7;		 //all the LCD pin's direction set as output
     ad8:	87 b1       	in	r24, 0x07	; 7
     ada:	87 6f       	ori	r24, 0xF7	; 247
     adc:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80;	 // all the LCD pins are set to logic 0 except PORTC 7
     ade:	88 b1       	in	r24, 0x08	; 8
     ae0:	80 78       	andi	r24, 0x80	; 128
     ae2:	88 b9       	out	0x08, r24	; 8
	sei();
     ae4:	78 94       	sei
}
     ae6:	08 95       	ret

00000ae8 <motion>:
*
*/

void motion(char movement)
{
	DDRA=DDRA | 0X0F; // Port A pin no 0,1,2,3 are for motion controlling
     ae8:	91 b1       	in	r25, 0x01	; 1
     aea:	9f 60       	ori	r25, 0x0F	; 15
     aec:	91 b9       	out	0x01, r25	; 1
	if(movement=='f')
     aee:	86 36       	cpi	r24, 0x66	; 102
     af0:	19 f4       	brne	.+6      	; 0xaf8 <motion+0x10>
	PORTA=0b00000110;
     af2:	86 e0       	ldi	r24, 0x06	; 6
     af4:	82 b9       	out	0x02, r24	; 2
     af6:	08 95       	ret
	else if(movement=='b')
     af8:	82 36       	cpi	r24, 0x62	; 98
     afa:	19 f4       	brne	.+6      	; 0xb02 <motion+0x1a>
	PORTA=0b00001001;
     afc:	89 e0       	ldi	r24, 0x09	; 9
     afe:	82 b9       	out	0x02, r24	; 2
     b00:	08 95       	ret
	else if(movement=='l')
     b02:	8c 36       	cpi	r24, 0x6C	; 108
     b04:	19 f4       	brne	.+6      	; 0xb0c <motion+0x24>
	PORTA=0b00000101;
     b06:	85 e0       	ldi	r24, 0x05	; 5
     b08:	82 b9       	out	0x02, r24	; 2
     b0a:	08 95       	ret
	else if(movement=='r')
     b0c:	82 37       	cpi	r24, 0x72	; 114
     b0e:	19 f4       	brne	.+6      	; 0xb16 <motion+0x2e>
	PORTA=0b00001010;
     b10:	8a e0       	ldi	r24, 0x0A	; 10
     b12:	82 b9       	out	0x02, r24	; 2
     b14:	08 95       	ret
	else if('s')
	PORTA=0x00;
     b16:	12 b8       	out	0x02, r1	; 2
     b18:	08 95       	ret

00000b1a <sppeed_config>:
*
*/

void sppeed_config(void)
{
	cli();
     b1a:	f8 94       	cli
	DDRA=DDRA|0x0F;
     b1c:	81 b1       	in	r24, 0x01	; 1
     b1e:	8f 60       	ori	r24, 0x0F	; 15
     b20:	81 b9       	out	0x01, r24	; 1
	DDRL=DDRL | 0b00011000;			// declaring pin mo Pl3 and Pl4 as output
     b22:	ea e0       	ldi	r30, 0x0A	; 10
     b24:	f1 e0       	ldi	r31, 0x01	; 1
     b26:	80 81       	ld	r24, Z
     b28:	88 61       	ori	r24, 0x18	; 24
     b2a:	80 83       	st	Z, r24
	PORTL=PORTL|0b00011000;			// if Output Compare pins are disconnected than output Will be one at these pins
     b2c:	eb e0       	ldi	r30, 0x0B	; 11
     b2e:	f1 e0       	ldi	r31, 0x01	; 1
     b30:	80 81       	ld	r24, Z
     b32:	88 61       	ori	r24, 0x18	; 24
     b34:	80 83       	st	Z, r24
	TCNT5=0x00FF;					// initial value of counter
     b36:	8f ef       	ldi	r24, 0xFF	; 255
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	90 93 25 01 	sts	0x0125, r25
     b3e:	80 93 24 01 	sts	0x0124, r24
	TCCR5A=TCCR5A | 0b10101001;		// Timer counter control register
     b42:	e0 e2       	ldi	r30, 0x20	; 32
     b44:	f1 e0       	ldi	r31, 0x01	; 1
     b46:	80 81       	ld	r24, Z
     b48:	89 6a       	ori	r24, 0xA9	; 169
     b4a:	80 83       	st	Z, r24
	TCCR5B=TCCR5B | 0b00001011;
     b4c:	e1 e2       	ldi	r30, 0x21	; 33
     b4e:	f1 e0       	ldi	r31, 0x01	; 1
     b50:	80 81       	ld	r24, Z
     b52:	8b 60       	ori	r24, 0x0B	; 11
     b54:	80 83       	st	Z, r24
	sppeed(255,249);
     b56:	8f ef       	ldi	r24, 0xFF	; 255
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	69 ef       	ldi	r22, 0xF9	; 249
     b5c:	70 e0       	ldi	r23, 0x00	; 0
     b5e:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	sei();
     b62:	78 94       	sei
}
     b64:	08 95       	ret

00000b66 <distance>:
* Example Call:				distance('f',11,'o');
*
*/

void distance(char a,float cm,char iop)
{
     b66:	cf 92       	push	r12
     b68:	df 92       	push	r13
     b6a:	ef 92       	push	r14
     b6c:	ff 92       	push	r15
     b6e:	1f 93       	push	r17
     b70:	cf 93       	push	r28
     b72:	df 93       	push	r29
     b74:	c8 2f       	mov	r28, r24
     b76:	6a 01       	movw	r12, r20
     b78:	7b 01       	movw	r14, r22
	sppeed(255,249);
     b7a:	8f ef       	ldi	r24, 0xFF	; 255
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	69 ef       	ldi	r22, 0xF9	; 249
     b80:	70 e0       	ldi	r23, 0x00	; 0
     b82:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	float b=0;
	right_position_encode=0; //clearing encoder value
     b86:	10 92 4f 02 	sts	0x024F, r1
     b8a:	10 92 50 02 	sts	0x0250, r1
     b8e:	10 92 51 02 	sts	0x0251, r1
     b92:	10 92 52 02 	sts	0x0252, r1
	left_position_encode=0;
     b96:	10 92 53 02 	sts	0x0253, r1
     b9a:	10 92 54 02 	sts	0x0254, r1
     b9e:	10 92 55 02 	sts	0x0255, r1
     ba2:	10 92 56 02 	sts	0x0256, r1
*/

void distance(char a,float cm,char iop)
{
	sppeed(255,249);
	float b=0;
     ba6:	60 e0       	ldi	r22, 0x00	; 0
     ba8:	70 e0       	ldi	r23, 0x00	; 0
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	90 e0       	ldi	r25, 0x00	; 0
		{
			PORTA=0b00000110;
		}
		else if(a=='b')
		{
			PORTA=0b00001001;
     bae:	19 e0       	ldi	r17, 0x09	; 9
	left_position_encode=0;
	while((ceil(b))<(cm))
	{
		if(a=='f')
		{
			PORTA=0b00000110;
     bb0:	d6 e0       	ldi	r29, 0x06	; 6
{
	sppeed(255,249);
	float b=0;
	right_position_encode=0; //clearing encoder value
	left_position_encode=0;
	while((ceil(b))<(cm))
     bb2:	17 c0       	rjmp	.+46     	; 0xbe2 <distance+0x7c>
	{
		if(a=='f')
     bb4:	c6 36       	cpi	r28, 0x66	; 102
     bb6:	11 f4       	brne	.+4      	; 0xbbc <distance+0x56>
		{
			PORTA=0b00000110;
     bb8:	d2 b9       	out	0x02, r29	; 2
     bba:	03 c0       	rjmp	.+6      	; 0xbc2 <distance+0x5c>
		}
		else if(a=='b')
     bbc:	c2 36       	cpi	r28, 0x62	; 98
     bbe:	09 f4       	brne	.+2      	; 0xbc2 <distance+0x5c>
		{
			PORTA=0b00001001;
     bc0:	12 b9       	out	0x02, r17	; 2

		}
		b=0.5413*right_position_encode; // feedback constant value
     bc2:	60 91 4f 02 	lds	r22, 0x024F
     bc6:	70 91 50 02 	lds	r23, 0x0250
     bca:	80 91 51 02 	lds	r24, 0x0251
     bce:	90 91 52 02 	lds	r25, 0x0252
     bd2:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <__floatunsisf>
     bd6:	23 ea       	ldi	r18, 0xA3	; 163
     bd8:	32 e9       	ldi	r19, 0x92	; 146
     bda:	4a e0       	ldi	r20, 0x0A	; 10
     bdc:	5f e3       	ldi	r21, 0x3F	; 63
     bde:	0e 94 4a 18 	call	0x3094	; 0x3094 <__mulsf3>
{
	sppeed(255,249);
	float b=0;
	right_position_encode=0; //clearing encoder value
	left_position_encode=0;
	while((ceil(b))<(cm))
     be2:	38 2f       	mov	r19, r24
     be4:	29 2f       	mov	r18, r25
     be6:	86 2f       	mov	r24, r22
     be8:	97 2f       	mov	r25, r23
     bea:	a3 2f       	mov	r26, r19
     bec:	b2 2f       	mov	r27, r18
     bee:	bc 01       	movw	r22, r24
     bf0:	cd 01       	movw	r24, r26
     bf2:	0e 94 a8 16 	call	0x2d50	; 0x2d50 <ceil>
     bf6:	a7 01       	movw	r20, r14
     bf8:	96 01       	movw	r18, r12
     bfa:	0e 94 bb 16 	call	0x2d76	; 0x2d76 <__cmpsf2>
     bfe:	88 23       	and	r24, r24
     c00:	cc f2       	brlt	.-78     	; 0xbb4 <distance+0x4e>
			PORTA=0b00001001;

		}
		b=0.5413*right_position_encode; // feedback constant value
	}
	stop();
     c02:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
}
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	ff 90       	pop	r15
     c0e:	ef 90       	pop	r14
     c10:	df 90       	pop	r13
     c12:	cf 90       	pop	r12
     c14:	08 95       	ret

00000c16 <motion_pin_config>:
*
*/

void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     c16:	81 b1       	in	r24, 0x01	; 1
     c18:	8f 60       	ori	r24, 0x0F	; 15
     c1a:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     c1c:	82 b1       	in	r24, 0x02	; 2
     c1e:	80 7f       	andi	r24, 0xF0	; 240
     c20:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;			//Setting PL3 and PL4 pins as output for PWM generation
     c22:	ea e0       	ldi	r30, 0x0A	; 10
     c24:	f1 e0       	ldi	r31, 0x01	; 1
     c26:	80 81       	ld	r24, Z
     c28:	88 61       	ori	r24, 0x18	; 24
     c2a:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18;		//PL3 and PL4 pins are for velocity control using PWM.
     c2c:	eb e0       	ldi	r30, 0x0B	; 11
     c2e:	f1 e0       	ldi	r31, 0x01	; 1
     c30:	80 81       	ld	r24, Z
     c32:	88 61       	ori	r24, 0x18	; 24
     c34:	80 83       	st	Z, r24
	OCR5A=0x00FF;
     c36:	8f ef       	ldi	r24, 0xFF	; 255
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	90 93 29 01 	sts	0x0129, r25
     c3e:	80 93 28 01 	sts	0x0128, r24
	OCR5B=0x00FF;
     c42:	90 93 2b 01 	sts	0x012B, r25
     c46:	80 93 2a 01 	sts	0x012A, r24
}
     c4a:	08 95       	ret

00000c4c <left_encoder_pin_config>:
*
*/

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     c4c:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     c4e:	74 9a       	sbi	0x0e, 4	; 14
}
     c50:	08 95       	ret

00000c52 <right_encoder_pin_config>:
*
*/

void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;		//Set the direction of the PORTE 4 pin as input
     c52:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20;		//Enable internal pull-up for PORTE 4 pin
     c54:	75 9a       	sbi	0x0e, 5	; 14
}
     c56:	08 95       	ret

00000c58 <port_init>:
*
*/

void port_init()
{
	motion_pin_config(); //robot motion pins config
     c58:	0e 94 0b 06 	call	0xc16	; 0xc16 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     c5c:	0e 94 26 06 	call	0xc4c	; 0xc4c <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     c60:	0e 94 29 06 	call	0xc52	; 0xc52 <right_encoder_pin_config>
}
     c64:	08 95       	ret

00000c66 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 						// removing upper nibble for the protection
	PortARestore = PORTA; 					// reading the PORTA original status
     c66:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 					// making lower direction nibble to 0
     c68:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 						// removing upper nibble for the protection
     c6a:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 					// reading the PORTA original status
	PortARestore &= 0xF0; 					// making lower direction nibble to 0
	PortARestore |= Direction;				// adding lower nibble for forward command and restoring the PORTA status
     c6c:	98 2b       	or	r25, r24
	PORTA = PortARestore; 					// executing the command
     c6e:	92 b9       	out	0x02, r25	; 2
}
     c70:	08 95       	ret

00000c72 <stop>:
*
*/

void stop (void)
{
	motion_set(0x00);
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	0e 94 33 06 	call	0xc66	; 0xc66 <motion_set>
	//_delay_ms(1000);
}
     c78:	08 95       	ret

00000c7a <left>:
*
*/

void left (void) 
{
	motion_set(0x05);
     c7a:	85 e0       	ldi	r24, 0x05	; 5
     c7c:	0e 94 33 06 	call	0xc66	; 0xc66 <motion_set>
}
     c80:	08 95       	ret

00000c82 <right>:
*
*/

void right (void) 
{
	motion_set(0x0A);
     c82:	8a e0       	ldi	r24, 0x0A	; 10
     c84:	0e 94 33 06 	call	0xc66	; 0xc66 <motion_set>
}
     c88:	08 95       	ret

00000c8a <soft_left>:
*
*/

void soft_left (void) 
{
	motion_set(0x04);
     c8a:	84 e0       	ldi	r24, 0x04	; 4
     c8c:	0e 94 33 06 	call	0xc66	; 0xc66 <motion_set>
}
     c90:	08 95       	ret

00000c92 <soft_right>:
*
*/

void soft_right (void) 
{
	motion_set(0x02);
     c92:	82 e0       	ldi	r24, 0x02	; 2
     c94:	0e 94 33 06 	call	0xc66	; 0xc66 <motion_set>
}
     c98:	08 95       	ret

00000c9a <angle_rotate>:
* Example Call:				angle_rotate(90);
*
*/

void angle_rotate(unsigned int Degrees)
{
     c9a:	0f 93       	push	r16
     c9c:	1f 93       	push	r17
     c9e:	cf 93       	push	r28
     ca0:	df 93       	push	r29
     ca2:	ec 01       	movw	r28, r24
	sppeed(255,249);  //sets the speed of motors
     ca4:	8f ef       	ldi	r24, 0xFF	; 255
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	69 ef       	ldi	r22, 0xF9	; 249
     caa:	70 e0       	ldi	r23, 0x00	; 0
     cac:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;
	if(node_number==15 || node_number==16 || node_number==17)
     cb0:	80 91 4d 02 	lds	r24, 0x024D
     cb4:	90 91 4e 02 	lds	r25, 0x024E
     cb8:	0f 97       	sbiw	r24, 0x0f	; 15
     cba:	83 30       	cpi	r24, 0x03	; 3
     cbc:	91 05       	cpc	r25, r1
     cbe:	60 f4       	brcc	.+24     	; 0xcd8 <angle_rotate+0x3e>
	ReqdShaftCount = (float) Degrees/ 4.60;
     cc0:	be 01       	movw	r22, r28
     cc2:	80 e0       	ldi	r24, 0x00	; 0
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <__floatunsisf>
     cca:	23 e3       	ldi	r18, 0x33	; 51
     ccc:	33 e3       	ldi	r19, 0x33	; 51
     cce:	43 e9       	ldi	r20, 0x93	; 147
     cd0:	50 e4       	ldi	r21, 0x40	; 64
     cd2:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <__divsf3>
     cd6:	0b c0       	rjmp	.+22     	; 0xcee <angle_rotate+0x54>
	else
	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     cd8:	be 01       	movw	r22, r28
     cda:	80 e0       	ldi	r24, 0x00	; 0
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <__floatunsisf>
     ce2:	28 e4       	ldi	r18, 0x48	; 72
     ce4:	31 ee       	ldi	r19, 0xE1	; 225
     ce6:	42 e8       	ldi	r20, 0x82	; 130
     ce8:	50 e4       	ldi	r21, 0x40	; 64
     cea:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     cee:	38 2f       	mov	r19, r24
     cf0:	29 2f       	mov	r18, r25
     cf2:	86 2f       	mov	r24, r22
     cf4:	97 2f       	mov	r25, r23
     cf6:	a3 2f       	mov	r26, r19
     cf8:	b2 2f       	mov	r27, r18
     cfa:	bc 01       	movw	r22, r24
     cfc:	cd 01       	movw	r24, r26
     cfe:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <__fixunssfsi>
     d02:	dc 01       	movw	r26, r24
     d04:	cb 01       	movw	r24, r22
     d06:	a0 e0       	ldi	r26, 0x00	; 0
     d08:	b0 e0       	ldi	r27, 0x00	; 0
	right_position_encode = 0;
     d0a:	10 92 4f 02 	sts	0x024F, r1
     d0e:	10 92 50 02 	sts	0x0250, r1
     d12:	10 92 51 02 	sts	0x0251, r1
     d16:	10 92 52 02 	sts	0x0252, r1
	left_position_encode = 0;
     d1a:	10 92 53 02 	sts	0x0253, r1
     d1e:	10 92 54 02 	sts	0x0254, r1
     d22:	10 92 55 02 	sts	0x0255, r1
     d26:	10 92 56 02 	sts	0x0256, r1
	while (1)
	{
		if((right_position_encode >= ReqdShaftCountInt) | (left_position_encode >= ReqdShaftCountInt))
     d2a:	f1 e0       	ldi	r31, 0x01	; 1
     d2c:	c0 e0       	ldi	r28, 0x00	; 0
     d2e:	40 91 4f 02 	lds	r20, 0x024F
     d32:	50 91 50 02 	lds	r21, 0x0250
     d36:	60 91 51 02 	lds	r22, 0x0251
     d3a:	70 91 52 02 	lds	r23, 0x0252
     d3e:	00 91 53 02 	lds	r16, 0x0253
     d42:	10 91 54 02 	lds	r17, 0x0254
     d46:	20 91 55 02 	lds	r18, 0x0255
     d4a:	30 91 56 02 	lds	r19, 0x0256
     d4e:	ef 2f       	mov	r30, r31
     d50:	48 17       	cp	r20, r24
     d52:	59 07       	cpc	r21, r25
     d54:	6a 07       	cpc	r22, r26
     d56:	7b 07       	cpc	r23, r27
     d58:	08 f4       	brcc	.+2      	; 0xd5c <angle_rotate+0xc2>
     d5a:	ec 2f       	mov	r30, r28
     d5c:	ee 23       	and	r30, r30
     d5e:	49 f4       	brne	.+18     	; 0xd72 <angle_rotate+0xd8>
     d60:	4f 2f       	mov	r20, r31
     d62:	08 17       	cp	r16, r24
     d64:	19 07       	cpc	r17, r25
     d66:	2a 07       	cpc	r18, r26
     d68:	3b 07       	cpc	r19, r27
     d6a:	08 f4       	brcc	.+2      	; 0xd6e <angle_rotate+0xd4>
     d6c:	4c 2f       	mov	r20, r28
     d6e:	44 23       	and	r20, r20
     d70:	f1 f2       	breq	.-68     	; 0xd2e <angle_rotate+0x94>
		break;
	}
	stop(); //Stop robot
     d72:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
	navigate();   //navigate the bot after rotating
     d76:	0e 94 02 01 	call	0x204	; 0x204 <navigate>
}
     d7a:	df 91       	pop	r29
     d7c:	cf 91       	pop	r28
     d7e:	1f 91       	pop	r17
     d80:	0f 91       	pop	r16
     d82:	08 95       	ret

00000d84 <left_degrees>:
* Example Call:				left_degrees(90);
*
*/

void left_degrees(unsigned int Degrees)
{
     d84:	ef 92       	push	r14
     d86:	ff 92       	push	r15
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees = navigation_in_degrees + Degrees;
     d92:	80 91 2a 02 	lds	r24, 0x022A
     d96:	90 91 2b 02 	lds	r25, 0x022B
     d9a:	8c 0f       	add	r24, r28
     d9c:	9d 1f       	adc	r25, r29
     d9e:	90 93 2b 02 	sts	0x022B, r25
     da2:	80 93 2a 02 	sts	0x022A, r24
	left(); //Turn left
     da6:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
	angle_rotate(Degrees);
     daa:	ce 01       	movw	r24, r28
     dac:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
	while(digital[2]<15 && digital[1]<15 && digital[3]<15)
     db0:	80 91 1e 05 	lds	r24, 0x051E
     db4:	90 91 1f 05 	lds	r25, 0x051F
     db8:	8f 30       	cpi	r24, 0x0F	; 15
     dba:	91 05       	cpc	r25, r1
     dbc:	08 f0       	brcs	.+2      	; 0xdc0 <left_degrees+0x3c>
     dbe:	40 c0       	rjmp	.+128    	; 0xe40 <left_degrees+0xbc>
     dc0:	80 91 1c 05 	lds	r24, 0x051C
     dc4:	90 91 1d 05 	lds	r25, 0x051D
     dc8:	8f 30       	cpi	r24, 0x0F	; 15
     dca:	91 05       	cpc	r25, r1
     dcc:	c8 f5       	brcc	.+114    	; 0xe40 <left_degrees+0xbc>
     dce:	80 91 20 05 	lds	r24, 0x0520
     dd2:	90 91 21 05 	lds	r25, 0x0521
     dd6:	8f 30       	cpi	r24, 0x0F	; 15
     dd8:	91 05       	cpc	r25, r1
     dda:	90 f5       	brcc	.+100    	; 0xe40 <left_degrees+0xbc>
     ddc:	ce e1       	ldi	r28, 0x1E	; 30
     dde:	d5 e0       	ldi	r29, 0x05	; 5
     de0:	0c e1       	ldi	r16, 0x1C	; 28
     de2:	15 e0       	ldi	r17, 0x05	; 5
     de4:	0f 2e       	mov	r0, r31
     de6:	f0 e2       	ldi	r31, 0x20	; 32
     de8:	ef 2e       	mov	r14, r31
     dea:	f5 e0       	ldi	r31, 0x05	; 5
     dec:	ff 2e       	mov	r15, r31
     dee:	f0 2d       	mov	r31, r0
	{
		sppeed(255,249);
     df0:	8f ef       	ldi	r24, 0xFF	; 255
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	69 ef       	ldi	r22, 0xF9	; 249
     df6:	70 e0       	ldi	r23, 0x00	; 0
     df8:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		if(node_number==10 || node_number==0)
     dfc:	80 91 4d 02 	lds	r24, 0x024D
     e00:	90 91 4e 02 	lds	r25, 0x024E
     e04:	8a 30       	cpi	r24, 0x0A	; 10
     e06:	91 05       	cpc	r25, r1
     e08:	11 f0       	breq	.+4      	; 0xe0e <left_degrees+0x8a>
     e0a:	00 97       	sbiw	r24, 0x00	; 0
     e0c:	31 f4       	brne	.+12     	; 0xe1a <left_degrees+0x96>
		sppeed(180,174);
     e0e:	84 eb       	ldi	r24, 0xB4	; 180
     e10:	90 e0       	ldi	r25, 0x00	; 0
     e12:	6e ea       	ldi	r22, 0xAE	; 174
     e14:	70 e0       	ldi	r23, 0x00	; 0
     e16:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		left();
     e1a:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees = navigation_in_degrees + Degrees;
	left(); //Turn left
	angle_rotate(Degrees);
	while(digital[2]<15 && digital[1]<15 && digital[3]<15)
     e1e:	88 81       	ld	r24, Y
     e20:	99 81       	ldd	r25, Y+1	; 0x01
     e22:	8f 30       	cpi	r24, 0x0F	; 15
     e24:	91 05       	cpc	r25, r1
     e26:	60 f4       	brcc	.+24     	; 0xe40 <left_degrees+0xbc>
     e28:	f8 01       	movw	r30, r16
     e2a:	80 81       	ld	r24, Z
     e2c:	91 81       	ldd	r25, Z+1	; 0x01
     e2e:	8f 30       	cpi	r24, 0x0F	; 15
     e30:	91 05       	cpc	r25, r1
     e32:	30 f4       	brcc	.+12     	; 0xe40 <left_degrees+0xbc>
     e34:	f7 01       	movw	r30, r14
     e36:	80 81       	ld	r24, Z
     e38:	91 81       	ldd	r25, Z+1	; 0x01
     e3a:	8f 30       	cpi	r24, 0x0F	; 15
     e3c:	91 05       	cpc	r25, r1
     e3e:	c0 f2       	brcs	.-80     	; 0xdf0 <left_degrees+0x6c>
		sppeed(255,249);
		if(node_number==10 || node_number==0)
		sppeed(180,174);
		left();
	}
	stop();
     e40:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
}
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	ff 90       	pop	r15
     e4e:	ef 90       	pop	r14
     e50:	08 95       	ret

00000e52 <right_degrees>:
* Example Call:				right_degrees(90);
*
*/

void right_degrees(unsigned int Degrees)
{
     e52:	ef 92       	push	r14
     e54:	ff 92       	push	r15
     e56:	0f 93       	push	r16
     e58:	1f 93       	push	r17
     e5a:	cf 93       	push	r28
     e5c:	df 93       	push	r29
     e5e:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees=navigation_in_degrees-Degrees;
     e60:	80 91 2a 02 	lds	r24, 0x022A
     e64:	90 91 2b 02 	lds	r25, 0x022B
     e68:	8c 1b       	sub	r24, r28
     e6a:	9d 0b       	sbc	r25, r29
     e6c:	90 93 2b 02 	sts	0x022B, r25
     e70:	80 93 2a 02 	sts	0x022A, r24
	right(); //Turn right
     e74:	0e 94 41 06 	call	0xc82	; 0xc82 <right>
	angle_rotate(Degrees);
     e78:	ce 01       	movw	r24, r28
     e7a:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
	while(digital[2]<15 && digital[3]<15 && digital[1]<15)
     e7e:	80 91 1e 05 	lds	r24, 0x051E
     e82:	90 91 1f 05 	lds	r25, 0x051F
     e86:	8f 30       	cpi	r24, 0x0F	; 15
     e88:	91 05       	cpc	r25, r1
     e8a:	08 f0       	brcs	.+2      	; 0xe8e <right_degrees+0x3c>
     e8c:	40 c0       	rjmp	.+128    	; 0xf0e <right_degrees+0xbc>
     e8e:	80 91 20 05 	lds	r24, 0x0520
     e92:	90 91 21 05 	lds	r25, 0x0521
     e96:	8f 30       	cpi	r24, 0x0F	; 15
     e98:	91 05       	cpc	r25, r1
     e9a:	c8 f5       	brcc	.+114    	; 0xf0e <right_degrees+0xbc>
     e9c:	80 91 1c 05 	lds	r24, 0x051C
     ea0:	90 91 1d 05 	lds	r25, 0x051D
     ea4:	8f 30       	cpi	r24, 0x0F	; 15
     ea6:	91 05       	cpc	r25, r1
     ea8:	90 f5       	brcc	.+100    	; 0xf0e <right_degrees+0xbc>
     eaa:	ce e1       	ldi	r28, 0x1E	; 30
     eac:	d5 e0       	ldi	r29, 0x05	; 5
     eae:	00 e2       	ldi	r16, 0x20	; 32
     eb0:	15 e0       	ldi	r17, 0x05	; 5
     eb2:	0f 2e       	mov	r0, r31
     eb4:	fc e1       	ldi	r31, 0x1C	; 28
     eb6:	ef 2e       	mov	r14, r31
     eb8:	f5 e0       	ldi	r31, 0x05	; 5
     eba:	ff 2e       	mov	r15, r31
     ebc:	f0 2d       	mov	r31, r0
	{
		sppeed(255,249);
     ebe:	8f ef       	ldi	r24, 0xFF	; 255
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	69 ef       	ldi	r22, 0xF9	; 249
     ec4:	70 e0       	ldi	r23, 0x00	; 0
     ec6:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		if(node_number==10 || node_number==0)
     eca:	80 91 4d 02 	lds	r24, 0x024D
     ece:	90 91 4e 02 	lds	r25, 0x024E
     ed2:	8a 30       	cpi	r24, 0x0A	; 10
     ed4:	91 05       	cpc	r25, r1
     ed6:	11 f0       	breq	.+4      	; 0xedc <right_degrees+0x8a>
     ed8:	00 97       	sbiw	r24, 0x00	; 0
     eda:	31 f4       	brne	.+12     	; 0xee8 <right_degrees+0x96>
		sppeed(180,174);
     edc:	84 eb       	ldi	r24, 0xB4	; 180
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	6e ea       	ldi	r22, 0xAE	; 174
     ee2:	70 e0       	ldi	r23, 0x00	; 0
     ee4:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		right();
     ee8:	0e 94 41 06 	call	0xc82	; 0xc82 <right>
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees=navigation_in_degrees-Degrees;
	right(); //Turn right
	angle_rotate(Degrees);
	while(digital[2]<15 && digital[3]<15 && digital[1]<15)
     eec:	88 81       	ld	r24, Y
     eee:	99 81       	ldd	r25, Y+1	; 0x01
     ef0:	8f 30       	cpi	r24, 0x0F	; 15
     ef2:	91 05       	cpc	r25, r1
     ef4:	60 f4       	brcc	.+24     	; 0xf0e <right_degrees+0xbc>
     ef6:	f8 01       	movw	r30, r16
     ef8:	80 81       	ld	r24, Z
     efa:	91 81       	ldd	r25, Z+1	; 0x01
     efc:	8f 30       	cpi	r24, 0x0F	; 15
     efe:	91 05       	cpc	r25, r1
     f00:	30 f4       	brcc	.+12     	; 0xf0e <right_degrees+0xbc>
     f02:	f7 01       	movw	r30, r14
     f04:	80 81       	ld	r24, Z
     f06:	91 81       	ldd	r25, Z+1	; 0x01
     f08:	8f 30       	cpi	r24, 0x0F	; 15
     f0a:	91 05       	cpc	r25, r1
     f0c:	c0 f2       	brcs	.-80     	; 0xebe <right_degrees+0x6c>
		sppeed(255,249);
		if(node_number==10 || node_number==0)
		sppeed(180,174);
		right();
	}
	stop();
     f0e:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
}
     f12:	df 91       	pop	r29
     f14:	cf 91       	pop	r28
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	ff 90       	pop	r15
     f1c:	ef 90       	pop	r14
     f1e:	08 95       	ret

00000f20 <soft_left_degrees>:
* Example Call:				soft_left_degrees(90);
*
*/

void soft_left_degrees(unsigned int Degrees)
{
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	ec 01       	movw	r28, r24
	navigation_in_degrees=navigation_in_degrees+Degrees;
     f26:	80 91 2a 02 	lds	r24, 0x022A
     f2a:	90 91 2b 02 	lds	r25, 0x022B
     f2e:	8c 0f       	add	r24, r28
     f30:	9d 1f       	adc	r25, r29
     f32:	90 93 2b 02 	sts	0x022B, r25
     f36:	80 93 2a 02 	sts	0x022A, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     f3a:	0e 94 45 06 	call	0xc8a	; 0xc8a <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     f3e:	ce 01       	movw	r24, r28
     f40:	88 0f       	add	r24, r24
     f42:	99 1f       	adc	r25, r25
     f44:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
}
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	08 95       	ret

00000f4e <soft_right_degrees>:
* Example Call:				soft_right_degrees(90);
*
*/

void soft_right_degrees(unsigned int Degrees)
{
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
     f52:	ec 01       	movw	r28, r24
	navigation_in_degrees=navigation_in_degrees-Degrees;
     f54:	80 91 2a 02 	lds	r24, 0x022A
     f58:	90 91 2b 02 	lds	r25, 0x022B
     f5c:	8c 1b       	sub	r24, r28
     f5e:	9d 0b       	sbc	r25, r29
     f60:	90 93 2b 02 	sts	0x022B, r25
     f64:	80 93 2a 02 	sts	0x022A, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     f68:	0e 94 49 06 	call	0xc92	; 0xc92 <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     f6c:	ce 01       	movw	r24, r28
     f6e:	88 0f       	add	r24, r24
     f70:	99 1f       	adc	r25, r25
     f72:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
}
     f76:	df 91       	pop	r29
     f78:	cf 91       	pop	r28
     f7a:	08 95       	ret

00000f7c <INT_position>:
*
*/

void INT_position(void)
{
	cli(); //Clears the global interrupt
     f7c:	f8 94       	cli
	port_init();  //Initializes all the ports
     f7e:	0e 94 2c 06 	call	0xc58	; 0xc58 <port_init>
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     f82:	ea e6       	ldi	r30, 0x6A	; 106
     f84:	f0 e0       	ldi	r31, 0x00	; 0
     f86:	80 81       	ld	r24, Z
     f88:	88 60       	ori	r24, 0x08	; 8
     f8a:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     f8c:	ed 9a       	sbi	0x1d, 5	; 29
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     f8e:	80 81       	ld	r24, Z
     f90:	82 60       	ori	r24, 0x02	; 2
     f92:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     f94:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     f96:	78 94       	sei
}
     f98:	08 95       	ret

00000f9a <servo_config>:
*
*/

void servo_config(void)
{
	cli();
     f9a:	f8 94       	cli
	TCNT1=0x0000;							// set starting value of counter
     f9c:	10 92 85 00 	sts	0x0085, r1
     fa0:	10 92 84 00 	sts	0x0084, r1
	ICR1=1150;								// set top value of counter
     fa4:	8e e7       	ldi	r24, 0x7E	; 126
     fa6:	94 e0       	ldi	r25, 0x04	; 4
     fa8:	90 93 87 00 	sts	0x0087, r25
     fac:	80 93 86 00 	sts	0x0086, r24
	TCCR1A=0b10101010;						// counter configuring
     fb0:	2a ea       	ldi	r18, 0xAA	; 170
     fb2:	20 93 80 00 	sts	0x0080, r18
	TCCR1B=0b00011100;
     fb6:	2c e1       	ldi	r18, 0x1C	; 28
     fb8:	20 93 81 00 	sts	0x0081, r18
	DDRB=DDRB|0b11100000;					// set Output Compare pins as output pins
     fbc:	24 b1       	in	r18, 0x04	; 4
     fbe:	20 6e       	ori	r18, 0xE0	; 224
     fc0:	24 b9       	out	0x04, r18	; 4
	PORTB=PORTB|0b11100000;
     fc2:	25 b1       	in	r18, 0x05	; 5
     fc4:	20 6e       	ori	r18, 0xE0	; 224
     fc6:	25 b9       	out	0x05, r18	; 5
	OCR1A=1150;								// to free the servo
     fc8:	90 93 89 00 	sts	0x0089, r25
     fcc:	80 93 88 00 	sts	0x0088, r24
	OCR1B=1150;
     fd0:	90 93 8b 00 	sts	0x008B, r25
     fd4:	80 93 8a 00 	sts	0x008A, r24
	OCR1C=1150;
     fd8:	90 93 8d 00 	sts	0x008D, r25
     fdc:	80 93 8c 00 	sts	0x008C, r24
	sei();
     fe0:	78 94       	sei
}
     fe2:	08 95       	ret

00000fe4 <servo1_mov>:
* Example Call:					servo1_mov(10);
*
*/

void servo1_mov(int degree)
{
     fe4:	cf 93       	push	r28
     fe6:	df 93       	push	r29
     fe8:	ec 01       	movw	r28, r24

	if(node_number==13)
     fea:	80 91 4d 02 	lds	r24, 0x024D
     fee:	90 91 4e 02 	lds	r25, 0x024E
     ff2:	8d 30       	cpi	r24, 0x0D	; 13
     ff4:	91 05       	cpc	r25, r1
     ff6:	e1 f4       	brne	.+56     	; 0x1030 <servo1_mov+0x4c>
	OCR1A=((degree/1.89)+25);
     ff8:	be 01       	movw	r22, r28
     ffa:	88 27       	eor	r24, r24
     ffc:	77 fd       	sbrc	r23, 7
     ffe:	80 95       	com	r24
    1000:	98 2f       	mov	r25, r24
    1002:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__floatsisf>
    1006:	25 e8       	ldi	r18, 0x85	; 133
    1008:	3b ee       	ldi	r19, 0xEB	; 235
    100a:	41 ef       	ldi	r20, 0xF1	; 241
    100c:	5f e3       	ldi	r21, 0x3F	; 63
    100e:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <__divsf3>
    1012:	20 e0       	ldi	r18, 0x00	; 0
    1014:	30 e0       	ldi	r19, 0x00	; 0
    1016:	48 ec       	ldi	r20, 0xC8	; 200
    1018:	51 e4       	ldi	r21, 0x41	; 65
    101a:	0e 94 44 16 	call	0x2c88	; 0x2c88 <__addsf3>
    101e:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <__fixunssfsi>
    1022:	dc 01       	movw	r26, r24
    1024:	cb 01       	movw	r24, r22
    1026:	90 93 89 00 	sts	0x0089, r25
    102a:	80 93 88 00 	sts	0x0088, r24
    102e:	1d c0       	rjmp	.+58     	; 0x106a <servo1_mov+0x86>
	else
	OCR1A=ceil(((degree/1.89)+25));
    1030:	be 01       	movw	r22, r28
    1032:	88 27       	eor	r24, r24
    1034:	77 fd       	sbrc	r23, 7
    1036:	80 95       	com	r24
    1038:	98 2f       	mov	r25, r24
    103a:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__floatsisf>
    103e:	25 e8       	ldi	r18, 0x85	; 133
    1040:	3b ee       	ldi	r19, 0xEB	; 235
    1042:	41 ef       	ldi	r20, 0xF1	; 241
    1044:	5f e3       	ldi	r21, 0x3F	; 63
    1046:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <__divsf3>
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	30 e0       	ldi	r19, 0x00	; 0
    104e:	48 ec       	ldi	r20, 0xC8	; 200
    1050:	51 e4       	ldi	r21, 0x41	; 65
    1052:	0e 94 44 16 	call	0x2c88	; 0x2c88 <__addsf3>
    1056:	0e 94 a8 16 	call	0x2d50	; 0x2d50 <ceil>
    105a:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <__fixunssfsi>
    105e:	dc 01       	movw	r26, r24
    1060:	cb 01       	movw	r24, r22
    1062:	90 93 89 00 	sts	0x0089, r25
    1066:	80 93 88 00 	sts	0x0088, r24
	servo_angle_1=degree;
    106a:	d0 93 2f 02 	sts	0x022F, r29
    106e:	c0 93 2e 02 	sts	0x022E, r28
}
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <servo2_mov>:
* Example Call:					servo2_mov(10);
*
*/

void servo2_mov(int degree)
{
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	ec 01       	movw	r28, r24
	OCR1B=ceil(((degree/1.89)+25));
    107e:	be 01       	movw	r22, r28
    1080:	88 27       	eor	r24, r24
    1082:	77 fd       	sbrc	r23, 7
    1084:	80 95       	com	r24
    1086:	98 2f       	mov	r25, r24
    1088:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__floatsisf>
    108c:	25 e8       	ldi	r18, 0x85	; 133
    108e:	3b ee       	ldi	r19, 0xEB	; 235
    1090:	41 ef       	ldi	r20, 0xF1	; 241
    1092:	5f e3       	ldi	r21, 0x3F	; 63
    1094:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <__divsf3>
    1098:	20 e0       	ldi	r18, 0x00	; 0
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	48 ec       	ldi	r20, 0xC8	; 200
    109e:	51 e4       	ldi	r21, 0x41	; 65
    10a0:	0e 94 44 16 	call	0x2c88	; 0x2c88 <__addsf3>
    10a4:	0e 94 a8 16 	call	0x2d50	; 0x2d50 <ceil>
    10a8:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <__fixunssfsi>
    10ac:	dc 01       	movw	r26, r24
    10ae:	cb 01       	movw	r24, r22
    10b0:	90 93 8b 00 	sts	0x008B, r25
    10b4:	80 93 8a 00 	sts	0x008A, r24
	servo_angle_2=degree;
    10b8:	d0 93 2d 02 	sts	0x022D, r29
    10bc:	c0 93 2c 02 	sts	0x022C, r28
}
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <servo1_free>:
*
*/

void servo1_free(void)
{
	OCR1A=1150;
    10c6:	8e e7       	ldi	r24, 0x7E	; 126
    10c8:	94 e0       	ldi	r25, 0x04	; 4
    10ca:	90 93 89 00 	sts	0x0089, r25
    10ce:	80 93 88 00 	sts	0x0088, r24
}
    10d2:	08 95       	ret

000010d4 <servo2_free>:
*
*/

void servo2_free(void)
{
	OCR1B=1150;
    10d4:	8e e7       	ldi	r24, 0x7E	; 126
    10d6:	94 e0       	ldi	r25, 0x04	; 4
    10d8:	90 93 8b 00 	sts	0x008B, r25
    10dc:	80 93 8a 00 	sts	0x008A, r24
}
    10e0:	08 95       	ret

000010e2 <pick_waste>:
*/


void pick_waste(void)
{
	servo2_mov(3);
    10e2:	83 e0       	ldi	r24, 0x03	; 3
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    10ea:	8f ef       	ldi	r24, 0xFF	; 255
    10ec:	9f ef       	ldi	r25, 0xFF	; 255
    10ee:	ac e2       	ldi	r26, 0x2C	; 44
    10f0:	81 50       	subi	r24, 0x01	; 1
    10f2:	90 40       	sbci	r25, 0x00	; 0
    10f4:	a0 40       	sbci	r26, 0x00	; 0
    10f6:	e1 f7       	brne	.-8      	; 0x10f0 <pick_waste+0xe>
    10f8:	00 c0       	rjmp	.+0      	; 0x10fa <pick_waste+0x18>
    10fa:	00 00       	nop
	_delay_ms(1000);
}
    10fc:	08 95       	ret

000010fe <ADC_config>:
*/


void ADC_config(void)
{
	cli();
    10fe:	f8 94       	cli
	TCCR3A=0x00;
    1100:	10 92 90 00 	sts	0x0090, r1
	TCCR3B=0x02; // with clock setting 8
    1104:	82 e0       	ldi	r24, 0x02	; 2
    1106:	80 93 91 00 	sts	0x0091, r24
	TCCR3C=0x00;
    110a:	10 92 92 00 	sts	0x0092, r1
	TIMSK3=0x01; // to enable timer overflow interrupt
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	80 93 71 00 	sts	0x0071, r24
	DDRF = 0x00; //set PORTF direction as input
    1114:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00; //set PORTF pins floating
    1116:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00; //set PORTK direction as input
    1118:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00; //set PORTK pins floating
    111c:	10 92 08 01 	sts	0x0108, r1
	ADCSRA = 0x00;
    1120:	ea e7       	ldi	r30, 0x7A	; 122
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
    1126:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    112a:	80 e2       	ldi	r24, 0x20	; 32
    112c:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
    1130:	80 e8       	ldi	r24, 0x80	; 128
    1132:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
    1134:	86 e8       	ldi	r24, 0x86	; 134
    1136:	80 83       	st	Z, r24
}
    1138:	08 95       	ret

0000113a <getdata>:
*/

int getdata(int Ch)
{
	int a;									//a -> digital value which stores the digital value of ADCH register
	if(Ch>7)
    113a:	88 30       	cpi	r24, 0x08	; 8
    113c:	91 05       	cpc	r25, r1
    113e:	1c f0       	brlt	.+6      	; 0x1146 <getdata+0xc>
	{
		ADCSRB = 0x08;
    1140:	28 e0       	ldi	r18, 0x08	; 8
    1142:	20 93 7b 00 	sts	0x007B, r18
	}
	Ch = Ch & 0x07;
    1146:	87 70       	andi	r24, 0x07	; 7
    1148:	90 70       	andi	r25, 0x00	; 0
	ADMUX= 0x20| Ch;
    114a:	80 62       	ori	r24, 0x20	; 32
    114c:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
    1150:	ea e7       	ldi	r30, 0x7A	; 122
    1152:	f0 e0       	ldi	r31, 0x00	; 0
    1154:	80 81       	ld	r24, Z
    1156:	80 64       	ori	r24, 0x40	; 64
    1158:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
    115a:	80 81       	ld	r24, Z
    115c:	84 ff       	sbrs	r24, 4
    115e:	fd cf       	rjmp	.-6      	; 0x115a <getdata+0x20>
	a=ADCH;
    1160:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    1164:	ea e7       	ldi	r30, 0x7A	; 122
    1166:	f0 e0       	ldi	r31, 0x00	; 0
    1168:	90 81       	ld	r25, Z
    116a:	90 61       	ori	r25, 0x10	; 16
    116c:	90 83       	st	Z, r25
	ADCSRB = 0x00;
    116e:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	08 95       	ret

00001176 <__vector_6>:
* Example Call:								NONE
*
*/

ISR(INT5_vect) 
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	0b b6       	in	r0, 0x3b	; 59
    1180:	0f 92       	push	r0
    1182:	11 24       	eor	r1, r1
    1184:	0f 93       	push	r16
    1186:	1f 93       	push	r17
    1188:	2f 93       	push	r18
    118a:	3f 93       	push	r19
    118c:	4f 93       	push	r20
    118e:	5f 93       	push	r21
    1190:	6f 93       	push	r22
    1192:	7f 93       	push	r23
    1194:	8f 93       	push	r24
    1196:	9f 93       	push	r25
    1198:	af 93       	push	r26
    119a:	bf 93       	push	r27
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	ef 93       	push	r30
    11a2:	ff 93       	push	r31
	int i=0;
	right_position_encode++;
    11a4:	80 91 4f 02 	lds	r24, 0x024F
    11a8:	90 91 50 02 	lds	r25, 0x0250
    11ac:	a0 91 51 02 	lds	r26, 0x0251
    11b0:	b0 91 52 02 	lds	r27, 0x0252
    11b4:	01 96       	adiw	r24, 0x01	; 1
    11b6:	a1 1d       	adc	r26, r1
    11b8:	b1 1d       	adc	r27, r1
    11ba:	80 93 4f 02 	sts	0x024F, r24
    11be:	90 93 50 02 	sts	0x0250, r25
    11c2:	a0 93 51 02 	sts	0x0251, r26
    11c6:	b0 93 52 02 	sts	0x0252, r27
	if(abs(navigation_in_degrees)==360)
    11ca:	80 91 2a 02 	lds	r24, 0x022A
    11ce:	90 91 2b 02 	lds	r25, 0x022B
    11d2:	99 23       	and	r25, r25
    11d4:	1c f4       	brge	.+6      	; 0x11dc <__vector_6+0x66>
    11d6:	90 95       	com	r25
    11d8:	81 95       	neg	r24
    11da:	9f 4f       	sbci	r25, 0xFF	; 255
    11dc:	21 e0       	ldi	r18, 0x01	; 1
    11de:	88 36       	cpi	r24, 0x68	; 104
    11e0:	92 07       	cpc	r25, r18
    11e2:	21 f4       	brne	.+8      	; 0x11ec <__vector_6+0x76>
	navigation_in_degrees=0;
    11e4:	10 92 2b 02 	sts	0x022B, r1
    11e8:	10 92 2a 02 	sts	0x022A, r1
* Example Call:								NONE
*
*/

ISR(INT5_vect) 
{
    11ec:	c0 e0       	ldi	r28, 0x00	; 0
    11ee:	d0 e0       	ldi	r29, 0x00	; 0
	right_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
	digital[i]=getdata(i);
    11f0:	0a e1       	ldi	r16, 0x1A	; 26
    11f2:	15 e0       	ldi	r17, 0x05	; 5
    11f4:	ce 01       	movw	r24, r28
    11f6:	0e 94 9d 08 	call	0x113a	; 0x113a <getdata>
    11fa:	28 2f       	mov	r18, r24
    11fc:	39 2f       	mov	r19, r25
    11fe:	fe 01       	movw	r30, r28
    1200:	ee 0f       	add	r30, r30
    1202:	ff 1f       	adc	r31, r31
    1204:	e0 0f       	add	r30, r16
    1206:	f1 1f       	adc	r31, r17
    1208:	31 83       	std	Z+1, r19	; 0x01
    120a:	20 83       	st	Z, r18
	int i=0;
	right_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
    120c:	21 96       	adiw	r28, 0x01	; 1
    120e:	c0 31       	cpi	r28, 0x10	; 16
    1210:	d1 05       	cpc	r29, r1
    1212:	81 f7       	brne	.-32     	; 0x11f4 <__vector_6+0x7e>
	digital[i]=getdata(i);
}
    1214:	ff 91       	pop	r31
    1216:	ef 91       	pop	r30
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	bf 91       	pop	r27
    121e:	af 91       	pop	r26
    1220:	9f 91       	pop	r25
    1222:	8f 91       	pop	r24
    1224:	7f 91       	pop	r23
    1226:	6f 91       	pop	r22
    1228:	5f 91       	pop	r21
    122a:	4f 91       	pop	r20
    122c:	3f 91       	pop	r19
    122e:	2f 91       	pop	r18
    1230:	1f 91       	pop	r17
    1232:	0f 91       	pop	r16
    1234:	0f 90       	pop	r0
    1236:	0b be       	out	0x3b, r0	; 59
    1238:	0f 90       	pop	r0
    123a:	0f be       	out	0x3f, r0	; 63
    123c:	0f 90       	pop	r0
    123e:	1f 90       	pop	r1
    1240:	18 95       	reti

00001242 <__vector_5>:
* Example Call:								NONE
*
*/

ISR(INT4_vect)
{
    1242:	1f 92       	push	r1
    1244:	0f 92       	push	r0
    1246:	0f b6       	in	r0, 0x3f	; 63
    1248:	0f 92       	push	r0
    124a:	0b b6       	in	r0, 0x3b	; 59
    124c:	0f 92       	push	r0
    124e:	11 24       	eor	r1, r1
    1250:	0f 93       	push	r16
    1252:	1f 93       	push	r17
    1254:	2f 93       	push	r18
    1256:	3f 93       	push	r19
    1258:	4f 93       	push	r20
    125a:	5f 93       	push	r21
    125c:	6f 93       	push	r22
    125e:	7f 93       	push	r23
    1260:	8f 93       	push	r24
    1262:	9f 93       	push	r25
    1264:	af 93       	push	r26
    1266:	bf 93       	push	r27
    1268:	cf 93       	push	r28
    126a:	df 93       	push	r29
    126c:	ef 93       	push	r30
    126e:	ff 93       	push	r31
	int i=0;
	left_position_encode++;
    1270:	80 91 53 02 	lds	r24, 0x0253
    1274:	90 91 54 02 	lds	r25, 0x0254
    1278:	a0 91 55 02 	lds	r26, 0x0255
    127c:	b0 91 56 02 	lds	r27, 0x0256
    1280:	01 96       	adiw	r24, 0x01	; 1
    1282:	a1 1d       	adc	r26, r1
    1284:	b1 1d       	adc	r27, r1
    1286:	80 93 53 02 	sts	0x0253, r24
    128a:	90 93 54 02 	sts	0x0254, r25
    128e:	a0 93 55 02 	sts	0x0255, r26
    1292:	b0 93 56 02 	sts	0x0256, r27
	if(abs(navigation_in_degrees)==360)
    1296:	80 91 2a 02 	lds	r24, 0x022A
    129a:	90 91 2b 02 	lds	r25, 0x022B
    129e:	99 23       	and	r25, r25
    12a0:	1c f4       	brge	.+6      	; 0x12a8 <__vector_5+0x66>
    12a2:	90 95       	com	r25
    12a4:	81 95       	neg	r24
    12a6:	9f 4f       	sbci	r25, 0xFF	; 255
    12a8:	21 e0       	ldi	r18, 0x01	; 1
    12aa:	88 36       	cpi	r24, 0x68	; 104
    12ac:	92 07       	cpc	r25, r18
    12ae:	21 f4       	brne	.+8      	; 0x12b8 <__vector_5+0x76>
	navigation_in_degrees=0;
    12b0:	10 92 2b 02 	sts	0x022B, r1
    12b4:	10 92 2a 02 	sts	0x022A, r1
* Example Call:								NONE
*
*/

ISR(INT4_vect)
{
    12b8:	c0 e0       	ldi	r28, 0x00	; 0
    12ba:	d0 e0       	ldi	r29, 0x00	; 0
	left_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
	digital[i]=getdata(i);
    12bc:	0a e1       	ldi	r16, 0x1A	; 26
    12be:	15 e0       	ldi	r17, 0x05	; 5
    12c0:	ce 01       	movw	r24, r28
    12c2:	0e 94 9d 08 	call	0x113a	; 0x113a <getdata>
    12c6:	28 2f       	mov	r18, r24
    12c8:	39 2f       	mov	r19, r25
    12ca:	fe 01       	movw	r30, r28
    12cc:	ee 0f       	add	r30, r30
    12ce:	ff 1f       	adc	r31, r31
    12d0:	e0 0f       	add	r30, r16
    12d2:	f1 1f       	adc	r31, r17
    12d4:	31 83       	std	Z+1, r19	; 0x01
    12d6:	20 83       	st	Z, r18
	int i=0;
	left_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
    12d8:	21 96       	adiw	r28, 0x01	; 1
    12da:	c0 31       	cpi	r28, 0x10	; 16
    12dc:	d1 05       	cpc	r29, r1
    12de:	81 f7       	brne	.-32     	; 0x12c0 <__vector_5+0x7e>
	digital[i]=getdata(i);
}
    12e0:	ff 91       	pop	r31
    12e2:	ef 91       	pop	r30
    12e4:	df 91       	pop	r29
    12e6:	cf 91       	pop	r28
    12e8:	bf 91       	pop	r27
    12ea:	af 91       	pop	r26
    12ec:	9f 91       	pop	r25
    12ee:	8f 91       	pop	r24
    12f0:	7f 91       	pop	r23
    12f2:	6f 91       	pop	r22
    12f4:	5f 91       	pop	r21
    12f6:	4f 91       	pop	r20
    12f8:	3f 91       	pop	r19
    12fa:	2f 91       	pop	r18
    12fc:	1f 91       	pop	r17
    12fe:	0f 91       	pop	r16
    1300:	0f 90       	pop	r0
    1302:	0b be       	out	0x3b, r0	; 59
    1304:	0f 90       	pop	r0
    1306:	0f be       	out	0x3f, r0	; 63
    1308:	0f 90       	pop	r0
    130a:	1f 90       	pop	r1
    130c:	18 95       	reti

0000130e <sharp>:
* Example Call:				sharp(digital[11]);
*	
*/

int sharp(int adc_reading)
{
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
	float distance;
	int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
    1312:	9c 01       	movw	r18, r24
    1314:	b9 01       	movw	r22, r18
    1316:	88 27       	eor	r24, r24
    1318:	77 fd       	sbrc	r23, 7
    131a:	80 95       	com	r24
    131c:	98 2f       	mov	r25, r24
    131e:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__floatsisf>
    1322:	2f ee       	ldi	r18, 0xEF	; 239
    1324:	39 ec       	ldi	r19, 0xC9	; 201
    1326:	43 e9       	ldi	r20, 0x93	; 147
    1328:	5f e3       	ldi	r21, 0x3F	; 63
    132a:	0e 94 ad 18 	call	0x315a	; 0x315a <pow>
    132e:	b6 2f       	mov	r27, r22
    1330:	a7 2f       	mov	r26, r23
    1332:	38 2f       	mov	r19, r24
    1334:	29 2f       	mov	r18, r25
    1336:	60 e0       	ldi	r22, 0x00	; 0
    1338:	70 e0       	ldi	r23, 0x00	; 0
    133a:	80 e8       	ldi	r24, 0x80	; 128
    133c:	9f e3       	ldi	r25, 0x3F	; 63
    133e:	42 2f       	mov	r20, r18
    1340:	0b 2f       	mov	r16, r27
    1342:	1a 2f       	mov	r17, r26
    1344:	23 2f       	mov	r18, r19
    1346:	34 2f       	mov	r19, r20
    1348:	a9 01       	movw	r20, r18
    134a:	98 01       	movw	r18, r16
    134c:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <__divsf3>
    1350:	2a e9       	ldi	r18, 0x9A	; 154
    1352:	39 ef       	ldi	r19, 0xF9	; 249
    1354:	4e e2       	ldi	r20, 0x2E	; 46
    1356:	55 e4       	ldi	r21, 0x45	; 69
    1358:	0e 94 4a 18 	call	0x3094	; 0x3094 <__mulsf3>
    135c:	20 e0       	ldi	r18, 0x00	; 0
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	40 e2       	ldi	r20, 0x20	; 32
    1362:	51 e4       	ldi	r21, 0x41	; 65
    1364:	0e 94 4a 18 	call	0x3094	; 0x3094 <__mulsf3>
    1368:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <__fixsfsi>
    136c:	88 27       	eor	r24, r24
    136e:	77 fd       	sbrc	r23, 7
    1370:	80 95       	com	r24
    1372:	98 2f       	mov	r25, r24
    1374:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__floatsisf>
	distanceInt = (int)distance;
    1378:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
    137c:	86 2f       	mov	r24, r22
    137e:	97 2f       	mov	r25, r23
    1380:	33 e0       	ldi	r19, 0x03	; 3
    1382:	81 32       	cpi	r24, 0x21	; 33
    1384:	93 07       	cpc	r25, r19
    1386:	14 f0       	brlt	.+4      	; 0x138c <sharp+0x7e>
    1388:	80 e2       	ldi	r24, 0x20	; 32
    138a:	93 e0       	ldi	r25, 0x03	; 3
}
    138c:	1f 91       	pop	r17
    138e:	0f 91       	pop	r16
    1390:	08 95       	ret

00001392 <node_behave>:
* Example Call:				node_behave(); 
*
*/

void node_behave(void) 
{
    1392:	af 92       	push	r10
    1394:	bf 92       	push	r11
    1396:	cf 92       	push	r12
    1398:	df 92       	push	r13
    139a:	ef 92       	push	r14
    139c:	ff 92       	push	r15
    139e:	0f 93       	push	r16
    13a0:	1f 93       	push	r17
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
	int i;
    if(path[path_index]!='\0')
    13a6:	e0 91 47 02 	lds	r30, 0x0247
    13aa:	f0 91 48 02 	lds	r31, 0x0248
    13ae:	e9 5a       	subi	r30, 0xA9	; 169
    13b0:	fd 4f       	sbci	r31, 0xFD	; 253
    13b2:	80 81       	ld	r24, Z
    13b4:	88 23       	and	r24, r24
    13b6:	09 f4       	brne	.+2      	; 0x13ba <node_behave+0x28>
    13b8:	eb c0       	rjmp	.+470    	; 0x1590 <node_behave+0x1fe>
	{
		if((node_number==6 && *navigation_pointer=='E' && destinationn_node!=21) ||(node_number==16 && *navigation_pointer=='W') ||(node_number==15 && *navigation_pointer=='W') ||(node_number==17 && *navigation_pointer=='W') )
    13ba:	80 91 4d 02 	lds	r24, 0x024D
    13be:	90 91 4e 02 	lds	r25, 0x024E
    13c2:	86 30       	cpi	r24, 0x06	; 6
    13c4:	91 05       	cpc	r25, r1
    13c6:	79 f4       	brne	.+30     	; 0x13e6 <node_behave+0x54>
    13c8:	e0 91 92 02 	lds	r30, 0x0292
    13cc:	f0 91 93 02 	lds	r31, 0x0293
    13d0:	20 81       	ld	r18, Z
    13d2:	25 34       	cpi	r18, 0x45	; 69
    13d4:	41 f4       	brne	.+16     	; 0x13e6 <node_behave+0x54>
    13d6:	20 91 4b 02 	lds	r18, 0x024B
    13da:	30 91 4c 02 	lds	r19, 0x024C
    13de:	25 31       	cpi	r18, 0x15	; 21
    13e0:	31 05       	cpc	r19, r1
    13e2:	09 f5       	brne	.+66     	; 0x1426 <node_behave+0x94>
    13e4:	16 c0       	rjmp	.+44     	; 0x1412 <node_behave+0x80>
    13e6:	80 31       	cpi	r24, 0x10	; 16
    13e8:	91 05       	cpc	r25, r1
    13ea:	41 f4       	brne	.+16     	; 0x13fc <node_behave+0x6a>
    13ec:	e0 91 92 02 	lds	r30, 0x0292
    13f0:	f0 91 93 02 	lds	r31, 0x0293
    13f4:	20 81       	ld	r18, Z
    13f6:	27 35       	cpi	r18, 0x57	; 87
    13f8:	f9 f4       	brne	.+62     	; 0x1438 <node_behave+0xa6>
    13fa:	15 c0       	rjmp	.+42     	; 0x1426 <node_behave+0x94>
    13fc:	8f 30       	cpi	r24, 0x0F	; 15
    13fe:	91 05       	cpc	r25, r1
    1400:	41 f4       	brne	.+16     	; 0x1412 <node_behave+0x80>
    1402:	e0 91 92 02 	lds	r30, 0x0292
    1406:	f0 91 93 02 	lds	r31, 0x0293
    140a:	80 81       	ld	r24, Z
    140c:	87 35       	cpi	r24, 0x57	; 87
    140e:	01 f5       	brne	.+64     	; 0x1450 <node_behave+0xbe>
    1410:	0a c0       	rjmp	.+20     	; 0x1426 <node_behave+0x94>
    1412:	81 31       	cpi	r24, 0x11	; 17
    1414:	91 05       	cpc	r25, r1
    1416:	81 f4       	brne	.+32     	; 0x1438 <node_behave+0xa6>
    1418:	e0 91 92 02 	lds	r30, 0x0292
    141c:	f0 91 93 02 	lds	r31, 0x0293
    1420:	80 81       	ld	r24, Z
    1422:	87 35       	cpi	r24, 0x57	; 87
    1424:	a9 f4       	brne	.+42     	; 0x1450 <node_behave+0xbe>
		distance('f',3,'o');
    1426:	86 e6       	ldi	r24, 0x66	; 102
    1428:	40 e0       	ldi	r20, 0x00	; 0
    142a:	50 e0       	ldi	r21, 0x00	; 0
    142c:	60 e4       	ldi	r22, 0x40	; 64
    142e:	70 e4       	ldi	r23, 0x40	; 64
    1430:	2f e6       	ldi	r18, 0x6F	; 111
    1432:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
    1436:	14 c0       	rjmp	.+40     	; 0x1460 <node_behave+0xce>
		else if(node_number==14)
    1438:	8e 30       	cpi	r24, 0x0E	; 14
    143a:	91 05       	cpc	r25, r1
    143c:	49 f4       	brne	.+18     	; 0x1450 <node_behave+0xbe>
		distance('f',9.5,'o');
    143e:	86 e6       	ldi	r24, 0x66	; 102
    1440:	40 e0       	ldi	r20, 0x00	; 0
    1442:	50 e0       	ldi	r21, 0x00	; 0
    1444:	68 e1       	ldi	r22, 0x18	; 24
    1446:	71 e4       	ldi	r23, 0x41	; 65
    1448:	2f e6       	ldi	r18, 0x6F	; 111
    144a:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
    144e:	08 c0       	rjmp	.+16     	; 0x1460 <node_behave+0xce>
		else
		distance('f',8.5,'o');
    1450:	86 e6       	ldi	r24, 0x66	; 102
    1452:	40 e0       	ldi	r20, 0x00	; 0
    1454:	50 e0       	ldi	r21, 0x00	; 0
    1456:	68 e0       	ldi	r22, 0x08	; 8
    1458:	71 e4       	ldi	r23, 0x41	; 65
    145a:	2f e6       	ldi	r18, 0x6F	; 111
    145c:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    1460:	e0 91 92 02 	lds	r30, 0x0292
    1464:	f0 91 93 02 	lds	r31, 0x0293
    1468:	50 81       	ld	r21, Z
    146a:	e0 91 47 02 	lds	r30, 0x0247
    146e:	f0 91 48 02 	lds	r31, 0x0248
    1472:	e9 5a       	subi	r30, 0xA9	; 169
    1474:	fd 4f       	sbci	r31, 0xFD	; 253
    1476:	40 81       	ld	r20, Z
    1478:	85 2f       	mov	r24, r21
    147a:	90 e0       	ldi	r25, 0x00	; 0
    147c:	84 1b       	sub	r24, r20
    147e:	91 09       	sbc	r25, r1
    1480:	2f ef       	ldi	r18, 0xFF	; 255
    1482:	87 3f       	cpi	r24, 0xF7	; 247
    1484:	92 07       	cpc	r25, r18
    1486:	31 f0       	breq	.+12     	; 0x1494 <node_behave+0x102>
    1488:	84 30       	cpi	r24, 0x04	; 4
    148a:	91 05       	cpc	r25, r1
    148c:	19 f0       	breq	.+6      	; 0x1494 <node_behave+0x102>
    148e:	8e 30       	cpi	r24, 0x0E	; 14
    1490:	91 05       	cpc	r25, r1
    1492:	c1 f4       	brne	.+48     	; 0x14c4 <node_behave+0x132>
			while(*navigation_pointer!=path[path_index])
    1494:	54 17       	cp	r21, r20
    1496:	09 f4       	brne	.+2      	; 0x149a <node_behave+0x108>
    1498:	70 c0       	rjmp	.+224    	; 0x157a <node_behave+0x1e8>
    149a:	c7 e5       	ldi	r28, 0x57	; 87
    149c:	d2 e0       	ldi	r29, 0x02	; 2
				{left_degrees(90);}
    149e:	8a e5       	ldi	r24, 0x5A	; 90
    14a0:	90 e0       	ldi	r25, 0x00	; 0
    14a2:	0e 94 c2 06 	call	0xd84	; 0xd84 <left_degrees>
		else if(node_number==14)
		distance('f',9.5,'o');
		else
		distance('f',8.5,'o');
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
			while(*navigation_pointer!=path[path_index])
    14a6:	e0 91 92 02 	lds	r30, 0x0292
    14aa:	f0 91 93 02 	lds	r31, 0x0293
    14ae:	a0 91 47 02 	lds	r26, 0x0247
    14b2:	b0 91 48 02 	lds	r27, 0x0248
    14b6:	ac 0f       	add	r26, r28
    14b8:	bd 1f       	adc	r27, r29
    14ba:	90 81       	ld	r25, Z
    14bc:	8c 91       	ld	r24, X
    14be:	98 17       	cp	r25, r24
    14c0:	71 f7       	brne	.-36     	; 0x149e <node_behave+0x10c>
    14c2:	5b c0       	rjmp	.+182    	; 0x157a <node_behave+0x1e8>
				{left_degrees(90);}
		else if(node_number==3)
    14c4:	20 91 4d 02 	lds	r18, 0x024D
    14c8:	30 91 4e 02 	lds	r19, 0x024E
    14cc:	23 30       	cpi	r18, 0x03	; 3
    14ce:	31 05       	cpc	r19, r1
    14d0:	c1 f4       	brne	.+48     	; 0x1502 <node_behave+0x170>
			while(*navigation_pointer!=path[path_index])
    14d2:	54 17       	cp	r21, r20
    14d4:	09 f4       	brne	.+2      	; 0x14d8 <node_behave+0x146>
    14d6:	51 c0       	rjmp	.+162    	; 0x157a <node_behave+0x1e8>
    14d8:	c7 e5       	ldi	r28, 0x57	; 87
    14da:	d2 e0       	ldi	r29, 0x02	; 2
				right_degrees(180);
    14dc:	84 eb       	ldi	r24, 0xB4	; 180
    14de:	90 e0       	ldi	r25, 0x00	; 0
    14e0:	0e 94 29 07 	call	0xe52	; 0xe52 <right_degrees>
		distance('f',8.5,'o');
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
			while(*navigation_pointer!=path[path_index])
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
    14e4:	e0 91 92 02 	lds	r30, 0x0292
    14e8:	f0 91 93 02 	lds	r31, 0x0293
    14ec:	a0 91 47 02 	lds	r26, 0x0247
    14f0:	b0 91 48 02 	lds	r27, 0x0248
    14f4:	ac 0f       	add	r26, r28
    14f6:	bd 1f       	adc	r27, r29
    14f8:	90 81       	ld	r25, Z
    14fa:	8c 91       	ld	r24, X
    14fc:	98 17       	cp	r25, r24
    14fe:	71 f7       	brne	.-36     	; 0x14dc <node_behave+0x14a>
    1500:	3c c0       	rjmp	.+120    	; 0x157a <node_behave+0x1e8>
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
    1502:	9c 01       	movw	r18, r24
    1504:	99 23       	and	r25, r25
    1506:	24 f4       	brge	.+8      	; 0x1510 <node_behave+0x17e>
    1508:	22 27       	eor	r18, r18
    150a:	33 27       	eor	r19, r19
    150c:	28 1b       	sub	r18, r24
    150e:	39 0b       	sbc	r19, r25
    1510:	25 30       	cpi	r18, 0x05	; 5
    1512:	31 05       	cpc	r19, r1
    1514:	19 f4       	brne	.+6      	; 0x151c <node_behave+0x18a>
			while(*navigation_pointer!=path[path_index])
    1516:	54 17       	cp	r21, r20
    1518:	39 f4       	brne	.+14     	; 0x1528 <node_behave+0x196>
    151a:	2f c0       	rjmp	.+94     	; 0x157a <node_behave+0x1e8>
			while(*navigation_pointer!=path[path_index])
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
    151c:	22 31       	cpi	r18, 0x12	; 18
    151e:	31 05       	cpc	r19, r1
    1520:	d1 f3       	breq	.-12     	; 0x1516 <node_behave+0x184>
			while(*navigation_pointer!=path[path_index])
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    1522:	54 17       	cp	r21, r20
    1524:	b1 f4       	brne	.+44     	; 0x1552 <node_behave+0x1c0>
    1526:	29 c0       	rjmp	.+82     	; 0x157a <node_behave+0x1e8>
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
    1528:	c7 e5       	ldi	r28, 0x57	; 87
    152a:	d2 e0       	ldi	r29, 0x02	; 2
				left_degrees(180);
    152c:	84 eb       	ldi	r24, 0xB4	; 180
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	0e 94 c2 06 	call	0xd84	; 0xd84 <left_degrees>
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
    1534:	e0 91 92 02 	lds	r30, 0x0292
    1538:	f0 91 93 02 	lds	r31, 0x0293
    153c:	a0 91 47 02 	lds	r26, 0x0247
    1540:	b0 91 48 02 	lds	r27, 0x0248
    1544:	ac 0f       	add	r26, r28
    1546:	bd 1f       	adc	r27, r29
    1548:	90 81       	ld	r25, Z
    154a:	8c 91       	ld	r24, X
    154c:	98 17       	cp	r25, r24
    154e:	71 f7       	brne	.-36     	; 0x152c <node_behave+0x19a>
    1550:	14 c0       	rjmp	.+40     	; 0x157a <node_behave+0x1e8>
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    1552:	c7 e5       	ldi	r28, 0x57	; 87
    1554:	d2 e0       	ldi	r29, 0x02	; 2
			right_degrees(90);
    1556:	8a e5       	ldi	r24, 0x5A	; 90
    1558:	90 e0       	ldi	r25, 0x00	; 0
    155a:	0e 94 29 07 	call	0xe52	; 0xe52 <right_degrees>
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    155e:	e0 91 92 02 	lds	r30, 0x0292
    1562:	f0 91 93 02 	lds	r31, 0x0293
    1566:	a0 91 47 02 	lds	r26, 0x0247
    156a:	b0 91 48 02 	lds	r27, 0x0248
    156e:	ac 0f       	add	r26, r28
    1570:	bd 1f       	adc	r27, r29
    1572:	90 81       	ld	r25, Z
    1574:	8c 91       	ld	r24, X
    1576:	98 17       	cp	r25, r24
    1578:	71 f7       	brne	.-36     	; 0x1556 <node_behave+0x1c4>
			right_degrees(90);
		path_index++;
    157a:	80 91 47 02 	lds	r24, 0x0247
    157e:	90 91 48 02 	lds	r25, 0x0248
    1582:	01 96       	adiw	r24, 0x01	; 1
    1584:	90 93 48 02 	sts	0x0248, r25
    1588:	80 93 47 02 	sts	0x0247, r24
    158c:	0c 94 98 13 	jmp	0x2730	; 0x2730 <__stack+0x531>
	}
	else
	{
		node_number=destinationn_node;
    1590:	80 91 4b 02 	lds	r24, 0x024B
    1594:	90 91 4c 02 	lds	r25, 0x024C
    1598:	90 93 4e 02 	sts	0x024E, r25
    159c:	80 93 4d 02 	sts	0x024D, r24
		navigate();
    15a0:	0e 94 02 01 	call	0x204	; 0x204 <navigate>
		if(node_number==15 || node_number==16 || node_number==17)
    15a4:	80 91 4d 02 	lds	r24, 0x024D
    15a8:	90 91 4e 02 	lds	r25, 0x024E
    15ac:	0f 97       	sbiw	r24, 0x0f	; 15
    15ae:	83 30       	cpi	r24, 0x03	; 3
    15b0:	91 05       	cpc	r25, r1
    15b2:	08 f0       	brcs	.+2      	; 0x15b6 <node_behave+0x224>
    15b4:	7b c1       	rjmp	.+758    	; 0x18ac <node_behave+0x51a>
		{
			if((deposition_zone_A+deposition_zone_B+deposition_zone_C)!=1 && color_found==0 && check<2)
    15b6:	80 91 28 02 	lds	r24, 0x0228
    15ba:	90 91 29 02 	lds	r25, 0x0229
    15be:	20 91 26 02 	lds	r18, 0x0226
    15c2:	30 91 27 02 	lds	r19, 0x0227
    15c6:	82 0f       	add	r24, r18
    15c8:	93 1f       	adc	r25, r19
    15ca:	20 91 24 02 	lds	r18, 0x0224
    15ce:	30 91 25 02 	lds	r19, 0x0225
    15d2:	82 0f       	add	r24, r18
    15d4:	93 1f       	adc	r25, r19
    15d6:	81 30       	cpi	r24, 0x01	; 1
    15d8:	91 05       	cpc	r25, r1
    15da:	09 f4       	brne	.+2      	; 0x15de <node_behave+0x24c>
    15dc:	a3 c0       	rjmp	.+326    	; 0x1724 <node_behave+0x392>
    15de:	80 91 49 02 	lds	r24, 0x0249
    15e2:	90 91 4a 02 	lds	r25, 0x024A
    15e6:	00 97       	sbiw	r24, 0x00	; 0
    15e8:	09 f0       	breq	.+2      	; 0x15ec <node_behave+0x25a>
    15ea:	9c c0       	rjmp	.+312    	; 0x1724 <node_behave+0x392>
    15ec:	80 91 3a 02 	lds	r24, 0x023A
    15f0:	90 91 3b 02 	lds	r25, 0x023B
    15f4:	82 30       	cpi	r24, 0x02	; 2
    15f6:	91 05       	cpc	r25, r1
    15f8:	0c f0       	brlt	.+2      	; 0x15fc <node_behave+0x26a>
    15fa:	94 c0       	rjmp	.+296    	; 0x1724 <node_behave+0x392>
			{
				left(); //Turn left
    15fc:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
				angle_rotate(45);
    1600:	8d e2       	ldi	r24, 0x2D	; 45
    1602:	90 e0       	ldi	r25, 0x00	; 0
    1604:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
				distance('f',16,'o');
    1608:	86 e6       	ldi	r24, 0x66	; 102
    160a:	40 e0       	ldi	r20, 0x00	; 0
    160c:	50 e0       	ldi	r21, 0x00	; 0
    160e:	60 e8       	ldi	r22, 0x80	; 128
    1610:	71 e4       	ldi	r23, 0x41	; 65
    1612:	2f e6       	ldi	r18, 0x6F	; 111
    1614:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				right(); //Turn left
    1618:	0e 94 41 06 	call	0xc82	; 0xc82 <right>
				angle_rotate(170);
    161c:	8a ea       	ldi	r24, 0xAA	; 170
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
				stop();
    1624:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
				color_identified='\0';
    1628:	10 92 42 02 	sts	0x0242, r1
				color_sensor();
    162c:	c0 e2       	ldi	r28, 0x20	; 32
    162e:	d5 e1       	ldi	r29, 0x15	; 21
    1630:	fe 01       	movw	r30, r28
    1632:	19 95       	eicall
				if(color_identified=='\0')
    1634:	80 91 42 02 	lds	r24, 0x0242
    1638:	88 23       	and	r24, r24
    163a:	51 f4       	brne	.+20     	; 0x1650 <node_behave+0x2be>
				{
					distance('f',2,'o');
    163c:	86 e6       	ldi	r24, 0x66	; 102
    163e:	40 e0       	ldi	r20, 0x00	; 0
    1640:	50 e0       	ldi	r21, 0x00	; 0
    1642:	60 e0       	ldi	r22, 0x00	; 0
    1644:	70 e4       	ldi	r23, 0x40	; 64
    1646:	2f e6       	ldi	r18, 0x6F	; 111
    1648:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
					color_sensor();
    164c:	fe 01       	movw	r30, r28
    164e:	19 95       	eicall
				}
				if(node_number==15)
    1650:	80 91 4d 02 	lds	r24, 0x024D
    1654:	90 91 4e 02 	lds	r25, 0x024E
    1658:	8f 30       	cpi	r24, 0x0F	; 15
    165a:	91 05       	cpc	r25, r1
    165c:	29 f4       	brne	.+10     	; 0x1668 <node_behave+0x2d6>
				color_deposited[0]=color_identified;
    165e:	80 91 42 02 	lds	r24, 0x0242
    1662:	80 93 8b 02 	sts	0x028B, r24
    1666:	0f c0       	rjmp	.+30     	; 0x1686 <node_behave+0x2f4>
				if(node_number==16)
    1668:	80 31       	cpi	r24, 0x10	; 16
    166a:	91 05       	cpc	r25, r1
    166c:	29 f4       	brne	.+10     	; 0x1678 <node_behave+0x2e6>
				color_deposited[1]=color_identified;
    166e:	80 91 42 02 	lds	r24, 0x0242
    1672:	80 93 8c 02 	sts	0x028C, r24
    1676:	07 c0       	rjmp	.+14     	; 0x1686 <node_behave+0x2f4>
				if(node_number==17)
    1678:	81 31       	cpi	r24, 0x11	; 17
    167a:	91 05       	cpc	r25, r1
    167c:	21 f4       	brne	.+8      	; 0x1686 <node_behave+0x2f4>
				color_deposited[2]=color_identified;
    167e:	80 91 42 02 	lds	r24, 0x0242
    1682:	80 93 8d 02 	sts	0x028D, r24
				left(); //Turn left
    1686:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
				angle_rotate(170);
    168a:	8a ea       	ldi	r24, 0xAA	; 170
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
				distance('b',12,'o');
    1692:	82 e6       	ldi	r24, 0x62	; 98
    1694:	40 e0       	ldi	r20, 0x00	; 0
    1696:	50 e0       	ldi	r21, 0x00	; 0
    1698:	60 e4       	ldi	r22, 0x40	; 64
    169a:	71 e4       	ldi	r23, 0x41	; 65
    169c:	2f e6       	ldi	r18, 0x6F	; 111
    169e:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    16a2:	80 91 1e 05 	lds	r24, 0x051E
    16a6:	90 91 1f 05 	lds	r25, 0x051F
    16aa:	8f 30       	cpi	r24, 0x0F	; 15
    16ac:	91 05       	cpc	r25, r1
    16ae:	90 f5       	brcc	.+100    	; 0x1714 <node_behave+0x382>
    16b0:	80 91 1c 05 	lds	r24, 0x051C
    16b4:	90 91 1d 05 	lds	r25, 0x051D
    16b8:	8f 30       	cpi	r24, 0x0F	; 15
    16ba:	91 05       	cpc	r25, r1
    16bc:	58 f5       	brcc	.+86     	; 0x1714 <node_behave+0x382>
    16be:	80 91 20 05 	lds	r24, 0x0520
    16c2:	90 91 21 05 	lds	r25, 0x0521
    16c6:	8f 30       	cpi	r24, 0x0F	; 15
    16c8:	91 05       	cpc	r25, r1
    16ca:	20 f5       	brcc	.+72     	; 0x1714 <node_behave+0x382>
    16cc:	ce e1       	ldi	r28, 0x1E	; 30
    16ce:	d5 e0       	ldi	r29, 0x05	; 5
    16d0:	0c e1       	ldi	r16, 0x1C	; 28
    16d2:	15 e0       	ldi	r17, 0x05	; 5
    16d4:	0f 2e       	mov	r0, r31
    16d6:	f0 e2       	ldi	r31, 0x20	; 32
    16d8:	ef 2e       	mov	r14, r31
    16da:	f5 e0       	ldi	r31, 0x05	; 5
    16dc:	ff 2e       	mov	r15, r31
    16de:	f0 2d       	mov	r31, r0
				{
					sppeed(255,249);
    16e0:	8f ef       	ldi	r24, 0xFF	; 255
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	69 ef       	ldi	r22, 0xF9	; 249
    16e6:	70 e0       	ldi	r23, 0x00	; 0
    16e8:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
					right();
    16ec:	0e 94 41 06 	call	0xc82	; 0xc82 <right>
				if(node_number==17)
				color_deposited[2]=color_identified;
				left(); //Turn left
				angle_rotate(170);
				distance('b',12,'o');
				while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    16f0:	88 81       	ld	r24, Y
    16f2:	99 81       	ldd	r25, Y+1	; 0x01
    16f4:	8f 30       	cpi	r24, 0x0F	; 15
    16f6:	91 05       	cpc	r25, r1
    16f8:	68 f4       	brcc	.+26     	; 0x1714 <node_behave+0x382>
    16fa:	d8 01       	movw	r26, r16
    16fc:	8d 91       	ld	r24, X+
    16fe:	9c 91       	ld	r25, X
    1700:	11 97       	sbiw	r26, 0x01	; 1
    1702:	8f 30       	cpi	r24, 0x0F	; 15
    1704:	91 05       	cpc	r25, r1
    1706:	30 f4       	brcc	.+12     	; 0x1714 <node_behave+0x382>
    1708:	f7 01       	movw	r30, r14
    170a:	80 81       	ld	r24, Z
    170c:	91 81       	ldd	r25, Z+1	; 0x01
    170e:	8f 30       	cpi	r24, 0x0F	; 15
    1710:	91 05       	cpc	r25, r1
    1712:	30 f3       	brcs	.-52     	; 0x16e0 <node_behave+0x34e>
				{
					sppeed(255,249);
					right();
				}
				right();
    1714:	0e 94 41 06 	call	0xc82	; 0xc82 <right>
				angle_rotate(25);
    1718:	89 e1       	ldi	r24, 0x19	; 25
    171a:	90 e0       	ldi	r25, 0x00	; 0
    171c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
				stop();
    1720:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
			}
			if(color_identified==color[color_index-1] || (deposition_zone_A+deposition_zone_B+deposition_zone_C)==1 || check==2 || color_found>0)
    1724:	e0 91 40 02 	lds	r30, 0x0240
    1728:	f0 91 41 02 	lds	r31, 0x0241
    172c:	ec 5e       	subi	r30, 0xEC	; 236
    172e:	fa 4f       	sbci	r31, 0xFA	; 250
    1730:	90 81       	ld	r25, Z
    1732:	80 91 42 02 	lds	r24, 0x0242
    1736:	98 17       	cp	r25, r24
    1738:	11 f1       	breq	.+68     	; 0x177e <node_behave+0x3ec>
    173a:	80 91 28 02 	lds	r24, 0x0228
    173e:	90 91 29 02 	lds	r25, 0x0229
    1742:	20 91 26 02 	lds	r18, 0x0226
    1746:	30 91 27 02 	lds	r19, 0x0227
    174a:	82 0f       	add	r24, r18
    174c:	93 1f       	adc	r25, r19
    174e:	20 91 24 02 	lds	r18, 0x0224
    1752:	30 91 25 02 	lds	r19, 0x0225
    1756:	82 0f       	add	r24, r18
    1758:	93 1f       	adc	r25, r19
    175a:	81 30       	cpi	r24, 0x01	; 1
    175c:	91 05       	cpc	r25, r1
    175e:	79 f0       	breq	.+30     	; 0x177e <node_behave+0x3ec>
    1760:	80 91 3a 02 	lds	r24, 0x023A
    1764:	90 91 3b 02 	lds	r25, 0x023B
    1768:	82 30       	cpi	r24, 0x02	; 2
    176a:	91 05       	cpc	r25, r1
    176c:	41 f0       	breq	.+16     	; 0x177e <node_behave+0x3ec>
    176e:	20 91 49 02 	lds	r18, 0x0249
    1772:	30 91 4a 02 	lds	r19, 0x024A
    1776:	12 16       	cp	r1, r18
    1778:	13 06       	cpc	r1, r19
    177a:	0c f0       	brlt	.+2      	; 0x177e <node_behave+0x3ec>
    177c:	5b c0       	rjmp	.+182    	; 0x1834 <node_behave+0x4a2>
			{
				check=0;
    177e:	10 92 3b 02 	sts	0x023B, r1
    1782:	10 92 3a 02 	sts	0x023A, r1
				servo1_mov(10);
    1786:	8a e0       	ldi	r24, 0x0A	; 10
    1788:	90 e0       	ldi	r25, 0x00	; 0
    178a:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    178e:	8f ef       	ldi	r24, 0xFF	; 255
    1790:	9f e3       	ldi	r25, 0x3F	; 63
    1792:	ad e1       	ldi	r26, 0x1D	; 29
    1794:	81 50       	subi	r24, 0x01	; 1
    1796:	90 40       	sbci	r25, 0x00	; 0
    1798:	a0 40       	sbci	r26, 0x00	; 0
    179a:	e1 f7       	brne	.-8      	; 0x1794 <node_behave+0x402>
    179c:	00 c0       	rjmp	.+0      	; 0x179e <node_behave+0x40c>
    179e:	00 00       	nop
				_delay_ms(650);
				servo2_mov(45);
    17a0:	8d e2       	ldi	r24, 0x2D	; 45
    17a2:	90 e0       	ldi	r25, 0x00	; 0
    17a4:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    17a8:	8f ef       	ldi	r24, 0xFF	; 255
    17aa:	9f e7       	ldi	r25, 0x7F	; 127
    17ac:	a4 e0       	ldi	r26, 0x04	; 4
    17ae:	81 50       	subi	r24, 0x01	; 1
    17b0:	90 40       	sbci	r25, 0x00	; 0
    17b2:	a0 40       	sbci	r26, 0x00	; 0
    17b4:	e1 f7       	brne	.-8      	; 0x17ae <node_behave+0x41c>
    17b6:	00 c0       	rjmp	.+0      	; 0x17b8 <node_behave+0x426>
    17b8:	00 00       	nop
				_delay_ms(100);
				servo1_mov(80);
    17ba:	80 e5       	ldi	r24, 0x50	; 80
    17bc:	90 e0       	ldi	r25, 0x00	; 0
    17be:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
				servo2_free();
    17c2:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <servo2_free>
				if(node_number==15)
    17c6:	80 91 4d 02 	lds	r24, 0x024D
    17ca:	90 91 4e 02 	lds	r25, 0x024E
    17ce:	8f 30       	cpi	r24, 0x0F	; 15
    17d0:	91 05       	cpc	r25, r1
    17d2:	51 f4       	brne	.+20     	; 0x17e8 <node_behave+0x456>
				deposition_zone_A--;
    17d4:	80 91 28 02 	lds	r24, 0x0228
    17d8:	90 91 29 02 	lds	r25, 0x0229
    17dc:	01 97       	sbiw	r24, 0x01	; 1
    17de:	90 93 29 02 	sts	0x0229, r25
    17e2:	80 93 28 02 	sts	0x0228, r24
    17e6:	19 c0       	rjmp	.+50     	; 0x181a <node_behave+0x488>
				if(node_number==16)
    17e8:	80 31       	cpi	r24, 0x10	; 16
    17ea:	91 05       	cpc	r25, r1
    17ec:	51 f4       	brne	.+20     	; 0x1802 <node_behave+0x470>
				deposition_zone_B--;
    17ee:	80 91 26 02 	lds	r24, 0x0226
    17f2:	90 91 27 02 	lds	r25, 0x0227
    17f6:	01 97       	sbiw	r24, 0x01	; 1
    17f8:	90 93 27 02 	sts	0x0227, r25
    17fc:	80 93 26 02 	sts	0x0226, r24
    1800:	0c c0       	rjmp	.+24     	; 0x181a <node_behave+0x488>
				if(node_number==17)
    1802:	81 31       	cpi	r24, 0x11	; 17
    1804:	91 05       	cpc	r25, r1
    1806:	49 f4       	brne	.+18     	; 0x181a <node_behave+0x488>
				deposition_zone_C--;
    1808:	80 91 24 02 	lds	r24, 0x0224
    180c:	90 91 25 02 	lds	r25, 0x0225
    1810:	01 97       	sbiw	r24, 0x01	; 1
    1812:	90 93 25 02 	sts	0x0225, r25
    1816:	80 93 24 02 	sts	0x0224, r24
				path_find(10);
    181a:	8a e0       	ldi	r24, 0x0A	; 10
    181c:	90 e0       	ldi	r25, 0x00	; 0
    181e:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
				distance('b',6,'o');
    1822:	82 e6       	ldi	r24, 0x62	; 98
    1824:	40 e0       	ldi	r20, 0x00	; 0
    1826:	50 e0       	ldi	r21, 0x00	; 0
    1828:	60 ec       	ldi	r22, 0xC0	; 192
    182a:	70 e4       	ldi	r23, 0x40	; 64
    182c:	2f e6       	ldi	r18, 0x6F	; 111
    182e:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
    1832:	3c c0       	rjmp	.+120    	; 0x18ac <node_behave+0x51a>
			}
			else
			{
				check++;
    1834:	01 96       	adiw	r24, 0x01	; 1
    1836:	90 93 3b 02 	sts	0x023B, r25
    183a:	80 93 3a 02 	sts	0x023A, r24
				distance('b',6,'o');
    183e:	82 e6       	ldi	r24, 0x62	; 98
    1840:	40 e0       	ldi	r20, 0x00	; 0
    1842:	50 e0       	ldi	r21, 0x00	; 0
    1844:	60 ec       	ldi	r22, 0xC0	; 192
    1846:	70 e4       	ldi	r23, 0x40	; 64
    1848:	2f e6       	ldi	r18, 0x6F	; 111
    184a:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				if(deposition_zone_B==1 && color_deposited[1]=='\0')
    184e:	80 91 26 02 	lds	r24, 0x0226
    1852:	90 91 27 02 	lds	r25, 0x0227
    1856:	81 30       	cpi	r24, 0x01	; 1
    1858:	91 05       	cpc	r25, r1
    185a:	49 f4       	brne	.+18     	; 0x186e <node_behave+0x4dc>
    185c:	80 91 8c 02 	lds	r24, 0x028C
    1860:	88 23       	and	r24, r24
    1862:	29 f4       	brne	.+10     	; 0x186e <node_behave+0x4dc>
				path_find(16);
    1864:	80 e1       	ldi	r24, 0x10	; 16
    1866:	90 e0       	ldi	r25, 0x00	; 0
    1868:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    186c:	1f c0       	rjmp	.+62     	; 0x18ac <node_behave+0x51a>
				else if(deposition_zone_A==1 && color_deposited[0]=='\0')
    186e:	80 91 28 02 	lds	r24, 0x0228
    1872:	90 91 29 02 	lds	r25, 0x0229
    1876:	81 30       	cpi	r24, 0x01	; 1
    1878:	91 05       	cpc	r25, r1
    187a:	49 f4       	brne	.+18     	; 0x188e <node_behave+0x4fc>
    187c:	80 91 8b 02 	lds	r24, 0x028B
    1880:	88 23       	and	r24, r24
    1882:	29 f4       	brne	.+10     	; 0x188e <node_behave+0x4fc>
				path_find(15);
    1884:	8f e0       	ldi	r24, 0x0F	; 15
    1886:	90 e0       	ldi	r25, 0x00	; 0
    1888:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    188c:	0f c0       	rjmp	.+30     	; 0x18ac <node_behave+0x51a>
				else if(deposition_zone_C==1 && color_deposited[2]=='\0')
    188e:	80 91 24 02 	lds	r24, 0x0224
    1892:	90 91 25 02 	lds	r25, 0x0225
    1896:	81 30       	cpi	r24, 0x01	; 1
    1898:	91 05       	cpc	r25, r1
    189a:	41 f4       	brne	.+16     	; 0x18ac <node_behave+0x51a>
    189c:	80 91 8d 02 	lds	r24, 0x028D
    18a0:	88 23       	and	r24, r24
    18a2:	21 f4       	brne	.+8      	; 0x18ac <node_behave+0x51a>
				path_find(17);
    18a4:	81 e1       	ldi	r24, 0x11	; 17
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
			}
		}
		if(node_number==1)
    18ac:	80 91 4d 02 	lds	r24, 0x024D
    18b0:	90 91 4e 02 	lds	r25, 0x024E
    18b4:	81 30       	cpi	r24, 0x01	; 1
    18b6:	91 05       	cpc	r25, r1
    18b8:	09 f0       	breq	.+2      	; 0x18bc <node_behave+0x52a>
    18ba:	9c c0       	rjmp	.+312    	; 0x19f4 <node_behave+0x662>
		{
			distance('f',10,'o');
    18bc:	86 e6       	ldi	r24, 0x66	; 102
    18be:	40 e0       	ldi	r20, 0x00	; 0
    18c0:	50 e0       	ldi	r21, 0x00	; 0
    18c2:	60 e2       	ldi	r22, 0x20	; 32
    18c4:	71 e4       	ldi	r23, 0x41	; 65
    18c6:	2f e6       	ldi	r18, 0x6F	; 111
    18c8:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			left();
    18cc:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
			navigation_in_degrees=navigation_in_degrees+90;
    18d0:	80 91 2a 02 	lds	r24, 0x022A
    18d4:	90 91 2b 02 	lds	r25, 0x022B
    18d8:	86 5a       	subi	r24, 0xA6	; 166
    18da:	9f 4f       	sbci	r25, 0xFF	; 255
    18dc:	90 93 2b 02 	sts	0x022B, r25
    18e0:	80 93 2a 02 	sts	0x022A, r24
			angle_rotate(95);
    18e4:	8f e5       	ldi	r24, 0x5F	; 95
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
			stop();
    18ec:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
			if(weight_block_position_1==2)
    18f0:	80 91 20 02 	lds	r24, 0x0220
    18f4:	90 91 21 02 	lds	r25, 0x0221
    18f8:	82 30       	cpi	r24, 0x02	; 2
    18fa:	91 05       	cpc	r25, r1
    18fc:	91 f5       	brne	.+100    	; 0x1962 <node_behave+0x5d0>
			{
				distance('f',3.5,'o');
    18fe:	86 e6       	ldi	r24, 0x66	; 102
    1900:	40 e0       	ldi	r20, 0x00	; 0
    1902:	50 e0       	ldi	r21, 0x00	; 0
    1904:	60 e6       	ldi	r22, 0x60	; 96
    1906:	70 e4       	ldi	r23, 0x40	; 64
    1908:	2f e6       	ldi	r18, 0x6F	; 111
    190a:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				servo1_mov(16);
    190e:	80 e1       	ldi	r24, 0x10	; 16
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1916:	8f ef       	ldi	r24, 0xFF	; 255
    1918:	9f ef       	ldi	r25, 0xFF	; 255
    191a:	a3 e2       	ldi	r26, 0x23	; 35
    191c:	81 50       	subi	r24, 0x01	; 1
    191e:	90 40       	sbci	r25, 0x00	; 0
    1920:	a0 40       	sbci	r26, 0x00	; 0
    1922:	e1 f7       	brne	.-8      	; 0x191c <node_behave+0x58a>
    1924:	00 c0       	rjmp	.+0      	; 0x1926 <node_behave+0x594>
    1926:	00 00       	nop
				_delay_ms(800);
				servo2_mov(0);
    1928:	80 e0       	ldi	r24, 0x00	; 0
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	9f e7       	ldi	r25, 0x7F	; 127
    1934:	a6 e1       	ldi	r26, 0x16	; 22
    1936:	81 50       	subi	r24, 0x01	; 1
    1938:	90 40       	sbci	r25, 0x00	; 0
    193a:	a0 40       	sbci	r26, 0x00	; 0
    193c:	e1 f7       	brne	.-8      	; 0x1936 <node_behave+0x5a4>
    193e:	00 c0       	rjmp	.+0      	; 0x1940 <node_behave+0x5ae>
    1940:	00 00       	nop
				_delay_ms(500);
				servo1_mov(130);
    1942:	82 e8       	ldi	r24, 0x82	; 130
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    194a:	8f ef       	ldi	r24, 0xFF	; 255
    194c:	9f e7       	ldi	r25, 0x7F	; 127
    194e:	a1 e3       	ldi	r26, 0x31	; 49
    1950:	81 50       	subi	r24, 0x01	; 1
    1952:	90 40       	sbci	r25, 0x00	; 0
    1954:	a0 40       	sbci	r26, 0x00	; 0
    1956:	e1 f7       	brne	.-8      	; 0x1950 <node_behave+0x5be>
    1958:	00 c0       	rjmp	.+0      	; 0x195a <node_behave+0x5c8>
    195a:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    195c:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
    1960:	34 c0       	rjmp	.+104    	; 0x19ca <node_behave+0x638>
			}
			else if(weight_block_position_1==1)
    1962:	81 30       	cpi	r24, 0x01	; 1
    1964:	91 05       	cpc	r25, r1
    1966:	89 f5       	brne	.+98     	; 0x19ca <node_behave+0x638>
			{
				distance('f',5,'o');
    1968:	86 e6       	ldi	r24, 0x66	; 102
    196a:	40 e0       	ldi	r20, 0x00	; 0
    196c:	50 e0       	ldi	r21, 0x00	; 0
    196e:	60 ea       	ldi	r22, 0xA0	; 160
    1970:	70 e4       	ldi	r23, 0x40	; 64
    1972:	2f e6       	ldi	r18, 0x6F	; 111
    1974:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				servo1_mov(9);
    1978:	89 e0       	ldi	r24, 0x09	; 9
    197a:	90 e0       	ldi	r25, 0x00	; 0
    197c:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1980:	8f ef       	ldi	r24, 0xFF	; 255
    1982:	9f ef       	ldi	r25, 0xFF	; 255
    1984:	a3 e2       	ldi	r26, 0x23	; 35
    1986:	81 50       	subi	r24, 0x01	; 1
    1988:	90 40       	sbci	r25, 0x00	; 0
    198a:	a0 40       	sbci	r26, 0x00	; 0
    198c:	e1 f7       	brne	.-8      	; 0x1986 <node_behave+0x5f4>
    198e:	00 c0       	rjmp	.+0      	; 0x1990 <node_behave+0x5fe>
    1990:	00 00       	nop
				_delay_ms(800);
				servo2_mov(0);
    1992:	80 e0       	ldi	r24, 0x00	; 0
    1994:	90 e0       	ldi	r25, 0x00	; 0
    1996:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    199a:	8f ef       	ldi	r24, 0xFF	; 255
    199c:	9f e7       	ldi	r25, 0x7F	; 127
    199e:	a6 e1       	ldi	r26, 0x16	; 22
    19a0:	81 50       	subi	r24, 0x01	; 1
    19a2:	90 40       	sbci	r25, 0x00	; 0
    19a4:	a0 40       	sbci	r26, 0x00	; 0
    19a6:	e1 f7       	brne	.-8      	; 0x19a0 <node_behave+0x60e>
    19a8:	00 c0       	rjmp	.+0      	; 0x19aa <node_behave+0x618>
    19aa:	00 00       	nop
				_delay_ms(500);
				servo1_mov(130);
    19ac:	82 e8       	ldi	r24, 0x82	; 130
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    19b4:	8f ef       	ldi	r24, 0xFF	; 255
    19b6:	9f e7       	ldi	r25, 0x7F	; 127
    19b8:	a1 e3       	ldi	r26, 0x31	; 49
    19ba:	81 50       	subi	r24, 0x01	; 1
    19bc:	90 40       	sbci	r25, 0x00	; 0
    19be:	a0 40       	sbci	r26, 0x00	; 0
    19c0:	e1 f7       	brne	.-8      	; 0x19ba <node_behave+0x628>
    19c2:	00 c0       	rjmp	.+0      	; 0x19c4 <node_behave+0x632>
    19c4:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    19c6:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
			}
			weight_block_position_1--;
    19ca:	80 91 20 02 	lds	r24, 0x0220
    19ce:	90 91 21 02 	lds	r25, 0x0221
    19d2:	01 97       	sbiw	r24, 0x01	; 1
    19d4:	90 93 21 02 	sts	0x0221, r25
    19d8:	80 93 20 02 	sts	0x0220, r24
			distance('b',14,'o');
    19dc:	82 e6       	ldi	r24, 0x62	; 98
    19de:	40 e0       	ldi	r20, 0x00	; 0
    19e0:	50 e0       	ldi	r21, 0x00	; 0
    19e2:	60 e6       	ldi	r22, 0x60	; 96
    19e4:	71 e4       	ldi	r23, 0x41	; 65
    19e6:	2f e6       	ldi	r18, 0x6F	; 111
    19e8:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			enq_end(4);
    19ec:	84 e0       	ldi	r24, 0x04	; 4
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
		}

		if(node_number==13)
    19f4:	80 91 4d 02 	lds	r24, 0x024D
    19f8:	90 91 4e 02 	lds	r25, 0x024E
    19fc:	8d 30       	cpi	r24, 0x0D	; 13
    19fe:	91 05       	cpc	r25, r1
    1a00:	09 f0       	breq	.+2      	; 0x1a04 <node_behave+0x672>
    1a02:	26 c1       	rjmp	.+588    	; 0x1c50 <node_behave+0x8be>
		{
			if(weight_block_position_5!=0)
    1a04:	80 91 18 02 	lds	r24, 0x0218
    1a08:	90 91 19 02 	lds	r25, 0x0219
    1a0c:	00 97       	sbiw	r24, 0x00	; 0
    1a0e:	09 f4       	brne	.+2      	; 0x1a12 <node_behave+0x680>
    1a10:	83 c0       	rjmp	.+262    	; 0x1b18 <node_behave+0x786>
			{
				distance('f',12,'o');
    1a12:	86 e6       	ldi	r24, 0x66	; 102
    1a14:	40 e0       	ldi	r20, 0x00	; 0
    1a16:	50 e0       	ldi	r21, 0x00	; 0
    1a18:	60 e4       	ldi	r22, 0x40	; 64
    1a1a:	71 e4       	ldi	r23, 0x41	; 65
    1a1c:	2f e6       	ldi	r18, 0x6F	; 111
    1a1e:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				if(weight_block_position_5==2)
    1a22:	80 91 18 02 	lds	r24, 0x0218
    1a26:	90 91 19 02 	lds	r25, 0x0219
    1a2a:	82 30       	cpi	r24, 0x02	; 2
    1a2c:	91 05       	cpc	r25, r1
    1a2e:	51 f5       	brne	.+84     	; 0x1a84 <node_behave+0x6f2>
				{
					servo1_mov(16);
    1a30:	80 e1       	ldi	r24, 0x10	; 16
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1a38:	8f ef       	ldi	r24, 0xFF	; 255
    1a3a:	9f ef       	ldi	r25, 0xFF	; 255
    1a3c:	a3 e2       	ldi	r26, 0x23	; 35
    1a3e:	81 50       	subi	r24, 0x01	; 1
    1a40:	90 40       	sbci	r25, 0x00	; 0
    1a42:	a0 40       	sbci	r26, 0x00	; 0
    1a44:	e1 f7       	brne	.-8      	; 0x1a3e <node_behave+0x6ac>
    1a46:	00 c0       	rjmp	.+0      	; 0x1a48 <node_behave+0x6b6>
    1a48:	00 00       	nop
					_delay_ms(800);
					servo2_mov(0);
    1a4a:	80 e0       	ldi	r24, 0x00	; 0
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1a52:	8f ef       	ldi	r24, 0xFF	; 255
    1a54:	9f e7       	ldi	r25, 0x7F	; 127
    1a56:	a6 e1       	ldi	r26, 0x16	; 22
    1a58:	81 50       	subi	r24, 0x01	; 1
    1a5a:	90 40       	sbci	r25, 0x00	; 0
    1a5c:	a0 40       	sbci	r26, 0x00	; 0
    1a5e:	e1 f7       	brne	.-8      	; 0x1a58 <node_behave+0x6c6>
    1a60:	00 c0       	rjmp	.+0      	; 0x1a62 <node_behave+0x6d0>
    1a62:	00 00       	nop
					_delay_ms(500);
					servo1_mov(130);
    1a64:	82 e8       	ldi	r24, 0x82	; 130
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1a6c:	8f ef       	ldi	r24, 0xFF	; 255
    1a6e:	9f e7       	ldi	r25, 0x7F	; 127
    1a70:	a1 e3       	ldi	r26, 0x31	; 49
    1a72:	81 50       	subi	r24, 0x01	; 1
    1a74:	90 40       	sbci	r25, 0x00	; 0
    1a76:	a0 40       	sbci	r26, 0x00	; 0
    1a78:	e1 f7       	brne	.-8      	; 0x1a72 <node_behave+0x6e0>
    1a7a:	00 c0       	rjmp	.+0      	; 0x1a7c <node_behave+0x6ea>
    1a7c:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1a7e:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
    1a82:	34 c0       	rjmp	.+104    	; 0x1aec <node_behave+0x75a>
				}
				else if(weight_block_position_5==1)
    1a84:	81 30       	cpi	r24, 0x01	; 1
    1a86:	91 05       	cpc	r25, r1
    1a88:	89 f5       	brne	.+98     	; 0x1aec <node_behave+0x75a>
				{
					distance('f',2,'o');
    1a8a:	86 e6       	ldi	r24, 0x66	; 102
    1a8c:	40 e0       	ldi	r20, 0x00	; 0
    1a8e:	50 e0       	ldi	r21, 0x00	; 0
    1a90:	60 e0       	ldi	r22, 0x00	; 0
    1a92:	70 e4       	ldi	r23, 0x40	; 64
    1a94:	2f e6       	ldi	r18, 0x6F	; 111
    1a96:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
					servo1_mov(9);
    1a9a:	89 e0       	ldi	r24, 0x09	; 9
    1a9c:	90 e0       	ldi	r25, 0x00	; 0
    1a9e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1aa2:	8f ef       	ldi	r24, 0xFF	; 255
    1aa4:	9f ef       	ldi	r25, 0xFF	; 255
    1aa6:	a3 e2       	ldi	r26, 0x23	; 35
    1aa8:	81 50       	subi	r24, 0x01	; 1
    1aaa:	90 40       	sbci	r25, 0x00	; 0
    1aac:	a0 40       	sbci	r26, 0x00	; 0
    1aae:	e1 f7       	brne	.-8      	; 0x1aa8 <node_behave+0x716>
    1ab0:	00 c0       	rjmp	.+0      	; 0x1ab2 <node_behave+0x720>
    1ab2:	00 00       	nop
					_delay_ms(800);
					servo2_mov(0);
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	90 e0       	ldi	r25, 0x00	; 0
    1ab8:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1abc:	8f ef       	ldi	r24, 0xFF	; 255
    1abe:	9f e7       	ldi	r25, 0x7F	; 127
    1ac0:	a6 e1       	ldi	r26, 0x16	; 22
    1ac2:	81 50       	subi	r24, 0x01	; 1
    1ac4:	90 40       	sbci	r25, 0x00	; 0
    1ac6:	a0 40       	sbci	r26, 0x00	; 0
    1ac8:	e1 f7       	brne	.-8      	; 0x1ac2 <node_behave+0x730>
    1aca:	00 c0       	rjmp	.+0      	; 0x1acc <node_behave+0x73a>
    1acc:	00 00       	nop
					_delay_ms(500);
					servo1_mov(130);
    1ace:	82 e8       	ldi	r24, 0x82	; 130
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1ad6:	8f ef       	ldi	r24, 0xFF	; 255
    1ad8:	9f e7       	ldi	r25, 0x7F	; 127
    1ada:	a1 e3       	ldi	r26, 0x31	; 49
    1adc:	81 50       	subi	r24, 0x01	; 1
    1ade:	90 40       	sbci	r25, 0x00	; 0
    1ae0:	a0 40       	sbci	r26, 0x00	; 0
    1ae2:	e1 f7       	brne	.-8      	; 0x1adc <node_behave+0x74a>
    1ae4:	00 c0       	rjmp	.+0      	; 0x1ae6 <node_behave+0x754>
    1ae6:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1ae8:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
				}
				weight_block_position_5--;
    1aec:	80 91 18 02 	lds	r24, 0x0218
    1af0:	90 91 19 02 	lds	r25, 0x0219
    1af4:	01 97       	sbiw	r24, 0x01	; 1
    1af6:	90 93 19 02 	sts	0x0219, r25
    1afa:	80 93 18 02 	sts	0x0218, r24
				distance('b',14,'o');
    1afe:	82 e6       	ldi	r24, 0x62	; 98
    1b00:	40 e0       	ldi	r20, 0x00	; 0
    1b02:	50 e0       	ldi	r21, 0x00	; 0
    1b04:	60 e6       	ldi	r22, 0x60	; 96
    1b06:	71 e4       	ldi	r23, 0x41	; 65
    1b08:	2f e6       	ldi	r18, 0x6F	; 111
    1b0a:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				enq_end(14);
    1b0e:	8e e0       	ldi	r24, 0x0E	; 14
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
    1b16:	9c c0       	rjmp	.+312    	; 0x1c50 <node_behave+0x8be>
			}
			else
			{
				distance('f',11,'o');
    1b18:	86 e6       	ldi	r24, 0x66	; 102
    1b1a:	40 e0       	ldi	r20, 0x00	; 0
    1b1c:	50 e0       	ldi	r21, 0x00	; 0
    1b1e:	60 e3       	ldi	r22, 0x30	; 48
    1b20:	71 e4       	ldi	r23, 0x41	; 65
    1b22:	2f e6       	ldi	r18, 0x6F	; 111
    1b24:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				left();
    1b28:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
				navigation_in_degrees=navigation_in_degrees+90;
    1b2c:	80 91 2a 02 	lds	r24, 0x022A
    1b30:	90 91 2b 02 	lds	r25, 0x022B
    1b34:	86 5a       	subi	r24, 0xA6	; 166
    1b36:	9f 4f       	sbci	r25, 0xFF	; 255
    1b38:	90 93 2b 02 	sts	0x022B, r25
    1b3c:	80 93 2a 02 	sts	0x022A, r24
				angle_rotate(97);
    1b40:	81 e6       	ldi	r24, 0x61	; 97
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
				stop();
    1b48:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
				if(weight_block_position_4==2)
    1b4c:	80 91 1a 02 	lds	r24, 0x021A
    1b50:	90 91 1b 02 	lds	r25, 0x021B
    1b54:	82 30       	cpi	r24, 0x02	; 2
    1b56:	91 05       	cpc	r25, r1
    1b58:	91 f5       	brne	.+100    	; 0x1bbe <node_behave+0x82c>
				{
					distance('f',4,'o');
    1b5a:	86 e6       	ldi	r24, 0x66	; 102
    1b5c:	40 e0       	ldi	r20, 0x00	; 0
    1b5e:	50 e0       	ldi	r21, 0x00	; 0
    1b60:	60 e8       	ldi	r22, 0x80	; 128
    1b62:	70 e4       	ldi	r23, 0x40	; 64
    1b64:	2f e6       	ldi	r18, 0x6F	; 111
    1b66:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
					servo1_mov(16);
    1b6a:	80 e1       	ldi	r24, 0x10	; 16
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1b72:	8f ef       	ldi	r24, 0xFF	; 255
    1b74:	9f ef       	ldi	r25, 0xFF	; 255
    1b76:	a3 e2       	ldi	r26, 0x23	; 35
    1b78:	81 50       	subi	r24, 0x01	; 1
    1b7a:	90 40       	sbci	r25, 0x00	; 0
    1b7c:	a0 40       	sbci	r26, 0x00	; 0
    1b7e:	e1 f7       	brne	.-8      	; 0x1b78 <node_behave+0x7e6>
    1b80:	00 c0       	rjmp	.+0      	; 0x1b82 <node_behave+0x7f0>
    1b82:	00 00       	nop
					_delay_ms(800);
					servo2_mov(0);
    1b84:	80 e0       	ldi	r24, 0x00	; 0
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1b8c:	8f ef       	ldi	r24, 0xFF	; 255
    1b8e:	9f e7       	ldi	r25, 0x7F	; 127
    1b90:	a6 e1       	ldi	r26, 0x16	; 22
    1b92:	81 50       	subi	r24, 0x01	; 1
    1b94:	90 40       	sbci	r25, 0x00	; 0
    1b96:	a0 40       	sbci	r26, 0x00	; 0
    1b98:	e1 f7       	brne	.-8      	; 0x1b92 <node_behave+0x800>
    1b9a:	00 c0       	rjmp	.+0      	; 0x1b9c <node_behave+0x80a>
    1b9c:	00 00       	nop
					_delay_ms(500);
					servo1_mov(130);
    1b9e:	82 e8       	ldi	r24, 0x82	; 130
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1ba6:	8f ef       	ldi	r24, 0xFF	; 255
    1ba8:	9f e7       	ldi	r25, 0x7F	; 127
    1baa:	a1 e3       	ldi	r26, 0x31	; 49
    1bac:	81 50       	subi	r24, 0x01	; 1
    1bae:	90 40       	sbci	r25, 0x00	; 0
    1bb0:	a0 40       	sbci	r26, 0x00	; 0
    1bb2:	e1 f7       	brne	.-8      	; 0x1bac <node_behave+0x81a>
    1bb4:	00 c0       	rjmp	.+0      	; 0x1bb6 <node_behave+0x824>
    1bb6:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1bb8:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
    1bbc:	34 c0       	rjmp	.+104    	; 0x1c26 <node_behave+0x894>
				}
				else if(weight_block_position_4==1)
    1bbe:	81 30       	cpi	r24, 0x01	; 1
    1bc0:	91 05       	cpc	r25, r1
    1bc2:	89 f5       	brne	.+98     	; 0x1c26 <node_behave+0x894>
				{
					distance('f',5,'o');
    1bc4:	86 e6       	ldi	r24, 0x66	; 102
    1bc6:	40 e0       	ldi	r20, 0x00	; 0
    1bc8:	50 e0       	ldi	r21, 0x00	; 0
    1bca:	60 ea       	ldi	r22, 0xA0	; 160
    1bcc:	70 e4       	ldi	r23, 0x40	; 64
    1bce:	2f e6       	ldi	r18, 0x6F	; 111
    1bd0:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
					servo1_mov(9);
    1bd4:	89 e0       	ldi	r24, 0x09	; 9
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1bdc:	8f ef       	ldi	r24, 0xFF	; 255
    1bde:	9f ef       	ldi	r25, 0xFF	; 255
    1be0:	a3 e2       	ldi	r26, 0x23	; 35
    1be2:	81 50       	subi	r24, 0x01	; 1
    1be4:	90 40       	sbci	r25, 0x00	; 0
    1be6:	a0 40       	sbci	r26, 0x00	; 0
    1be8:	e1 f7       	brne	.-8      	; 0x1be2 <node_behave+0x850>
    1bea:	00 c0       	rjmp	.+0      	; 0x1bec <node_behave+0x85a>
    1bec:	00 00       	nop
					_delay_ms(800);
					servo2_mov(0);
    1bee:	80 e0       	ldi	r24, 0x00	; 0
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1bf6:	8f ef       	ldi	r24, 0xFF	; 255
    1bf8:	9f e7       	ldi	r25, 0x7F	; 127
    1bfa:	a6 e1       	ldi	r26, 0x16	; 22
    1bfc:	81 50       	subi	r24, 0x01	; 1
    1bfe:	90 40       	sbci	r25, 0x00	; 0
    1c00:	a0 40       	sbci	r26, 0x00	; 0
    1c02:	e1 f7       	brne	.-8      	; 0x1bfc <node_behave+0x86a>
    1c04:	00 c0       	rjmp	.+0      	; 0x1c06 <node_behave+0x874>
    1c06:	00 00       	nop
					_delay_ms(500);
					servo1_mov(130);
    1c08:	82 e8       	ldi	r24, 0x82	; 130
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1c10:	8f ef       	ldi	r24, 0xFF	; 255
    1c12:	9f e7       	ldi	r25, 0x7F	; 127
    1c14:	a1 e3       	ldi	r26, 0x31	; 49
    1c16:	81 50       	subi	r24, 0x01	; 1
    1c18:	90 40       	sbci	r25, 0x00	; 0
    1c1a:	a0 40       	sbci	r26, 0x00	; 0
    1c1c:	e1 f7       	brne	.-8      	; 0x1c16 <node_behave+0x884>
    1c1e:	00 c0       	rjmp	.+0      	; 0x1c20 <node_behave+0x88e>
    1c20:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1c22:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
				}
			weight_block_position_4--;
    1c26:	80 91 1a 02 	lds	r24, 0x021A
    1c2a:	90 91 1b 02 	lds	r25, 0x021B
    1c2e:	01 97       	sbiw	r24, 0x01	; 1
    1c30:	90 93 1b 02 	sts	0x021B, r25
    1c34:	80 93 1a 02 	sts	0x021A, r24
			distance('b',14,'o');
    1c38:	82 e6       	ldi	r24, 0x62	; 98
    1c3a:	40 e0       	ldi	r20, 0x00	; 0
    1c3c:	50 e0       	ldi	r21, 0x00	; 0
    1c3e:	60 e6       	ldi	r22, 0x60	; 96
    1c40:	71 e4       	ldi	r23, 0x41	; 65
    1c42:	2f e6       	ldi	r18, 0x6F	; 111
    1c44:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			enq_end(14);
    1c48:	8e e0       	ldi	r24, 0x0E	; 14
    1c4a:	90 e0       	ldi	r25, 0x00	; 0
    1c4c:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
			}
		}

		if(node_number==3)
    1c50:	80 91 4d 02 	lds	r24, 0x024D
    1c54:	90 91 4e 02 	lds	r25, 0x024E
    1c58:	83 30       	cpi	r24, 0x03	; 3
    1c5a:	91 05       	cpc	r25, r1
    1c5c:	09 f0       	breq	.+2      	; 0x1c60 <node_behave+0x8ce>
    1c5e:	82 c0       	rjmp	.+260    	; 0x1d64 <node_behave+0x9d2>
		{
			distance('f',11.5,'o');
    1c60:	86 e6       	ldi	r24, 0x66	; 102
    1c62:	40 e0       	ldi	r20, 0x00	; 0
    1c64:	50 e0       	ldi	r21, 0x00	; 0
    1c66:	68 e3       	ldi	r22, 0x38	; 56
    1c68:	71 e4       	ldi	r23, 0x41	; 65
    1c6a:	2f e6       	ldi	r18, 0x6F	; 111
    1c6c:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			if(weight_block_position_2==2)
    1c70:	80 91 1e 02 	lds	r24, 0x021E
    1c74:	90 91 1f 02 	lds	r25, 0x021F
    1c78:	82 30       	cpi	r24, 0x02	; 2
    1c7a:	91 05       	cpc	r25, r1
    1c7c:	51 f5       	brne	.+84     	; 0x1cd2 <node_behave+0x940>
			{
				servo1_mov(14);
    1c7e:	8e e0       	ldi	r24, 0x0E	; 14
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1c86:	8f ef       	ldi	r24, 0xFF	; 255
    1c88:	9f ef       	ldi	r25, 0xFF	; 255
    1c8a:	a3 e2       	ldi	r26, 0x23	; 35
    1c8c:	81 50       	subi	r24, 0x01	; 1
    1c8e:	90 40       	sbci	r25, 0x00	; 0
    1c90:	a0 40       	sbci	r26, 0x00	; 0
    1c92:	e1 f7       	brne	.-8      	; 0x1c8c <node_behave+0x8fa>
    1c94:	00 c0       	rjmp	.+0      	; 0x1c96 <node_behave+0x904>
    1c96:	00 00       	nop
				_delay_ms(800);
				servo2_mov(0);
    1c98:	80 e0       	ldi	r24, 0x00	; 0
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1ca0:	8f ef       	ldi	r24, 0xFF	; 255
    1ca2:	9f e7       	ldi	r25, 0x7F	; 127
    1ca4:	a6 e1       	ldi	r26, 0x16	; 22
    1ca6:	81 50       	subi	r24, 0x01	; 1
    1ca8:	90 40       	sbci	r25, 0x00	; 0
    1caa:	a0 40       	sbci	r26, 0x00	; 0
    1cac:	e1 f7       	brne	.-8      	; 0x1ca6 <node_behave+0x914>
    1cae:	00 c0       	rjmp	.+0      	; 0x1cb0 <node_behave+0x91e>
    1cb0:	00 00       	nop
				_delay_ms(500);
				servo1_mov(130);
    1cb2:	82 e8       	ldi	r24, 0x82	; 130
    1cb4:	90 e0       	ldi	r25, 0x00	; 0
    1cb6:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1cba:	8f ef       	ldi	r24, 0xFF	; 255
    1cbc:	9f e7       	ldi	r25, 0x7F	; 127
    1cbe:	a1 e3       	ldi	r26, 0x31	; 49
    1cc0:	81 50       	subi	r24, 0x01	; 1
    1cc2:	90 40       	sbci	r25, 0x00	; 0
    1cc4:	a0 40       	sbci	r26, 0x00	; 0
    1cc6:	e1 f7       	brne	.-8      	; 0x1cc0 <node_behave+0x92e>
    1cc8:	00 c0       	rjmp	.+0      	; 0x1cca <node_behave+0x938>
    1cca:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1ccc:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
    1cd0:	34 c0       	rjmp	.+104    	; 0x1d3a <node_behave+0x9a8>
			}
			else if(weight_block_position_2==1)
    1cd2:	81 30       	cpi	r24, 0x01	; 1
    1cd4:	91 05       	cpc	r25, r1
    1cd6:	89 f5       	brne	.+98     	; 0x1d3a <node_behave+0x9a8>
			{
				distance('f',4,'o');
    1cd8:	86 e6       	ldi	r24, 0x66	; 102
    1cda:	40 e0       	ldi	r20, 0x00	; 0
    1cdc:	50 e0       	ldi	r21, 0x00	; 0
    1cde:	60 e8       	ldi	r22, 0x80	; 128
    1ce0:	70 e4       	ldi	r23, 0x40	; 64
    1ce2:	2f e6       	ldi	r18, 0x6F	; 111
    1ce4:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				servo1_mov(9);
    1ce8:	89 e0       	ldi	r24, 0x09	; 9
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1cf0:	8f ef       	ldi	r24, 0xFF	; 255
    1cf2:	9f ef       	ldi	r25, 0xFF	; 255
    1cf4:	a3 e2       	ldi	r26, 0x23	; 35
    1cf6:	81 50       	subi	r24, 0x01	; 1
    1cf8:	90 40       	sbci	r25, 0x00	; 0
    1cfa:	a0 40       	sbci	r26, 0x00	; 0
    1cfc:	e1 f7       	brne	.-8      	; 0x1cf6 <node_behave+0x964>
    1cfe:	00 c0       	rjmp	.+0      	; 0x1d00 <node_behave+0x96e>
    1d00:	00 00       	nop
				_delay_ms(800);
				servo2_mov(0);
    1d02:	80 e0       	ldi	r24, 0x00	; 0
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1d0a:	8f ef       	ldi	r24, 0xFF	; 255
    1d0c:	9f e7       	ldi	r25, 0x7F	; 127
    1d0e:	a6 e1       	ldi	r26, 0x16	; 22
    1d10:	81 50       	subi	r24, 0x01	; 1
    1d12:	90 40       	sbci	r25, 0x00	; 0
    1d14:	a0 40       	sbci	r26, 0x00	; 0
    1d16:	e1 f7       	brne	.-8      	; 0x1d10 <node_behave+0x97e>
    1d18:	00 c0       	rjmp	.+0      	; 0x1d1a <node_behave+0x988>
    1d1a:	00 00       	nop
				_delay_ms(500);
				servo1_mov(130);
    1d1c:	82 e8       	ldi	r24, 0x82	; 130
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1d24:	8f ef       	ldi	r24, 0xFF	; 255
    1d26:	9f e7       	ldi	r25, 0x7F	; 127
    1d28:	a1 e3       	ldi	r26, 0x31	; 49
    1d2a:	81 50       	subi	r24, 0x01	; 1
    1d2c:	90 40       	sbci	r25, 0x00	; 0
    1d2e:	a0 40       	sbci	r26, 0x00	; 0
    1d30:	e1 f7       	brne	.-8      	; 0x1d2a <node_behave+0x998>
    1d32:	00 c0       	rjmp	.+0      	; 0x1d34 <node_behave+0x9a2>
    1d34:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1d36:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
			}
			weight_block_position_2--;
    1d3a:	80 91 1e 02 	lds	r24, 0x021E
    1d3e:	90 91 1f 02 	lds	r25, 0x021F
    1d42:	01 97       	sbiw	r24, 0x01	; 1
    1d44:	90 93 1f 02 	sts	0x021F, r25
    1d48:	80 93 1e 02 	sts	0x021E, r24
			distance('b',14.5,'o');
    1d4c:	82 e6       	ldi	r24, 0x62	; 98
    1d4e:	40 e0       	ldi	r20, 0x00	; 0
    1d50:	50 e0       	ldi	r21, 0x00	; 0
    1d52:	68 e6       	ldi	r22, 0x68	; 104
    1d54:	71 e4       	ldi	r23, 0x41	; 65
    1d56:	2f e6       	ldi	r18, 0x6F	; 111
    1d58:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			enq_end(4);              //adding node 4 in priority queue
    1d5c:	84 e0       	ldi	r24, 0x04	; 4
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
		}
		if(node_number==12)
    1d64:	80 91 4d 02 	lds	r24, 0x024D
    1d68:	90 91 4e 02 	lds	r25, 0x024E
    1d6c:	8c 30       	cpi	r24, 0x0C	; 12
    1d6e:	91 05       	cpc	r25, r1
    1d70:	09 f0       	breq	.+2      	; 0x1d74 <node_behave+0x9e2>
    1d72:	82 c0       	rjmp	.+260    	; 0x1e78 <node_behave+0xae6>
		{
			distance('f',12,'o');
    1d74:	86 e6       	ldi	r24, 0x66	; 102
    1d76:	40 e0       	ldi	r20, 0x00	; 0
    1d78:	50 e0       	ldi	r21, 0x00	; 0
    1d7a:	60 e4       	ldi	r22, 0x40	; 64
    1d7c:	71 e4       	ldi	r23, 0x41	; 65
    1d7e:	2f e6       	ldi	r18, 0x6F	; 111
    1d80:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			if(weight_block_position_3==2)
    1d84:	80 91 1c 02 	lds	r24, 0x021C
    1d88:	90 91 1d 02 	lds	r25, 0x021D
    1d8c:	82 30       	cpi	r24, 0x02	; 2
    1d8e:	91 05       	cpc	r25, r1
    1d90:	51 f5       	brne	.+84     	; 0x1de6 <node_behave+0xa54>
			{
				servo1_mov(16);
    1d92:	80 e1       	ldi	r24, 0x10	; 16
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1d9a:	8f ef       	ldi	r24, 0xFF	; 255
    1d9c:	9f ef       	ldi	r25, 0xFF	; 255
    1d9e:	a3 e2       	ldi	r26, 0x23	; 35
    1da0:	81 50       	subi	r24, 0x01	; 1
    1da2:	90 40       	sbci	r25, 0x00	; 0
    1da4:	a0 40       	sbci	r26, 0x00	; 0
    1da6:	e1 f7       	brne	.-8      	; 0x1da0 <node_behave+0xa0e>
    1da8:	00 c0       	rjmp	.+0      	; 0x1daa <node_behave+0xa18>
    1daa:	00 00       	nop
				_delay_ms(800);
				servo2_mov(0);
    1dac:	80 e0       	ldi	r24, 0x00	; 0
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1db4:	8f ef       	ldi	r24, 0xFF	; 255
    1db6:	9f e7       	ldi	r25, 0x7F	; 127
    1db8:	a6 e1       	ldi	r26, 0x16	; 22
    1dba:	81 50       	subi	r24, 0x01	; 1
    1dbc:	90 40       	sbci	r25, 0x00	; 0
    1dbe:	a0 40       	sbci	r26, 0x00	; 0
    1dc0:	e1 f7       	brne	.-8      	; 0x1dba <node_behave+0xa28>
    1dc2:	00 c0       	rjmp	.+0      	; 0x1dc4 <node_behave+0xa32>
    1dc4:	00 00       	nop
				_delay_ms(500);
				servo1_mov(130);
    1dc6:	82 e8       	ldi	r24, 0x82	; 130
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1dce:	8f ef       	ldi	r24, 0xFF	; 255
    1dd0:	9f e7       	ldi	r25, 0x7F	; 127
    1dd2:	a1 e3       	ldi	r26, 0x31	; 49
    1dd4:	81 50       	subi	r24, 0x01	; 1
    1dd6:	90 40       	sbci	r25, 0x00	; 0
    1dd8:	a0 40       	sbci	r26, 0x00	; 0
    1dda:	e1 f7       	brne	.-8      	; 0x1dd4 <node_behave+0xa42>
    1ddc:	00 c0       	rjmp	.+0      	; 0x1dde <node_behave+0xa4c>
    1dde:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1de0:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
    1de4:	34 c0       	rjmp	.+104    	; 0x1e4e <node_behave+0xabc>
			}
			else if(weight_block_position_3==1)
    1de6:	81 30       	cpi	r24, 0x01	; 1
    1de8:	91 05       	cpc	r25, r1
    1dea:	89 f5       	brne	.+98     	; 0x1e4e <node_behave+0xabc>
			{
				distance('f',2.5,'o');
    1dec:	86 e6       	ldi	r24, 0x66	; 102
    1dee:	40 e0       	ldi	r20, 0x00	; 0
    1df0:	50 e0       	ldi	r21, 0x00	; 0
    1df2:	60 e2       	ldi	r22, 0x20	; 32
    1df4:	70 e4       	ldi	r23, 0x40	; 64
    1df6:	2f e6       	ldi	r18, 0x6F	; 111
    1df8:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				servo1_mov(9);
    1dfc:	89 e0       	ldi	r24, 0x09	; 9
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1e04:	8f ef       	ldi	r24, 0xFF	; 255
    1e06:	9f ef       	ldi	r25, 0xFF	; 255
    1e08:	a3 e2       	ldi	r26, 0x23	; 35
    1e0a:	81 50       	subi	r24, 0x01	; 1
    1e0c:	90 40       	sbci	r25, 0x00	; 0
    1e0e:	a0 40       	sbci	r26, 0x00	; 0
    1e10:	e1 f7       	brne	.-8      	; 0x1e0a <node_behave+0xa78>
    1e12:	00 c0       	rjmp	.+0      	; 0x1e14 <node_behave+0xa82>
    1e14:	00 00       	nop
				_delay_ms(800);
				servo2_mov(0);
    1e16:	80 e0       	ldi	r24, 0x00	; 0
    1e18:	90 e0       	ldi	r25, 0x00	; 0
    1e1a:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    1e1e:	8f ef       	ldi	r24, 0xFF	; 255
    1e20:	9f e7       	ldi	r25, 0x7F	; 127
    1e22:	a6 e1       	ldi	r26, 0x16	; 22
    1e24:	81 50       	subi	r24, 0x01	; 1
    1e26:	90 40       	sbci	r25, 0x00	; 0
    1e28:	a0 40       	sbci	r26, 0x00	; 0
    1e2a:	e1 f7       	brne	.-8      	; 0x1e24 <node_behave+0xa92>
    1e2c:	00 c0       	rjmp	.+0      	; 0x1e2e <node_behave+0xa9c>
    1e2e:	00 00       	nop
				_delay_ms(500);
				servo1_mov(130);
    1e30:	82 e8       	ldi	r24, 0x82	; 130
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1e38:	8f ef       	ldi	r24, 0xFF	; 255
    1e3a:	9f e7       	ldi	r25, 0x7F	; 127
    1e3c:	a1 e3       	ldi	r26, 0x31	; 49
    1e3e:	81 50       	subi	r24, 0x01	; 1
    1e40:	90 40       	sbci	r25, 0x00	; 0
    1e42:	a0 40       	sbci	r26, 0x00	; 0
    1e44:	e1 f7       	brne	.-8      	; 0x1e3e <node_behave+0xaac>
    1e46:	00 c0       	rjmp	.+0      	; 0x1e48 <node_behave+0xab6>
    1e48:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1e4a:	0e 94 63 08 	call	0x10c6	; 0x10c6 <servo1_free>
			}
			weight_block_position_3--;
    1e4e:	80 91 1c 02 	lds	r24, 0x021C
    1e52:	90 91 1d 02 	lds	r25, 0x021D
    1e56:	01 97       	sbiw	r24, 0x01	; 1
    1e58:	90 93 1d 02 	sts	0x021D, r25
    1e5c:	80 93 1c 02 	sts	0x021C, r24
			distance('b',14,'o');
    1e60:	82 e6       	ldi	r24, 0x62	; 98
    1e62:	40 e0       	ldi	r20, 0x00	; 0
    1e64:	50 e0       	ldi	r21, 0x00	; 0
    1e66:	60 e6       	ldi	r22, 0x60	; 96
    1e68:	71 e4       	ldi	r23, 0x41	; 65
    1e6a:	2f e6       	ldi	r18, 0x6F	; 111
    1e6c:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			enq_end(14);
    1e70:	8e e0       	ldi	r24, 0x0E	; 14
    1e72:	90 e0       	ldi	r25, 0x00	; 0
    1e74:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
		}
		if(node_number==6)
    1e78:	80 91 4d 02 	lds	r24, 0x024D
    1e7c:	90 91 4e 02 	lds	r25, 0x024E
    1e80:	86 30       	cpi	r24, 0x06	; 6
    1e82:	91 05       	cpc	r25, r1
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <node_behave+0xaf6>
    1e86:	14 c2       	rjmp	.+1064   	; 0x22b0 <__stack+0xb1>
		{
			if(IP!=1)
    1e88:	80 91 22 02 	lds	r24, 0x0222
    1e8c:	90 91 23 02 	lds	r25, 0x0223
    1e90:	81 30       	cpi	r24, 0x01	; 1
    1e92:	91 05       	cpc	r25, r1
    1e94:	09 f4       	brne	.+2      	; 0x1e98 <node_behave+0xb06>
    1e96:	a7 c1       	rjmp	.+846    	; 0x21e6 <node_behave+0xe54>
			{
				distance('b',3,'0');
    1e98:	82 e6       	ldi	r24, 0x62	; 98
    1e9a:	40 e0       	ldi	r20, 0x00	; 0
    1e9c:	50 e0       	ldi	r21, 0x00	; 0
    1e9e:	60 e4       	ldi	r22, 0x40	; 64
    1ea0:	70 e4       	ldi	r23, 0x40	; 64
    1ea2:	20 e3       	ldi	r18, 0x30	; 48
    1ea4:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				if(IP==3)
    1ea8:	80 91 22 02 	lds	r24, 0x0222
    1eac:	90 91 23 02 	lds	r25, 0x0223
    1eb0:	83 30       	cpi	r24, 0x03	; 3
    1eb2:	91 05       	cpc	r25, r1
    1eb4:	09 f0       	breq	.+2      	; 0x1eb8 <node_behave+0xb26>
    1eb6:	99 c0       	rjmp	.+306    	; 0x1fea <node_behave+0xc58>
				{
					distance('f',2,'0');
    1eb8:	86 e6       	ldi	r24, 0x66	; 102
    1eba:	40 e0       	ldi	r20, 0x00	; 0
    1ebc:	50 e0       	ldi	r21, 0x00	; 0
    1ebe:	60 e0       	ldi	r22, 0x00	; 0
    1ec0:	70 e4       	ldi	r23, 0x40	; 64
    1ec2:	20 e3       	ldi	r18, 0x30	; 48
    1ec4:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
					servo1_mov(37);
    1ec8:	85 e2       	ldi	r24, 0x25	; 37
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1ed0:	8f ef       	ldi	r24, 0xFF	; 255
    1ed2:	9f ef       	ldi	r25, 0xFF	; 255
    1ed4:	a3 e2       	ldi	r26, 0x23	; 35
    1ed6:	81 50       	subi	r24, 0x01	; 1
    1ed8:	90 40       	sbci	r25, 0x00	; 0
    1eda:	a0 40       	sbci	r26, 0x00	; 0
    1edc:	e1 f7       	brne	.-8      	; 0x1ed6 <node_behave+0xb44>
    1ede:	00 c0       	rjmp	.+0      	; 0x1ee0 <node_behave+0xb4e>
    1ee0:	00 00       	nop
					_delay_ms(800);
					pick_waste();
    1ee2:	0e 94 71 08 	call	0x10e2	; 0x10e2 <pick_waste>
					servo1_mov(80);
    1ee6:	80 e5       	ldi	r24, 0x50	; 80
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1eee:	8f ef       	ldi	r24, 0xFF	; 255
    1ef0:	9f ef       	ldi	r25, 0xFF	; 255
    1ef2:	a3 e2       	ldi	r26, 0x23	; 35
    1ef4:	81 50       	subi	r24, 0x01	; 1
    1ef6:	90 40       	sbci	r25, 0x00	; 0
    1ef8:	a0 40       	sbci	r26, 0x00	; 0
    1efa:	e1 f7       	brne	.-8      	; 0x1ef4 <node_behave+0xb62>
    1efc:	00 c0       	rjmp	.+0      	; 0x1efe <node_behave+0xb6c>
    1efe:	00 00       	nop
					_delay_ms(800);
					left_degrees(180);
    1f00:	84 eb       	ldi	r24, 0xB4	; 180
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	0e 94 c2 06 	call	0xd84	; 0xd84 <left_degrees>
					servo1_mov(0);
    1f08:	80 e0       	ldi	r24, 0x00	; 0
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    1f10:	8f ef       	ldi	r24, 0xFF	; 255
    1f12:	9f ef       	ldi	r25, 0xFF	; 255
    1f14:	ac e2       	ldi	r26, 0x2C	; 44
    1f16:	81 50       	subi	r24, 0x01	; 1
    1f18:	90 40       	sbci	r25, 0x00	; 0
    1f1a:	a0 40       	sbci	r26, 0x00	; 0
    1f1c:	e1 f7       	brne	.-8      	; 0x1f16 <node_behave+0xb84>
    1f1e:	00 c0       	rjmp	.+0      	; 0x1f20 <node_behave+0xb8e>
    1f20:	00 00       	nop
					_delay_ms(1000);
					color_identified='\0';
    1f22:	10 92 42 02 	sts	0x0242, r1
					color_sensor();
    1f26:	c0 e2       	ldi	r28, 0x20	; 32
    1f28:	d5 e1       	ldi	r29, 0x15	; 21
    1f2a:	fe 01       	movw	r30, r28
    1f2c:	19 95       	eicall
					if(color_identified=='\0')
    1f2e:	80 91 42 02 	lds	r24, 0x0242
    1f32:	88 23       	and	r24, r24
    1f34:	c1 f4       	brne	.+48     	; 0x1f66 <node_behave+0xbd4>
					{
						servo2_mov(45);
    1f36:	8d e2       	ldi	r24, 0x2D	; 45
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
						distance('f',2,'o');
    1f3e:	86 e6       	ldi	r24, 0x66	; 102
    1f40:	40 e0       	ldi	r20, 0x00	; 0
    1f42:	50 e0       	ldi	r21, 0x00	; 0
    1f44:	60 e0       	ldi	r22, 0x00	; 0
    1f46:	70 e4       	ldi	r23, 0x40	; 64
    1f48:	2f e6       	ldi	r18, 0x6F	; 111
    1f4a:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
						color_sensor();
    1f4e:	fe 01       	movw	r30, r28
    1f50:	19 95       	eicall
						distance('b',2,'o');
    1f52:	82 e6       	ldi	r24, 0x62	; 98
    1f54:	40 e0       	ldi	r20, 0x00	; 0
    1f56:	50 e0       	ldi	r21, 0x00	; 0
    1f58:	60 e0       	ldi	r22, 0x00	; 0
    1f5a:	70 e4       	ldi	r23, 0x40	; 64
    1f5c:	2f e6       	ldi	r18, 0x6F	; 111
    1f5e:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
						pick_waste();
    1f62:	0e 94 71 08 	call	0x10e2	; 0x10e2 <pick_waste>
					}
					color[color_index]=color_identified;
    1f66:	e0 91 40 02 	lds	r30, 0x0240
    1f6a:	f0 91 41 02 	lds	r31, 0x0241
    1f6e:	eb 5e       	subi	r30, 0xEB	; 235
    1f70:	fa 4f       	sbci	r31, 0xFA	; 250
    1f72:	80 91 42 02 	lds	r24, 0x0242
    1f76:	80 83       	st	Z, r24
					servo1_mov(80);
    1f78:	80 e5       	ldi	r24, 0x50	; 80
    1f7a:	90 e0       	ldi	r25, 0x00	; 0
    1f7c:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
					if(deposition_zone_B==1)
    1f80:	80 91 26 02 	lds	r24, 0x0226
    1f84:	90 91 27 02 	lds	r25, 0x0227
    1f88:	81 30       	cpi	r24, 0x01	; 1
    1f8a:	91 05       	cpc	r25, r1
    1f8c:	29 f4       	brne	.+10     	; 0x1f98 <node_behave+0xc06>
					path_find(16);
    1f8e:	80 e1       	ldi	r24, 0x10	; 16
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    1f96:	17 c0       	rjmp	.+46     	; 0x1fc6 <node_behave+0xc34>
					else if(deposition_zone_A==1)
    1f98:	80 91 28 02 	lds	r24, 0x0228
    1f9c:	90 91 29 02 	lds	r25, 0x0229
    1fa0:	81 30       	cpi	r24, 0x01	; 1
    1fa2:	91 05       	cpc	r25, r1
    1fa4:	29 f4       	brne	.+10     	; 0x1fb0 <node_behave+0xc1e>
					path_find(15);
    1fa6:	8f e0       	ldi	r24, 0x0F	; 15
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    1fae:	0b c0       	rjmp	.+22     	; 0x1fc6 <node_behave+0xc34>
					else if(deposition_zone_C==1)
    1fb0:	80 91 24 02 	lds	r24, 0x0224
    1fb4:	90 91 25 02 	lds	r25, 0x0225
    1fb8:	81 30       	cpi	r24, 0x01	; 1
    1fba:	91 05       	cpc	r25, r1
    1fbc:	21 f4       	brne	.+8      	; 0x1fc6 <node_behave+0xc34>
					path_find(17);
    1fbe:	81 e1       	ldi	r24, 0x11	; 17
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
					path_index++;
    1fc6:	80 91 47 02 	lds	r24, 0x0247
    1fca:	90 91 48 02 	lds	r25, 0x0248
    1fce:	01 96       	adiw	r24, 0x01	; 1
    1fd0:	90 93 48 02 	sts	0x0248, r25
    1fd4:	80 93 47 02 	sts	0x0247, r24
					color_index++;
    1fd8:	80 91 40 02 	lds	r24, 0x0240
    1fdc:	90 91 41 02 	lds	r25, 0x0241
    1fe0:	01 96       	adiw	r24, 0x01	; 1
    1fe2:	90 93 41 02 	sts	0x0241, r25
    1fe6:	80 93 40 02 	sts	0x0240, r24
				}
			if(IP==2)
    1fea:	80 91 22 02 	lds	r24, 0x0222
    1fee:	90 91 23 02 	lds	r25, 0x0223
    1ff2:	82 30       	cpi	r24, 0x02	; 2
    1ff4:	91 05       	cpc	r25, r1
    1ff6:	09 f0       	breq	.+2      	; 0x1ffa <node_behave+0xc68>
    1ff8:	ec c0       	rjmp	.+472    	; 0x21d2 <node_behave+0xe40>
				{
					distance('f',2,'o');
    1ffa:	86 e6       	ldi	r24, 0x66	; 102
    1ffc:	40 e0       	ldi	r20, 0x00	; 0
    1ffe:	50 e0       	ldi	r21, 0x00	; 0
    2000:	60 e0       	ldi	r22, 0x00	; 0
    2002:	70 e4       	ldi	r23, 0x40	; 64
    2004:	2f e6       	ldi	r18, 0x6F	; 111
    2006:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
					servo1_mov(25);
    200a:	89 e1       	ldi	r24, 0x19	; 25
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    2012:	8f ef       	ldi	r24, 0xFF	; 255
    2014:	9f ef       	ldi	r25, 0xFF	; 255
    2016:	a3 e2       	ldi	r26, 0x23	; 35
    2018:	81 50       	subi	r24, 0x01	; 1
    201a:	90 40       	sbci	r25, 0x00	; 0
    201c:	a0 40       	sbci	r26, 0x00	; 0
    201e:	e1 f7       	brne	.-8      	; 0x2018 <node_behave+0xc86>
    2020:	00 c0       	rjmp	.+0      	; 0x2022 <node_behave+0xc90>
    2022:	00 00       	nop
					_delay_ms(800);
					pick_waste();
    2024:	0e 94 71 08 	call	0x10e2	; 0x10e2 <pick_waste>
					servo1_mov(80);
    2028:	80 e5       	ldi	r24, 0x50	; 80
    202a:	90 e0       	ldi	r25, 0x00	; 0
    202c:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    2030:	8f ef       	ldi	r24, 0xFF	; 255
    2032:	9f ef       	ldi	r25, 0xFF	; 255
    2034:	a3 e2       	ldi	r26, 0x23	; 35
    2036:	81 50       	subi	r24, 0x01	; 1
    2038:	90 40       	sbci	r25, 0x00	; 0
    203a:	a0 40       	sbci	r26, 0x00	; 0
    203c:	e1 f7       	brne	.-8      	; 0x2036 <node_behave+0xca4>
    203e:	00 c0       	rjmp	.+0      	; 0x2040 <node_behave+0xcae>
    2040:	00 00       	nop
					_delay_ms(800);
					left_degrees(180);
    2042:	84 eb       	ldi	r24, 0xB4	; 180
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	0e 94 c2 06 	call	0xd84	; 0xd84 <left_degrees>
					servo1_mov(0);
    204a:	80 e0       	ldi	r24, 0x00	; 0
    204c:	90 e0       	ldi	r25, 0x00	; 0
    204e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    2052:	8f ef       	ldi	r24, 0xFF	; 255
    2054:	9f ef       	ldi	r25, 0xFF	; 255
    2056:	ac e2       	ldi	r26, 0x2C	; 44
    2058:	81 50       	subi	r24, 0x01	; 1
    205a:	90 40       	sbci	r25, 0x00	; 0
    205c:	a0 40       	sbci	r26, 0x00	; 0
    205e:	e1 f7       	brne	.-8      	; 0x2058 <node_behave+0xcc6>
    2060:	00 c0       	rjmp	.+0      	; 0x2062 <node_behave+0xcd0>
    2062:	00 00       	nop
					_delay_ms(1000);
					color_identified='\0';
    2064:	10 92 42 02 	sts	0x0242, r1
					color_sensor();
    2068:	c0 e2       	ldi	r28, 0x20	; 32
    206a:	d5 e1       	ldi	r29, 0x15	; 21
    206c:	fe 01       	movw	r30, r28
    206e:	19 95       	eicall
					if(color_identified=='\0')
    2070:	80 91 42 02 	lds	r24, 0x0242
    2074:	88 23       	and	r24, r24
    2076:	c1 f4       	brne	.+48     	; 0x20a8 <node_behave+0xd16>
					{
						servo2_mov(45);
    2078:	8d e2       	ldi	r24, 0x2D	; 45
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
						distance('f',2,'o');
    2080:	86 e6       	ldi	r24, 0x66	; 102
    2082:	40 e0       	ldi	r20, 0x00	; 0
    2084:	50 e0       	ldi	r21, 0x00	; 0
    2086:	60 e0       	ldi	r22, 0x00	; 0
    2088:	70 e4       	ldi	r23, 0x40	; 64
    208a:	2f e6       	ldi	r18, 0x6F	; 111
    208c:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
						color_sensor();
    2090:	fe 01       	movw	r30, r28
    2092:	19 95       	eicall
						distance('b',2,'o');
    2094:	82 e6       	ldi	r24, 0x62	; 98
    2096:	40 e0       	ldi	r20, 0x00	; 0
    2098:	50 e0       	ldi	r21, 0x00	; 0
    209a:	60 e0       	ldi	r22, 0x00	; 0
    209c:	70 e4       	ldi	r23, 0x40	; 64
    209e:	2f e6       	ldi	r18, 0x6F	; 111
    20a0:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
						pick_waste();
    20a4:	0e 94 71 08 	call	0x10e2	; 0x10e2 <pick_waste>
					}
					color[color_index]=color_identified;
    20a8:	e0 91 40 02 	lds	r30, 0x0240
    20ac:	f0 91 41 02 	lds	r31, 0x0241
    20b0:	eb 5e       	subi	r30, 0xEB	; 235
    20b2:	fa 4f       	sbci	r31, 0xFA	; 250
    20b4:	80 91 42 02 	lds	r24, 0x0242
    20b8:	80 83       	st	Z, r24
					servo1_mov(80);
    20ba:	80 e5       	ldi	r24, 0x50	; 80
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    20c2:	cb e8       	ldi	r28, 0x8B	; 139
    20c4:	d2 e0       	ldi	r29, 0x02	; 2
    20c6:	0f e0       	ldi	r16, 0x0F	; 15
    20c8:	10 e0       	ldi	r17, 0x00	; 0
					int a=0;             //summing variable
    20ca:	cc 24       	eor	r12, r12
    20cc:	dd 24       	eor	r13, r13
					for(i=0;i<4;i++)
					{
						if(color[color_index]==color_deposited[i])
    20ce:	0f 2e       	mov	r0, r31
    20d0:	f5 e1       	ldi	r31, 0x15	; 21
    20d2:	af 2e       	mov	r10, r31
    20d4:	f5 e0       	ldi	r31, 0x05	; 5
    20d6:	bf 2e       	mov	r11, r31
    20d8:	f0 2d       	mov	r31, r0
							             
* Example Call:				node_behave(); 
*
*/

void node_behave(void) 
    20da:	7e 01       	movw	r14, r28
					color[color_index]=color_identified;
					servo1_mov(80);
					int a=0;             //summing variable
					for(i=0;i<4;i++)
					{
						if(color[color_index]==color_deposited[i])
    20dc:	80 91 40 02 	lds	r24, 0x0240
    20e0:	90 91 41 02 	lds	r25, 0x0241
    20e4:	8a 0d       	add	r24, r10
    20e6:	9b 1d       	adc	r25, r11
    20e8:	dc 01       	movw	r26, r24
    20ea:	9c 91       	ld	r25, X
    20ec:	88 81       	ld	r24, Y
    20ee:	98 17       	cp	r25, r24
    20f0:	61 f4       	brne	.+24     	; 0x210a <node_behave+0xd78>
						{
							color_found++;
    20f2:	80 91 49 02 	lds	r24, 0x0249
    20f6:	90 91 4a 02 	lds	r25, 0x024A
    20fa:	01 96       	adiw	r24, 0x01	; 1
    20fc:	90 93 4a 02 	sts	0x024A, r25
    2100:	80 93 49 02 	sts	0x0249, r24
							path_find(15+i);
    2104:	c8 01       	movw	r24, r16
    2106:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    210a:	21 96       	adiw	r28, 0x01	; 1
						}
						if(color_deposited[i]!='\0')
    210c:	f7 01       	movw	r30, r14
    210e:	80 81       	ld	r24, Z
    2110:	88 23       	and	r24, r24
    2112:	19 f0       	breq	.+6      	; 0x211a <node_behave+0xd88>
						a++;
    2114:	08 94       	sec
    2116:	c1 1c       	adc	r12, r1
    2118:	d1 1c       	adc	r13, r1
    211a:	0f 5f       	subi	r16, 0xFF	; 255
    211c:	1f 4f       	sbci	r17, 0xFF	; 255
						pick_waste();
					}
					color[color_index]=color_identified;
					servo1_mov(80);
					int a=0;             //summing variable
					for(i=0;i<4;i++)
    211e:	03 31       	cpi	r16, 0x13	; 19
    2120:	11 05       	cpc	r17, r1
    2122:	d9 f6       	brne	.-74     	; 0x20da <node_behave+0xd48>
							path_find(15+i);
						}
						if(color_deposited[i]!='\0')
						a++;
					}
					if(a>2)
    2124:	f3 e0       	ldi	r31, 0x03	; 3
    2126:	cf 16       	cp	r12, r31
    2128:	d1 04       	cpc	r13, r1
    212a:	4c f0       	brlt	.+18     	; 0x213e <node_behave+0xdac>
					color_found++;
    212c:	80 91 49 02 	lds	r24, 0x0249
    2130:	90 91 4a 02 	lds	r25, 0x024A
    2134:	01 96       	adiw	r24, 0x01	; 1
    2136:	90 93 4a 02 	sts	0x024A, r25
    213a:	80 93 49 02 	sts	0x0249, r24
					if(path[path_index]=='\0')
    213e:	e0 91 47 02 	lds	r30, 0x0247
    2142:	f0 91 48 02 	lds	r31, 0x0248
    2146:	e9 5a       	subi	r30, 0xA9	; 169
    2148:	fd 4f       	sbci	r31, 0xFD	; 253
    214a:	80 81       	ld	r24, Z
    214c:	88 23       	and	r24, r24
    214e:	79 f5       	brne	.+94     	; 0x21ae <node_behave+0xe1c>
					{
						if(deposition_zone_B==1 && color_deposited[1]=='\0')
    2150:	80 91 26 02 	lds	r24, 0x0226
    2154:	90 91 27 02 	lds	r25, 0x0227
    2158:	81 30       	cpi	r24, 0x01	; 1
    215a:	91 05       	cpc	r25, r1
    215c:	49 f4       	brne	.+18     	; 0x2170 <node_behave+0xdde>
    215e:	80 91 8c 02 	lds	r24, 0x028C
    2162:	88 23       	and	r24, r24
    2164:	29 f4       	brne	.+10     	; 0x2170 <node_behave+0xdde>
						path_find(16);
    2166:	80 e1       	ldi	r24, 0x10	; 16
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    216e:	1f c0       	rjmp	.+62     	; 0x21ae <node_behave+0xe1c>
						else if(deposition_zone_A==1 && color_deposited[0]=='\0')
    2170:	80 91 28 02 	lds	r24, 0x0228
    2174:	90 91 29 02 	lds	r25, 0x0229
    2178:	81 30       	cpi	r24, 0x01	; 1
    217a:	91 05       	cpc	r25, r1
    217c:	49 f4       	brne	.+18     	; 0x2190 <node_behave+0xdfe>
    217e:	80 91 8b 02 	lds	r24, 0x028B
    2182:	88 23       	and	r24, r24
    2184:	29 f4       	brne	.+10     	; 0x2190 <node_behave+0xdfe>
						path_find(15);
    2186:	8f e0       	ldi	r24, 0x0F	; 15
    2188:	90 e0       	ldi	r25, 0x00	; 0
    218a:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    218e:	0f c0       	rjmp	.+30     	; 0x21ae <node_behave+0xe1c>
						else if(deposition_zone_C==1 && color_deposited[2]=='\0')
    2190:	80 91 24 02 	lds	r24, 0x0224
    2194:	90 91 25 02 	lds	r25, 0x0225
    2198:	81 30       	cpi	r24, 0x01	; 1
    219a:	91 05       	cpc	r25, r1
    219c:	41 f4       	brne	.+16     	; 0x21ae <node_behave+0xe1c>
    219e:	80 91 8d 02 	lds	r24, 0x028D
    21a2:	88 23       	and	r24, r24
    21a4:	21 f4       	brne	.+8      	; 0x21ae <node_behave+0xe1c>
						path_find(17);
    21a6:	81 e1       	ldi	r24, 0x11	; 17
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
					}
					path_index++;
    21ae:	80 91 47 02 	lds	r24, 0x0247
    21b2:	90 91 48 02 	lds	r25, 0x0248
    21b6:	01 96       	adiw	r24, 0x01	; 1
    21b8:	90 93 48 02 	sts	0x0248, r25
    21bc:	80 93 47 02 	sts	0x0247, r24
					color_index++;
    21c0:	80 91 40 02 	lds	r24, 0x0240
    21c4:	90 91 41 02 	lds	r25, 0x0241
    21c8:	01 96       	adiw	r24, 0x01	; 1
    21ca:	90 93 41 02 	sts	0x0241, r25
    21ce:	80 93 40 02 	sts	0x0240, r24
				}
					IP--;
    21d2:	80 91 22 02 	lds	r24, 0x0222
    21d6:	90 91 23 02 	lds	r25, 0x0223
    21da:	01 97       	sbiw	r24, 0x01	; 1
    21dc:	90 93 23 02 	sts	0x0223, r25
    21e0:	80 93 22 02 	sts	0x0222, r24
    21e4:	65 c0       	rjmp	.+202    	; 0x22b0 <__stack+0xb1>
			}
			else
			{
				distance('f',2.5,'o');
    21e6:	86 e6       	ldi	r24, 0x66	; 102
    21e8:	40 e0       	ldi	r20, 0x00	; 0
    21ea:	50 e0       	ldi	r21, 0x00	; 0
    21ec:	60 e2       	ldi	r22, 0x20	; 32
    21ee:	70 e4       	ldi	r23, 0x40	; 64
    21f0:	2f e6       	ldi	r18, 0x6F	; 111
    21f2:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				servo2_mov(45);
    21f6:	8d e2       	ldi	r24, 0x2D	; 45
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    21fe:	8f ef       	ldi	r24, 0xFF	; 255
    2200:	9f ef       	ldi	r25, 0xFF	; 255
    2202:	a8 e0       	ldi	r26, 0x08	; 8
    2204:	81 50       	subi	r24, 0x01	; 1
    2206:	90 40       	sbci	r25, 0x00	; 0
    2208:	a0 40       	sbci	r26, 0x00	; 0
    220a:	e1 f7       	brne	.-8      	; 0x2204 <__stack+0x5>
    220c:	00 c0       	rjmp	.+0      	; 0x220e <__stack+0xf>
    220e:	00 00       	nop
				_delay_ms(200);
				color_found++;
    2210:	80 91 49 02 	lds	r24, 0x0249
    2214:	90 91 4a 02 	lds	r25, 0x024A
    2218:	01 96       	adiw	r24, 0x01	; 1
    221a:	90 93 4a 02 	sts	0x024A, r25
    221e:	80 93 49 02 	sts	0x0249, r24
				servo1_mov(5);
    2222:	85 e0       	ldi	r24, 0x05	; 5
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    222a:	8f ef       	ldi	r24, 0xFF	; 255
    222c:	9f ef       	ldi	r25, 0xFF	; 255
    222e:	a3 e2       	ldi	r26, 0x23	; 35
    2230:	81 50       	subi	r24, 0x01	; 1
    2232:	90 40       	sbci	r25, 0x00	; 0
    2234:	a0 40       	sbci	r26, 0x00	; 0
    2236:	e1 f7       	brne	.-8      	; 0x2230 <__stack+0x31>
    2238:	00 c0       	rjmp	.+0      	; 0x223a <__stack+0x3b>
    223a:	00 00       	nop
				_delay_ms(800);
				pick_waste();
    223c:	0e 94 71 08 	call	0x10e2	; 0x10e2 <pick_waste>
				servo1_mov(80);
    2240:	80 e5       	ldi	r24, 0x50	; 80
    2242:	90 e0       	ldi	r25, 0x00	; 0
    2244:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
				if(deposition_zone_B==1)
    2248:	80 91 26 02 	lds	r24, 0x0226
    224c:	90 91 27 02 	lds	r25, 0x0227
    2250:	81 30       	cpi	r24, 0x01	; 1
    2252:	91 05       	cpc	r25, r1
    2254:	29 f4       	brne	.+10     	; 0x2260 <__stack+0x61>
				path_find(16);
    2256:	80 e1       	ldi	r24, 0x10	; 16
    2258:	90 e0       	ldi	r25, 0x00	; 0
    225a:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    225e:	17 c0       	rjmp	.+46     	; 0x228e <__stack+0x8f>
				else if(deposition_zone_A==1)
    2260:	80 91 28 02 	lds	r24, 0x0228
    2264:	90 91 29 02 	lds	r25, 0x0229
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	91 05       	cpc	r25, r1
    226c:	29 f4       	brne	.+10     	; 0x2278 <__stack+0x79>
				path_find(15);
    226e:	8f e0       	ldi	r24, 0x0F	; 15
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    2276:	0b c0       	rjmp	.+22     	; 0x228e <__stack+0x8f>
				else if(deposition_zone_C==1)
    2278:	80 91 24 02 	lds	r24, 0x0224
    227c:	90 91 25 02 	lds	r25, 0x0225
    2280:	81 30       	cpi	r24, 0x01	; 1
    2282:	91 05       	cpc	r25, r1
    2284:	21 f4       	brne	.+8      	; 0x228e <__stack+0x8f>
				path_find(17);
    2286:	81 e1       	ldi	r24, 0x11	; 17
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
				color_index++;
    228e:	80 91 40 02 	lds	r24, 0x0240
    2292:	90 91 41 02 	lds	r25, 0x0241
    2296:	01 96       	adiw	r24, 0x01	; 1
    2298:	90 93 41 02 	sts	0x0241, r25
    229c:	80 93 40 02 	sts	0x0240, r24
				distance('f',3,'o');
    22a0:	86 e6       	ldi	r24, 0x66	; 102
    22a2:	40 e0       	ldi	r20, 0x00	; 0
    22a4:	50 e0       	ldi	r21, 0x00	; 0
    22a6:	60 e4       	ldi	r22, 0x40	; 64
    22a8:	70 e4       	ldi	r23, 0x40	; 64
    22aa:	2f e6       	ldi	r18, 0x6F	; 111
    22ac:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			}

		}
		if(node_number==4)
    22b0:	80 91 4d 02 	lds	r24, 0x024D
    22b4:	90 91 4e 02 	lds	r25, 0x024E
    22b8:	84 30       	cpi	r24, 0x04	; 4
    22ba:	91 05       	cpc	r25, r1
    22bc:	09 f0       	breq	.+2      	; 0x22c0 <__stack+0xc1>
    22be:	75 c0       	rjmp	.+234    	; 0x23aa <__stack+0x1ab>
		{
			distance('b',4,'o');
    22c0:	82 e6       	ldi	r24, 0x62	; 98
    22c2:	40 e0       	ldi	r20, 0x00	; 0
    22c4:	50 e0       	ldi	r21, 0x00	; 0
    22c6:	60 e8       	ldi	r22, 0x80	; 128
    22c8:	70 e4       	ldi	r23, 0x40	; 64
    22ca:	2f e6       	ldi	r18, 0x6F	; 111
    22cc:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			servo1_mov(66);
    22d0:	82 e4       	ldi	r24, 0x42	; 66
    22d2:	90 e0       	ldi	r25, 0x00	; 0
    22d4:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    22d8:	8f ef       	ldi	r24, 0xFF	; 255
    22da:	9f e7       	ldi	r25, 0x7F	; 127
    22dc:	af e1       	ldi	r26, 0x1F	; 31
    22de:	81 50       	subi	r24, 0x01	; 1
    22e0:	90 40       	sbci	r25, 0x00	; 0
    22e2:	a0 40       	sbci	r26, 0x00	; 0
    22e4:	e1 f7       	brne	.-8      	; 0x22de <__stack+0xdf>
    22e6:	00 c0       	rjmp	.+0      	; 0x22e8 <__stack+0xe9>
    22e8:	00 00       	nop
			_delay_ms(700);
			servo2_mov(45);
    22ea:	8d e2       	ldi	r24, 0x2D	; 45
    22ec:	90 e0       	ldi	r25, 0x00	; 0
    22ee:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    22f2:	8f ef       	ldi	r24, 0xFF	; 255
    22f4:	9f e7       	ldi	r25, 0x7F	; 127
    22f6:	a4 e0       	ldi	r26, 0x04	; 4
    22f8:	81 50       	subi	r24, 0x01	; 1
    22fa:	90 40       	sbci	r25, 0x00	; 0
    22fc:	a0 40       	sbci	r26, 0x00	; 0
    22fe:	e1 f7       	brne	.-8      	; 0x22f8 <__stack+0xf9>
    2300:	00 c0       	rjmp	.+0      	; 0x2302 <__stack+0x103>
    2302:	00 00       	nop
			_delay_ms(100);
			servo1_mov(80);
    2304:	80 e5       	ldi	r24, 0x50	; 80
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    230c:	8f ef       	ldi	r24, 0xFF	; 255
    230e:	9f ef       	ldi	r25, 0xFF	; 255
    2310:	ac e2       	ldi	r26, 0x2C	; 44
    2312:	81 50       	subi	r24, 0x01	; 1
    2314:	90 40       	sbci	r25, 0x00	; 0
    2316:	a0 40       	sbci	r26, 0x00	; 0
    2318:	e1 f7       	brne	.-8      	; 0x2312 <__stack+0x113>
    231a:	00 c0       	rjmp	.+0      	; 0x231c <__stack+0x11d>
    231c:	00 00       	nop
			_delay_ms(1000);
			if(sharp(digital[11])<300)
    231e:	80 91 30 05 	lds	r24, 0x0530
    2322:	90 91 31 05 	lds	r25, 0x0531
    2326:	0e 94 87 09 	call	0x130e	; 0x130e <sharp>
    232a:	a1 e0       	ldi	r26, 0x01	; 1
    232c:	8c 32       	cpi	r24, 0x2C	; 44
    232e:	9a 07       	cpc	r25, r26
    2330:	4c f4       	brge	.+18     	; 0x2344 <__stack+0x145>
			{
				bridge=Area;
    2332:	80 91 44 02 	lds	r24, 0x0244
    2336:	80 93 43 02 	sts	0x0243, r24
				path_find(6);
    233a:	86 e0       	ldi	r24, 0x06	; 6
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    2342:	12 c0       	rjmp	.+36     	; 0x2368 <__stack+0x169>
			}
			else
			{
				bridge='I';
    2344:	89 e4       	ldi	r24, 0x49	; 73
    2346:	80 93 43 02 	sts	0x0243, r24
				if(weight_block_position_2==0)
    234a:	80 91 1e 02 	lds	r24, 0x021E
    234e:	90 91 1f 02 	lds	r25, 0x021F
    2352:	00 97       	sbiw	r24, 0x00	; 0
    2354:	29 f4       	brne	.+10     	; 0x2360 <__stack+0x161>
				path_find(1);
    2356:	81 e0       	ldi	r24, 0x01	; 1
    2358:	90 e0       	ldi	r25, 0x00	; 0
    235a:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    235e:	04 c0       	rjmp	.+8      	; 0x2368 <__stack+0x169>
				else
				path_find(3);
    2360:	83 e0       	ldi	r24, 0x03	; 3
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
			}
			left();
    2368:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
			navigation_in_degrees=navigation_in_degrees+180;
    236c:	80 91 2a 02 	lds	r24, 0x022A
    2370:	90 91 2b 02 	lds	r25, 0x022B
    2374:	8c 54       	subi	r24, 0x4C	; 76
    2376:	9f 4f       	sbci	r25, 0xFF	; 255
    2378:	90 93 2b 02 	sts	0x022B, r25
    237c:	80 93 2a 02 	sts	0x022A, r24
			angle_rotate(180);
    2380:	84 eb       	ldi	r24, 0xB4	; 180
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
			path_index++;
    2388:	80 91 47 02 	lds	r24, 0x0247
    238c:	90 91 48 02 	lds	r25, 0x0248
    2390:	01 96       	adiw	r24, 0x01	; 1
    2392:	90 93 48 02 	sts	0x0248, r25
    2396:	80 93 47 02 	sts	0x0247, r24
			distance('b',5,'o');
    239a:	82 e6       	ldi	r24, 0x62	; 98
    239c:	40 e0       	ldi	r20, 0x00	; 0
    239e:	50 e0       	ldi	r21, 0x00	; 0
    23a0:	60 ea       	ldi	r22, 0xA0	; 160
    23a2:	70 e4       	ldi	r23, 0x40	; 64
    23a4:	2f e6       	ldi	r18, 0x6F	; 111
    23a6:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
		}
		if(node_number==14)
    23aa:	80 91 4d 02 	lds	r24, 0x024D
    23ae:	90 91 4e 02 	lds	r25, 0x024E
    23b2:	8e 30       	cpi	r24, 0x0E	; 14
    23b4:	91 05       	cpc	r25, r1
    23b6:	09 f0       	breq	.+2      	; 0x23ba <__stack+0x1bb>
    23b8:	74 c0       	rjmp	.+232    	; 0x24a2 <__stack+0x2a3>
		{
			distance('b',4,'o');
    23ba:	82 e6       	ldi	r24, 0x62	; 98
    23bc:	40 e0       	ldi	r20, 0x00	; 0
    23be:	50 e0       	ldi	r21, 0x00	; 0
    23c0:	60 e8       	ldi	r22, 0x80	; 128
    23c2:	70 e4       	ldi	r23, 0x40	; 64
    23c4:	2f e6       	ldi	r18, 0x6F	; 111
    23c6:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			servo1_mov(66);
    23ca:	82 e4       	ldi	r24, 0x42	; 66
    23cc:	90 e0       	ldi	r25, 0x00	; 0
    23ce:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    23d2:	8f ef       	ldi	r24, 0xFF	; 255
    23d4:	9f ef       	ldi	r25, 0xFF	; 255
    23d6:	ac e2       	ldi	r26, 0x2C	; 44
    23d8:	81 50       	subi	r24, 0x01	; 1
    23da:	90 40       	sbci	r25, 0x00	; 0
    23dc:	a0 40       	sbci	r26, 0x00	; 0
    23de:	e1 f7       	brne	.-8      	; 0x23d8 <__stack+0x1d9>
    23e0:	00 c0       	rjmp	.+0      	; 0x23e2 <__stack+0x1e3>
    23e2:	00 00       	nop
			_delay_ms(1000);
			servo2_mov(60);
    23e4:	8c e3       	ldi	r24, 0x3C	; 60
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    23ec:	8f ef       	ldi	r24, 0xFF	; 255
    23ee:	9f e7       	ldi	r25, 0x7F	; 127
    23f0:	a4 e0       	ldi	r26, 0x04	; 4
    23f2:	81 50       	subi	r24, 0x01	; 1
    23f4:	90 40       	sbci	r25, 0x00	; 0
    23f6:	a0 40       	sbci	r26, 0x00	; 0
    23f8:	e1 f7       	brne	.-8      	; 0x23f2 <__stack+0x1f3>
    23fa:	00 c0       	rjmp	.+0      	; 0x23fc <__stack+0x1fd>
    23fc:	00 00       	nop
			_delay_ms(100);
			servo1_mov(90);
    23fe:	8a e5       	ldi	r24, 0x5A	; 90
    2400:	90 e0       	ldi	r25, 0x00	; 0
    2402:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
    2406:	8f ef       	ldi	r24, 0xFF	; 255
    2408:	9f ef       	ldi	r25, 0xFF	; 255
    240a:	ac e2       	ldi	r26, 0x2C	; 44
    240c:	81 50       	subi	r24, 0x01	; 1
    240e:	90 40       	sbci	r25, 0x00	; 0
    2410:	a0 40       	sbci	r26, 0x00	; 0
    2412:	e1 f7       	brne	.-8      	; 0x240c <__stack+0x20d>
    2414:	00 c0       	rjmp	.+0      	; 0x2416 <__stack+0x217>
    2416:	00 00       	nop
			_delay_ms(1000);
			if(sharp(digital[11])<200)
    2418:	80 91 30 05 	lds	r24, 0x0530
    241c:	90 91 31 05 	lds	r25, 0x0531
    2420:	0e 94 87 09 	call	0x130e	; 0x130e <sharp>
    2424:	88 3c       	cpi	r24, 0xC8	; 200
    2426:	91 05       	cpc	r25, r1
    2428:	4c f4       	brge	.+18     	; 0x243c <__stack+0x23d>
			{
				bridge=Area;
    242a:	80 91 44 02 	lds	r24, 0x0244
    242e:	80 93 43 02 	sts	0x0243, r24
				path_find(0);
    2432:	80 e0       	ldi	r24, 0x00	; 0
    2434:	90 e0       	ldi	r25, 0x00	; 0
    2436:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    243a:	12 c0       	rjmp	.+36     	; 0x2460 <__stack+0x261>
			}
			else
			{
				bridge='C';
    243c:	83 e4       	ldi	r24, 0x43	; 67
    243e:	80 93 43 02 	sts	0x0243, r24
				if(weight_block_position_3!=0)
    2442:	80 91 1c 02 	lds	r24, 0x021C
    2446:	90 91 1d 02 	lds	r25, 0x021D
    244a:	00 97       	sbiw	r24, 0x00	; 0
    244c:	29 f0       	breq	.+10     	; 0x2458 <__stack+0x259>
				path_find(12);
    244e:	8c e0       	ldi	r24, 0x0C	; 12
    2450:	90 e0       	ldi	r25, 0x00	; 0
    2452:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    2456:	04 c0       	rjmp	.+8      	; 0x2460 <__stack+0x261>
				else
				path_find(13);
    2458:	8d e0       	ldi	r24, 0x0D	; 13
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
			}
			left();
    2460:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
			navigation_in_degrees=navigation_in_degrees+180;
    2464:	80 91 2a 02 	lds	r24, 0x022A
    2468:	90 91 2b 02 	lds	r25, 0x022B
    246c:	8c 54       	subi	r24, 0x4C	; 76
    246e:	9f 4f       	sbci	r25, 0xFF	; 255
    2470:	90 93 2b 02 	sts	0x022B, r25
    2474:	80 93 2a 02 	sts	0x022A, r24
			angle_rotate(180);
    2478:	84 eb       	ldi	r24, 0xB4	; 180
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <angle_rotate>
			path_index++;
    2480:	80 91 47 02 	lds	r24, 0x0247
    2484:	90 91 48 02 	lds	r25, 0x0248
    2488:	01 96       	adiw	r24, 0x01	; 1
    248a:	90 93 48 02 	sts	0x0248, r25
    248e:	80 93 47 02 	sts	0x0247, r24
			distance('b',5,'o');
    2492:	82 e6       	ldi	r24, 0x62	; 98
    2494:	40 e0       	ldi	r20, 0x00	; 0
    2496:	50 e0       	ldi	r21, 0x00	; 0
    2498:	60 ea       	ldi	r22, 0xA0	; 160
    249a:	70 e4       	ldi	r23, 0x40	; 64
    249c:	2f e6       	ldi	r18, 0x6F	; 111
    249e:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
		}
		if(node_number==0)
    24a2:	80 91 4d 02 	lds	r24, 0x024D
    24a6:	90 91 4e 02 	lds	r25, 0x024E
    24aa:	00 97       	sbiw	r24, 0x00	; 0
    24ac:	09 f0       	breq	.+2      	; 0x24b0 <__stack+0x2b1>
    24ae:	81 c0       	rjmp	.+258    	; 0x25b2 <__stack+0x3b3>
		{
			if(*navigation_pointer!='W')
    24b0:	e0 91 92 02 	lds	r30, 0x0292
    24b4:	f0 91 93 02 	lds	r31, 0x0293
    24b8:	80 81       	ld	r24, Z
    24ba:	87 35       	cpi	r24, 0x57	; 87
    24bc:	09 f4       	brne	.+2      	; 0x24c0 <__stack+0x2c1>
    24be:	52 c0       	rjmp	.+164    	; 0x2564 <__stack+0x365>
			{
				distance('f',11,'o');
    24c0:	86 e6       	ldi	r24, 0x66	; 102
    24c2:	40 e0       	ldi	r20, 0x00	; 0
    24c4:	50 e0       	ldi	r21, 0x00	; 0
    24c6:	60 e3       	ldi	r22, 0x30	; 48
    24c8:	71 e4       	ldi	r23, 0x41	; 65
    24ca:	2f e6       	ldi	r18, 0x6F	; 111
    24cc:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    24d0:	e0 91 92 02 	lds	r30, 0x0292
    24d4:	f0 91 93 02 	lds	r31, 0x0293
    24d8:	20 81       	ld	r18, Z
    24da:	2e 34       	cpi	r18, 0x4E	; 78
    24dc:	21 f0       	breq	.+8      	; 0x24e6 <__stack+0x2e7>
    24de:	2b 35       	cpi	r18, 0x5B	; 91
    24e0:	11 f0       	breq	.+4      	; 0x24e6 <__stack+0x2e7>
    24e2:	25 36       	cpi	r18, 0x65	; 101
    24e4:	61 f4       	brne	.+24     	; 0x24fe <__stack+0x2ff>
				while(*navigation_pointer!='W')
				left_degrees(90);
    24e6:	8a e5       	ldi	r24, 0x5A	; 90
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	0e 94 c2 06 	call	0xd84	; 0xd84 <left_degrees>
		{
			if(*navigation_pointer!='W')
			{
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
    24ee:	e0 91 92 02 	lds	r30, 0x0292
    24f2:	f0 91 93 02 	lds	r31, 0x0293
    24f6:	80 81       	ld	r24, Z
    24f8:	87 35       	cpi	r24, 0x57	; 87
    24fa:	a9 f7       	brne	.-22     	; 0x24e6 <__stack+0x2e7>
    24fc:	2b c0       	rjmp	.+86     	; 0x2554 <__stack+0x355>
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
    24fe:	82 2f       	mov	r24, r18
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	87 55       	subi	r24, 0x57	; 87
    2504:	90 40       	sbci	r25, 0x00	; 0
    2506:	1a f4       	brpl	.+6      	; 0x250e <__stack+0x30f>
    2508:	90 95       	com	r25
    250a:	81 95       	neg	r24
    250c:	9f 4f       	sbci	r25, 0xFF	; 255
    250e:	85 30       	cpi	r24, 0x05	; 5
    2510:	91 05       	cpc	r25, r1
    2512:	19 f4       	brne	.+6      	; 0x251a <__stack+0x31b>
				while(*navigation_pointer!='W')
    2514:	27 35       	cpi	r18, 0x57	; 87
    2516:	39 f4       	brne	.+14     	; 0x2526 <__stack+0x327>
    2518:	1d c0       	rjmp	.+58     	; 0x2554 <__stack+0x355>
			{
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
    251a:	82 31       	cpi	r24, 0x12	; 18
    251c:	91 05       	cpc	r25, r1
    251e:	d1 f3       	breq	.-12     	; 0x2514 <__stack+0x315>
				while(*navigation_pointer!='W')
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
    2520:	27 35       	cpi	r18, 0x57	; 87
    2522:	69 f4       	brne	.+26     	; 0x253e <__stack+0x33f>
    2524:	17 c0       	rjmp	.+46     	; 0x2554 <__stack+0x355>
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
				right_degrees(180);
    2526:	84 eb       	ldi	r24, 0xB4	; 180
    2528:	90 e0       	ldi	r25, 0x00	; 0
    252a:	0e 94 29 07 	call	0xe52	; 0xe52 <right_degrees>
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
    252e:	e0 91 92 02 	lds	r30, 0x0292
    2532:	f0 91 93 02 	lds	r31, 0x0293
    2536:	80 81       	ld	r24, Z
    2538:	87 35       	cpi	r24, 0x57	; 87
    253a:	a9 f7       	brne	.-22     	; 0x2526 <__stack+0x327>
    253c:	0b c0       	rjmp	.+22     	; 0x2554 <__stack+0x355>
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
				right_degrees(90);
    253e:	8a e5       	ldi	r24, 0x5A	; 90
    2540:	90 e0       	ldi	r25, 0x00	; 0
    2542:	0e 94 29 07 	call	0xe52	; 0xe52 <right_degrees>
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
    2546:	e0 91 92 02 	lds	r30, 0x0292
    254a:	f0 91 93 02 	lds	r31, 0x0293
    254e:	80 81       	ld	r24, Z
    2550:	87 35       	cpi	r24, 0x57	; 87
    2552:	a9 f7       	brne	.-22     	; 0x253e <__stack+0x33f>
				right_degrees(90);
				distance('b',11,'o');
    2554:	82 e6       	ldi	r24, 0x62	; 98
    2556:	40 e0       	ldi	r20, 0x00	; 0
    2558:	50 e0       	ldi	r21, 0x00	; 0
    255a:	60 e3       	ldi	r22, 0x30	; 48
    255c:	71 e4       	ldi	r23, 0x41	; 65
    255e:	2f e6       	ldi	r18, 0x6F	; 111
    2560:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			}
			if(sharp(digital[11])<400)
    2564:	80 91 30 05 	lds	r24, 0x0530
    2568:	90 91 31 05 	lds	r25, 0x0531
    256c:	0e 94 87 09 	call	0x130e	; 0x130e <sharp>
    2570:	a1 e0       	ldi	r26, 0x01	; 1
    2572:	80 39       	cpi	r24, 0x90	; 144
    2574:	9a 07       	cpc	r25, r26
    2576:	4c f4       	brge	.+18     	; 0x258a <__stack+0x38b>
			{
				bridge=Area;
    2578:	80 91 44 02 	lds	r24, 0x0244
    257c:	80 93 43 02 	sts	0x0243, r24
				path_find(6);
    2580:	86 e0       	ldi	r24, 0x06	; 6
    2582:	90 e0       	ldi	r25, 0x00	; 0
    2584:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    2588:	12 c0       	rjmp	.+36     	; 0x25ae <__stack+0x3af>
			}
			else
			{
				bridge='I';
    258a:	89 e4       	ldi	r24, 0x49	; 73
    258c:	80 93 43 02 	sts	0x0243, r24
				if(weight_block_position_2==0)
    2590:	80 91 1e 02 	lds	r24, 0x021E
    2594:	90 91 1f 02 	lds	r25, 0x021F
    2598:	00 97       	sbiw	r24, 0x00	; 0
    259a:	29 f4       	brne	.+10     	; 0x25a6 <__stack+0x3a7>
				enq_end(1);
    259c:	81 e0       	ldi	r24, 0x01	; 1
    259e:	90 e0       	ldi	r25, 0x00	; 0
    25a0:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
    25a4:	04 c0       	rjmp	.+8      	; 0x25ae <__stack+0x3af>
				else
				enq_end(3);
    25a6:	83 e0       	ldi	r24, 0x03	; 3
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
			}
			navigate();
    25ae:	0e 94 02 01 	call	0x204	; 0x204 <navigate>
		}
		if(node_number==10)
    25b2:	80 91 4d 02 	lds	r24, 0x024D
    25b6:	90 91 4e 02 	lds	r25, 0x024E
    25ba:	8a 30       	cpi	r24, 0x0A	; 10
    25bc:	91 05       	cpc	r25, r1
    25be:	09 f0       	breq	.+2      	; 0x25c2 <__stack+0x3c3>
    25c0:	7f c0       	rjmp	.+254    	; 0x26c0 <__stack+0x4c1>
		{
			if(*navigation_pointer!='E')
    25c2:	e0 91 92 02 	lds	r30, 0x0292
    25c6:	f0 91 93 02 	lds	r31, 0x0293
    25ca:	80 81       	ld	r24, Z
    25cc:	85 34       	cpi	r24, 0x45	; 69
    25ce:	09 f4       	brne	.+2      	; 0x25d2 <__stack+0x3d3>
    25d0:	52 c0       	rjmp	.+164    	; 0x2676 <__stack+0x477>
			{
				distance('f',11,'o');
    25d2:	86 e6       	ldi	r24, 0x66	; 102
    25d4:	40 e0       	ldi	r20, 0x00	; 0
    25d6:	50 e0       	ldi	r21, 0x00	; 0
    25d8:	60 e3       	ldi	r22, 0x30	; 48
    25da:	71 e4       	ldi	r23, 0x41	; 65
    25dc:	2f e6       	ldi	r18, 0x6F	; 111
    25de:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    25e2:	e0 91 92 02 	lds	r30, 0x0292
    25e6:	f0 91 93 02 	lds	r31, 0x0293
    25ea:	20 81       	ld	r18, Z
    25ec:	2c 33       	cpi	r18, 0x3C	; 60
    25ee:	21 f0       	breq	.+8      	; 0x25f8 <__stack+0x3f9>
    25f0:	29 34       	cpi	r18, 0x49	; 73
    25f2:	11 f0       	breq	.+4      	; 0x25f8 <__stack+0x3f9>
    25f4:	23 35       	cpi	r18, 0x53	; 83
    25f6:	61 f4       	brne	.+24     	; 0x2610 <__stack+0x411>
				while(*navigation_pointer!='E')
				left_degrees(90);
    25f8:	8a e5       	ldi	r24, 0x5A	; 90
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	0e 94 c2 06 	call	0xd84	; 0xd84 <left_degrees>
		{
			if(*navigation_pointer!='E')
			{
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
    2600:	e0 91 92 02 	lds	r30, 0x0292
    2604:	f0 91 93 02 	lds	r31, 0x0293
    2608:	80 81       	ld	r24, Z
    260a:	85 34       	cpi	r24, 0x45	; 69
    260c:	a9 f7       	brne	.-22     	; 0x25f8 <__stack+0x3f9>
    260e:	2b c0       	rjmp	.+86     	; 0x2666 <__stack+0x467>
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
    2610:	82 2f       	mov	r24, r18
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	85 54       	subi	r24, 0x45	; 69
    2616:	90 40       	sbci	r25, 0x00	; 0
    2618:	1a f4       	brpl	.+6      	; 0x2620 <__stack+0x421>
    261a:	90 95       	com	r25
    261c:	81 95       	neg	r24
    261e:	9f 4f       	sbci	r25, 0xFF	; 255
    2620:	85 30       	cpi	r24, 0x05	; 5
    2622:	91 05       	cpc	r25, r1
    2624:	19 f4       	brne	.+6      	; 0x262c <__stack+0x42d>
				while(*navigation_pointer!='E')
    2626:	25 34       	cpi	r18, 0x45	; 69
    2628:	39 f4       	brne	.+14     	; 0x2638 <__stack+0x439>
    262a:	1d c0       	rjmp	.+58     	; 0x2666 <__stack+0x467>
			{
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
    262c:	82 31       	cpi	r24, 0x12	; 18
    262e:	91 05       	cpc	r25, r1
    2630:	d1 f3       	breq	.-12     	; 0x2626 <__stack+0x427>
				while(*navigation_pointer!='E')
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
    2632:	25 34       	cpi	r18, 0x45	; 69
    2634:	69 f4       	brne	.+26     	; 0x2650 <__stack+0x451>
    2636:	17 c0       	rjmp	.+46     	; 0x2666 <__stack+0x467>
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
				right_degrees(180);
    2638:	84 eb       	ldi	r24, 0xB4	; 180
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	0e 94 29 07 	call	0xe52	; 0xe52 <right_degrees>
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
    2640:	e0 91 92 02 	lds	r30, 0x0292
    2644:	f0 91 93 02 	lds	r31, 0x0293
    2648:	80 81       	ld	r24, Z
    264a:	85 34       	cpi	r24, 0x45	; 69
    264c:	a9 f7       	brne	.-22     	; 0x2638 <__stack+0x439>
    264e:	0b c0       	rjmp	.+22     	; 0x2666 <__stack+0x467>
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
				right_degrees(90);
    2650:	8a e5       	ldi	r24, 0x5A	; 90
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	0e 94 29 07 	call	0xe52	; 0xe52 <right_degrees>
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
    2658:	e0 91 92 02 	lds	r30, 0x0292
    265c:	f0 91 93 02 	lds	r31, 0x0293
    2660:	80 81       	ld	r24, Z
    2662:	85 34       	cpi	r24, 0x45	; 69
    2664:	a9 f7       	brne	.-22     	; 0x2650 <__stack+0x451>
				right_degrees(90);
				distance('b',12,'o');
    2666:	82 e6       	ldi	r24, 0x62	; 98
    2668:	40 e0       	ldi	r20, 0x00	; 0
    266a:	50 e0       	ldi	r21, 0x00	; 0
    266c:	60 e4       	ldi	r22, 0x40	; 64
    266e:	71 e4       	ldi	r23, 0x41	; 65
    2670:	2f e6       	ldi	r18, 0x6F	; 111
    2672:	0e 94 b3 05 	call	0xb66	; 0xb66 <distance>
			}
			if(sharp(digital[11])<450)
    2676:	80 91 30 05 	lds	r24, 0x0530
    267a:	90 91 31 05 	lds	r25, 0x0531
    267e:	0e 94 87 09 	call	0x130e	; 0x130e <sharp>
    2682:	b1 e0       	ldi	r27, 0x01	; 1
    2684:	82 3c       	cpi	r24, 0xC2	; 194
    2686:	9b 07       	cpc	r25, r27
    2688:	4c f4       	brge	.+18     	; 0x269c <__stack+0x49d>
			{
				bridge=Area;
    268a:	80 91 44 02 	lds	r24, 0x0244
    268e:	80 93 43 02 	sts	0x0243, r24
				path_find(0);
    2692:	80 e0       	ldi	r24, 0x00	; 0
    2694:	90 e0       	ldi	r25, 0x00	; 0
    2696:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
    269a:	12 c0       	rjmp	.+36     	; 0x26c0 <__stack+0x4c1>
			}				
			else
			{
				bridge='C';
    269c:	83 e4       	ldi	r24, 0x43	; 67
    269e:	80 93 43 02 	sts	0x0243, r24
				if(weight_block_position_3!=0)
    26a2:	80 91 1c 02 	lds	r24, 0x021C
    26a6:	90 91 1d 02 	lds	r25, 0x021D
    26aa:	00 97       	sbiw	r24, 0x00	; 0
    26ac:	29 f0       	breq	.+10     	; 0x26b8 <__stack+0x4b9>
				enq_end(12);
    26ae:	8c e0       	ldi	r24, 0x0C	; 12
    26b0:	90 e0       	ldi	r25, 0x00	; 0
    26b2:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
    26b6:	04 c0       	rjmp	.+8      	; 0x26c0 <__stack+0x4c1>
				else
				enq_end(13);
    26b8:	8d e0       	ldi	r24, 0x0D	; 13
    26ba:	90 e0       	ldi	r25, 0x00	; 0
    26bc:	0e 94 01 05 	call	0xa02	; 0xa02 <enq_end>
			}
		}

		if(que_length!=0 && path[path_index]=='\0')
    26c0:	80 91 45 02 	lds	r24, 0x0245
    26c4:	90 91 46 02 	lds	r25, 0x0246
    26c8:	00 97       	sbiw	r24, 0x00	; 0
    26ca:	a1 f0       	breq	.+40     	; 0x26f4 <__stack+0x4f5>
    26cc:	e0 91 47 02 	lds	r30, 0x0247
    26d0:	f0 91 48 02 	lds	r31, 0x0248
    26d4:	e9 5a       	subi	r30, 0xA9	; 169
    26d6:	fd 4f       	sbci	r31, 0xFD	; 253
    26d8:	80 81       	ld	r24, Z
    26da:	88 23       	and	r24, r24
    26dc:	49 f5       	brne	.+82     	; 0x2730 <__stack+0x531>
		{
			path_find(end->num);
    26de:	e0 91 36 02 	lds	r30, 0x0236
    26e2:	f0 91 37 02 	lds	r31, 0x0237
    26e6:	84 81       	ldd	r24, Z+4	; 0x04
    26e8:	95 81       	ldd	r25, Z+5	; 0x05
    26ea:	0e 94 0c 04 	call	0x818	; 0x818 <path_find>
			dequeue();
    26ee:	0e 94 43 05 	call	0xa86	; 0xa86 <dequeue>
    26f2:	1e c0       	rjmp	.+60     	; 0x2730 <__stack+0x531>
		}
		else if(path[path_index]=='\0')
    26f4:	e0 91 47 02 	lds	r30, 0x0247
    26f8:	f0 91 48 02 	lds	r31, 0x0248
    26fc:	e9 5a       	subi	r30, 0xA9	; 169
    26fe:	fd 4f       	sbci	r31, 0xFD	; 253
    2700:	80 81       	ld	r24, Z
    2702:	88 23       	and	r24, r24
    2704:	a9 f4       	brne	.+42     	; 0x2730 <__stack+0x531>
		{
			buzzer(1);
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	90 e0       	ldi	r25, 0x00	; 0
    270a:	0e 94 60 05 	call	0xac0	; 0xac0 <buzzer>
    270e:	8f ef       	ldi	r24, 0xFF	; 255
    2710:	9f ef       	ldi	r25, 0xFF	; 255
    2712:	a9 e5       	ldi	r26, 0x59	; 89
    2714:	81 50       	subi	r24, 0x01	; 1
    2716:	90 40       	sbci	r25, 0x00	; 0
    2718:	a0 40       	sbci	r26, 0x00	; 0
    271a:	e1 f7       	brne	.-8      	; 0x2714 <__stack+0x515>
    271c:	00 c0       	rjmp	.+0      	; 0x271e <__stack+0x51f>
    271e:	00 00       	nop
			_delay_ms(2000);
			buzzer(0);
    2720:	80 e0       	ldi	r24, 0x00	; 0
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	0e 94 60 05 	call	0xac0	; 0xac0 <buzzer>
			exit(1);
    2728:	81 e0       	ldi	r24, 0x01	; 1
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	0e 94 66 1b 	call	0x36cc	; 0x36cc <_exit>
		}
	}
}
    2730:	df 91       	pop	r29
    2732:	cf 91       	pop	r28
    2734:	1f 91       	pop	r17
    2736:	0f 91       	pop	r16
    2738:	ff 90       	pop	r15
    273a:	ef 90       	pop	r14
    273c:	df 90       	pop	r13
    273e:	cf 90       	pop	r12
    2740:	bf 90       	pop	r11
    2742:	af 90       	pop	r10
    2744:	08 95       	ret

00002746 <__vector_35>:
* Example Call:								NONE
*
*/

ISR(TIMER3_OVF_vect) // Timer 3overflow interrupt to get digital value
{
    2746:	1f 92       	push	r1
    2748:	0f 92       	push	r0
    274a:	0f b6       	in	r0, 0x3f	; 63
    274c:	0f 92       	push	r0
    274e:	0b b6       	in	r0, 0x3b	; 59
    2750:	0f 92       	push	r0
    2752:	11 24       	eor	r1, r1
    2754:	2f 93       	push	r18
    2756:	3f 93       	push	r19
    2758:	4f 93       	push	r20
    275a:	5f 93       	push	r21
    275c:	6f 93       	push	r22
    275e:	7f 93       	push	r23
    2760:	8f 93       	push	r24
    2762:	9f 93       	push	r25
    2764:	af 93       	push	r26
    2766:	bf 93       	push	r27
    2768:	ef 93       	push	r30
    276a:	ff 93       	push	r31
	int i=0;
	for(i=1;i<4;i++)
	digital[i]=getdata(i);
    276c:	81 e0       	ldi	r24, 0x01	; 1
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	0e 94 9d 08 	call	0x113a	; 0x113a <getdata>
    2774:	28 2f       	mov	r18, r24
    2776:	39 2f       	mov	r19, r25
    2778:	30 93 1d 05 	sts	0x051D, r19
    277c:	20 93 1c 05 	sts	0x051C, r18
    2780:	82 e0       	ldi	r24, 0x02	; 2
    2782:	90 e0       	ldi	r25, 0x00	; 0
    2784:	0e 94 9d 08 	call	0x113a	; 0x113a <getdata>
    2788:	28 2f       	mov	r18, r24
    278a:	39 2f       	mov	r19, r25
    278c:	30 93 1f 05 	sts	0x051F, r19
    2790:	20 93 1e 05 	sts	0x051E, r18
    2794:	83 e0       	ldi	r24, 0x03	; 3
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	0e 94 9d 08 	call	0x113a	; 0x113a <getdata>
    279c:	28 2f       	mov	r18, r24
    279e:	39 2f       	mov	r19, r25
    27a0:	30 93 21 05 	sts	0x0521, r19
    27a4:	20 93 20 05 	sts	0x0520, r18
	digital[11]=getdata(11);
    27a8:	8b e0       	ldi	r24, 0x0B	; 11
    27aa:	90 e0       	ldi	r25, 0x00	; 0
    27ac:	0e 94 9d 08 	call	0x113a	; 0x113a <getdata>
    27b0:	28 2f       	mov	r18, r24
    27b2:	39 2f       	mov	r19, r25
    27b4:	30 93 31 05 	sts	0x0531, r19
    27b8:	20 93 30 05 	sts	0x0530, r18
	if(node_number<10)
    27bc:	80 91 4d 02 	lds	r24, 0x024D
    27c0:	90 91 4e 02 	lds	r25, 0x024E
    27c4:	8a 30       	cpi	r24, 0x0A	; 10
    27c6:	91 05       	cpc	r25, r1
    27c8:	24 f4       	brge	.+8      	; 0x27d2 <__vector_35+0x8c>
	Area='C';
    27ca:	83 e4       	ldi	r24, 0x43	; 67
    27cc:	80 93 44 02 	sts	0x0244, r24
    27d0:	03 c0       	rjmp	.+6      	; 0x27d8 <__vector_35+0x92>
	else
	Area='I';
    27d2:	89 e4       	ldi	r24, 0x49	; 73
    27d4:	80 93 44 02 	sts	0x0244, r24
}
    27d8:	ff 91       	pop	r31
    27da:	ef 91       	pop	r30
    27dc:	bf 91       	pop	r27
    27de:	af 91       	pop	r26
    27e0:	9f 91       	pop	r25
    27e2:	8f 91       	pop	r24
    27e4:	7f 91       	pop	r23
    27e6:	6f 91       	pop	r22
    27e8:	5f 91       	pop	r21
    27ea:	4f 91       	pop	r20
    27ec:	3f 91       	pop	r19
    27ee:	2f 91       	pop	r18
    27f0:	0f 90       	pop	r0
    27f2:	0b be       	out	0x3b, r0	; 59
    27f4:	0f 90       	pop	r0
    27f6:	0f be       	out	0x3f, r0	; 63
    27f8:	0f 90       	pop	r0
    27fa:	1f 90       	pop	r1
    27fc:	18 95       	reti

000027fe <line_following>:
*
*/

void line_following(void)
{
	if (digital[2]>60 || (digital[1]>15 && digital[2]>15))
    27fe:	80 91 1e 05 	lds	r24, 0x051E
    2802:	90 91 1f 05 	lds	r25, 0x051F
    2806:	8d 33       	cpi	r24, 0x3D	; 61
    2808:	91 05       	cpc	r25, r1
    280a:	70 f4       	brcc	.+28     	; 0x2828 <line_following+0x2a>
    280c:	80 91 1c 05 	lds	r24, 0x051C
    2810:	90 91 1d 05 	lds	r25, 0x051D
    2814:	80 31       	cpi	r24, 0x10	; 16
    2816:	91 05       	cpc	r25, r1
    2818:	60 f0       	brcs	.+24     	; 0x2832 <line_following+0x34>
    281a:	80 91 1e 05 	lds	r24, 0x051E
    281e:	90 91 1f 05 	lds	r25, 0x051F
    2822:	80 31       	cpi	r24, 0x10	; 16
    2824:	91 05       	cpc	r25, r1
    2826:	28 f0       	brcs	.+10     	; 0x2832 <line_following+0x34>
	{
		stop();
    2828:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
		node_behave();
    282c:	0e 94 c9 09 	call	0x1392	; 0x1392 <node_behave>
*/

void line_following(void)
{
	if (digital[2]>60 || (digital[1]>15 && digital[2]>15))
	{
    2830:	08 95       	ret
		stop();
		node_behave();
	}
	else if(digital[2]>15 && (digital[1]>15 || digital[3]>15))
    2832:	80 91 1e 05 	lds	r24, 0x051E
    2836:	90 91 1f 05 	lds	r25, 0x051F
    283a:	80 31       	cpi	r24, 0x10	; 16
    283c:	91 05       	cpc	r25, r1
    283e:	98 f0       	brcs	.+38     	; 0x2866 <line_following+0x68>
    2840:	80 91 1c 05 	lds	r24, 0x051C
    2844:	90 91 1d 05 	lds	r25, 0x051D
    2848:	80 31       	cpi	r24, 0x10	; 16
    284a:	91 05       	cpc	r25, r1
    284c:	38 f4       	brcc	.+14     	; 0x285c <line_following+0x5e>
    284e:	80 91 20 05 	lds	r24, 0x0520
    2852:	90 91 21 05 	lds	r25, 0x0521
    2856:	80 31       	cpi	r24, 0x10	; 16
    2858:	91 05       	cpc	r25, r1
    285a:	28 f0       	brcs	.+10     	; 0x2866 <line_following+0x68>
	{	stop();
    285c:	0e 94 39 06 	call	0xc72	; 0xc72 <stop>
		node_behave();
    2860:	0e 94 c9 09 	call	0x1392	; 0x1392 <node_behave>
	{
		stop();
		node_behave();
	}
	else if(digital[2]>15 && (digital[1]>15 || digital[3]>15))
	{	stop();
    2864:	08 95       	ret
		node_behave();
	}
	else if(digital[1]>15 && digital[3]<15)
    2866:	80 91 1c 05 	lds	r24, 0x051C
    286a:	90 91 1d 05 	lds	r25, 0x051D
    286e:	80 31       	cpi	r24, 0x10	; 16
    2870:	91 05       	cpc	r25, r1
    2872:	80 f0       	brcs	.+32     	; 0x2894 <line_following+0x96>
    2874:	80 91 20 05 	lds	r24, 0x0520
    2878:	90 91 21 05 	lds	r25, 0x0521
    287c:	8f 30       	cpi	r24, 0x0F	; 15
    287e:	91 05       	cpc	r25, r1
    2880:	48 f4       	brcc	.+18     	; 0x2894 <line_following+0x96>
	{
		sppeed(255,249);
    2882:	8f ef       	ldi	r24, 0xFF	; 255
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	69 ef       	ldi	r22, 0xF9	; 249
    2888:	70 e0       	ldi	r23, 0x00	; 0
    288a:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		right();
    288e:	0e 94 41 06 	call	0xc82	; 0xc82 <right>
    2892:	08 95       	ret
	}
	else if(digital[1]<15 && digital[3]>15)
    2894:	80 91 1c 05 	lds	r24, 0x051C
    2898:	90 91 1d 05 	lds	r25, 0x051D
    289c:	8f 30       	cpi	r24, 0x0F	; 15
    289e:	91 05       	cpc	r25, r1
    28a0:	80 f4       	brcc	.+32     	; 0x28c2 <line_following+0xc4>
    28a2:	80 91 20 05 	lds	r24, 0x0520
    28a6:	90 91 21 05 	lds	r25, 0x0521
    28aa:	80 31       	cpi	r24, 0x10	; 16
    28ac:	91 05       	cpc	r25, r1
    28ae:	48 f0       	brcs	.+18     	; 0x28c2 <line_following+0xc4>
	{
		sppeed(255,249);
    28b0:	8f ef       	ldi	r24, 0xFF	; 255
    28b2:	90 e0       	ldi	r25, 0x00	; 0
    28b4:	69 ef       	ldi	r22, 0xF9	; 249
    28b6:	70 e0       	ldi	r23, 0x00	; 0
    28b8:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		left();
    28bc:	0e 94 3d 06 	call	0xc7a	; 0xc7a <left>
    28c0:	08 95       	ret
	}
	else
	{
		sppeed(255,249);
    28c2:	8f ef       	ldi	r24, 0xFF	; 255
    28c4:	90 e0       	ldi	r25, 0x00	; 0
    28c6:	69 ef       	ldi	r22, 0xF9	; 249
    28c8:	70 e0       	ldi	r23, 0x00	; 0
    28ca:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		motion('f');
    28ce:	86 e6       	ldi	r24, 0x66	; 102
    28d0:	0e 94 74 05 	call	0xae8	; 0xae8 <motion>
    28d4:	08 95       	ret

000028d6 <color_sensor_pin_config>:
*
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
    28d6:	8a b1       	in	r24, 0x0a	; 10
    28d8:	8e 6f       	ori	r24, 0xFE	; 254
    28da:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
    28dc:	58 9a       	sbi	0x0b, 0	; 11
}
    28de:	08 95       	ret

000028e0 <clrport_init>:
*
*/

void clrport_init(void)
{
	color_sensor_pin_config();//color sensor pin configuration
    28e0:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <color_sensor_pin_config>
}
    28e4:	08 95       	ret

000028e6 <color_sensor_pin_interrupt_init>:
*
*/

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
    28e6:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
    28e8:	e9 e6       	ldi	r30, 0x69	; 105
    28ea:	f0 e0       	ldi	r31, 0x00	; 0
    28ec:	80 81       	ld	r24, Z
    28ee:	82 60       	ori	r24, 0x02	; 2
    28f0:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
    28f2:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
    28f4:	78 94       	sei
}
    28f6:	08 95       	ret

000028f8 <__vector_1>:
*
*/

//ISR for color sensor
ISR(INT0_vect)
{
    28f8:	1f 92       	push	r1
    28fa:	0f 92       	push	r0
    28fc:	0f b6       	in	r0, 0x3f	; 63
    28fe:	0f 92       	push	r0
    2900:	11 24       	eor	r1, r1
    2902:	8f 93       	push	r24
    2904:	9f 93       	push	r25
    2906:	af 93       	push	r26
    2908:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
    290a:	80 91 3c 02 	lds	r24, 0x023C
    290e:	90 91 3d 02 	lds	r25, 0x023D
    2912:	a0 91 3e 02 	lds	r26, 0x023E
    2916:	b0 91 3f 02 	lds	r27, 0x023F
    291a:	01 96       	adiw	r24, 0x01	; 1
    291c:	a1 1d       	adc	r26, r1
    291e:	b1 1d       	adc	r27, r1
    2920:	80 93 3c 02 	sts	0x023C, r24
    2924:	90 93 3d 02 	sts	0x023D, r25
    2928:	a0 93 3e 02 	sts	0x023E, r26
    292c:	b0 93 3f 02 	sts	0x023F, r27
}
    2930:	bf 91       	pop	r27
    2932:	af 91       	pop	r26
    2934:	9f 91       	pop	r25
    2936:	8f 91       	pop	r24
    2938:	0f 90       	pop	r0
    293a:	0f be       	out	0x3f, r0	; 63
    293c:	0f 90       	pop	r0
    293e:	1f 90       	pop	r1
    2940:	18 95       	reti

00002942 <init_devices>:
*
*/

void init_devices(void)
{
	cli(); //Clears the global interrupt
    2942:	f8 94       	cli
	clrport_init();  //Initializes all the ports
    2944:	0e 94 70 14 	call	0x28e0	; 0x28e0 <clrport_init>
	color_sensor_pin_interrupt_init();
    2948:	0e 94 73 14 	call	0x28e6	; 0x28e6 <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
    294c:	78 94       	sei
}
    294e:	08 95       	ret

00002950 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
    2950:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
    2952:	5f 98       	cbi	0x0b, 7	; 11
}
    2954:	08 95       	ret

00002956 <filter_green>:
*/

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
    2956:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    2958:	5f 9a       	sbi	0x0b, 7	; 11
}
    295a:	08 95       	ret

0000295c <filter_blue>:
*/

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
    295c:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    295e:	5f 9a       	sbi	0x0b, 7	; 11
}
    2960:	08 95       	ret

00002962 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from data sheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
    2962:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
    2964:	5d 9a       	sbi	0x0b, 5	; 11
}
    2966:	08 95       	ret

00002968 <red_read>:
*/

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    2968:	0e 94 a8 14 	call	0x2950	; 0x2950 <filter_red>
	pulse=0; //reset the count to 0
    296c:	10 92 3c 02 	sts	0x023C, r1
    2970:	10 92 3d 02 	sts	0x023D, r1
    2974:	10 92 3e 02 	sts	0x023E, r1
    2978:	10 92 3f 02 	sts	0x023F, r1
    297c:	8f ef       	ldi	r24, 0xFF	; 255
    297e:	9f e7       	ldi	r25, 0x7F	; 127
    2980:	a4 e0       	ldi	r26, 0x04	; 4
    2982:	81 50       	subi	r24, 0x01	; 1
    2984:	90 40       	sbci	r25, 0x00	; 0
    2986:	a0 40       	sbci	r26, 0x00	; 0
    2988:	e1 f7       	brne	.-8      	; 0x2982 <red_read+0x1a>
    298a:	00 c0       	rjmp	.+0      	; 0x298c <red_read+0x24>
    298c:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    298e:	80 91 3c 02 	lds	r24, 0x023C
    2992:	90 91 3d 02 	lds	r25, 0x023D
    2996:	a0 91 3e 02 	lds	r26, 0x023E
    299a:	b0 91 3f 02 	lds	r27, 0x023F
    299e:	80 93 9c 02 	sts	0x029C, r24
    29a2:	90 93 9d 02 	sts	0x029D, r25
    29a6:	a0 93 9e 02 	sts	0x029E, r26
    29aa:	b0 93 9f 02 	sts	0x029F, r27
}
    29ae:	08 95       	ret

000029b0 <green_read>:
*/

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    29b0:	0e 94 ab 14 	call	0x2956	; 0x2956 <filter_green>
	pulse=0; //reset the count to 0
    29b4:	10 92 3c 02 	sts	0x023C, r1
    29b8:	10 92 3d 02 	sts	0x023D, r1
    29bc:	10 92 3e 02 	sts	0x023E, r1
    29c0:	10 92 3f 02 	sts	0x023F, r1
    29c4:	8f ef       	ldi	r24, 0xFF	; 255
    29c6:	9f e7       	ldi	r25, 0x7F	; 127
    29c8:	a4 e0       	ldi	r26, 0x04	; 4
    29ca:	81 50       	subi	r24, 0x01	; 1
    29cc:	90 40       	sbci	r25, 0x00	; 0
    29ce:	a0 40       	sbci	r26, 0x00	; 0
    29d0:	e1 f7       	brne	.-8      	; 0x29ca <green_read+0x1a>
    29d2:	00 c0       	rjmp	.+0      	; 0x29d4 <green_read+0x24>
    29d4:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    29d6:	80 91 3c 02 	lds	r24, 0x023C
    29da:	90 91 3d 02 	lds	r25, 0x023D
    29de:	a0 91 3e 02 	lds	r26, 0x023E
    29e2:	b0 91 3f 02 	lds	r27, 0x023F
    29e6:	80 93 98 02 	sts	0x0298, r24
    29ea:	90 93 99 02 	sts	0x0299, r25
    29ee:	a0 93 9a 02 	sts	0x029A, r26
    29f2:	b0 93 9b 02 	sts	0x029B, r27
}
    29f6:	08 95       	ret

000029f8 <blue_read>:
*/

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    29f8:	0e 94 ae 14 	call	0x295c	; 0x295c <filter_blue>
	pulse=0; //reset the count to 0
    29fc:	10 92 3c 02 	sts	0x023C, r1
    2a00:	10 92 3d 02 	sts	0x023D, r1
    2a04:	10 92 3e 02 	sts	0x023E, r1
    2a08:	10 92 3f 02 	sts	0x023F, r1
    2a0c:	8f ef       	ldi	r24, 0xFF	; 255
    2a0e:	9f e7       	ldi	r25, 0x7F	; 127
    2a10:	a4 e0       	ldi	r26, 0x04	; 4
    2a12:	81 50       	subi	r24, 0x01	; 1
    2a14:	90 40       	sbci	r25, 0x00	; 0
    2a16:	a0 40       	sbci	r26, 0x00	; 0
    2a18:	e1 f7       	brne	.-8      	; 0x2a12 <blue_read+0x1a>
    2a1a:	00 c0       	rjmp	.+0      	; 0x2a1c <blue_read+0x24>
    2a1c:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    2a1e:	80 91 3c 02 	lds	r24, 0x023C
    2a22:	90 91 3d 02 	lds	r25, 0x023D
    2a26:	a0 91 3e 02 	lds	r26, 0x023E
    2a2a:	b0 91 3f 02 	lds	r27, 0x023F
    2a2e:	80 93 8e 02 	sts	0x028E, r24
    2a32:	90 93 8f 02 	sts	0x028F, r25
    2a36:	a0 93 90 02 	sts	0x0290, r26
    2a3a:	b0 93 91 02 	sts	0x0291, r27

}
    2a3e:	08 95       	ret

00002a40 <color_sensor>:
*
*/

void color_sensor(void)
{
	red_read();
    2a40:	0e 94 b4 14 	call	0x2968	; 0x2968 <red_read>
	blue_read();
    2a44:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <blue_read>
	green_read();
    2a48:	0e 94 d8 14 	call	0x29b0	; 0x29b0 <green_read>
	if(red<threshold_color_value && blue<threshold_color_value && green<threshold_color_value)
    2a4c:	80 91 9c 02 	lds	r24, 0x029C
    2a50:	90 91 9d 02 	lds	r25, 0x029D
    2a54:	a0 91 9e 02 	lds	r26, 0x029E
    2a58:	b0 91 9f 02 	lds	r27, 0x029F
    2a5c:	84 31       	cpi	r24, 0x14	; 20
    2a5e:	25 e0       	ldi	r18, 0x05	; 5
    2a60:	92 07       	cpc	r25, r18
    2a62:	20 e0       	ldi	r18, 0x00	; 0
    2a64:	a2 07       	cpc	r26, r18
    2a66:	20 e0       	ldi	r18, 0x00	; 0
    2a68:	b2 07       	cpc	r27, r18
    2a6a:	18 f5       	brcc	.+70     	; 0x2ab2 <color_sensor+0x72>
    2a6c:	80 91 8e 02 	lds	r24, 0x028E
    2a70:	90 91 8f 02 	lds	r25, 0x028F
    2a74:	a0 91 90 02 	lds	r26, 0x0290
    2a78:	b0 91 91 02 	lds	r27, 0x0291
    2a7c:	84 31       	cpi	r24, 0x14	; 20
    2a7e:	25 e0       	ldi	r18, 0x05	; 5
    2a80:	92 07       	cpc	r25, r18
    2a82:	20 e0       	ldi	r18, 0x00	; 0
    2a84:	a2 07       	cpc	r26, r18
    2a86:	20 e0       	ldi	r18, 0x00	; 0
    2a88:	b2 07       	cpc	r27, r18
    2a8a:	98 f4       	brcc	.+38     	; 0x2ab2 <color_sensor+0x72>
    2a8c:	80 91 98 02 	lds	r24, 0x0298
    2a90:	90 91 99 02 	lds	r25, 0x0299
    2a94:	a0 91 9a 02 	lds	r26, 0x029A
    2a98:	b0 91 9b 02 	lds	r27, 0x029B
    2a9c:	84 31       	cpi	r24, 0x14	; 20
    2a9e:	25 e0       	ldi	r18, 0x05	; 5
    2aa0:	92 07       	cpc	r25, r18
    2aa2:	20 e0       	ldi	r18, 0x00	; 0
    2aa4:	a2 07       	cpc	r26, r18
    2aa6:	20 e0       	ldi	r18, 0x00	; 0
    2aa8:	b2 07       	cpc	r27, r18
    2aaa:	18 f4       	brcc	.+6      	; 0x2ab2 <color_sensor+0x72>
	color_identified='\0';
    2aac:	10 92 42 02 	sts	0x0242, r1
    2ab0:	89 c0       	rjmp	.+274    	; 0x2bc4 <color_sensor+0x184>
	else
	{
		if(red>blue && red>green)
    2ab2:	40 91 9c 02 	lds	r20, 0x029C
    2ab6:	50 91 9d 02 	lds	r21, 0x029D
    2aba:	60 91 9e 02 	lds	r22, 0x029E
    2abe:	70 91 9f 02 	lds	r23, 0x029F
    2ac2:	80 91 8e 02 	lds	r24, 0x028E
    2ac6:	90 91 8f 02 	lds	r25, 0x028F
    2aca:	a0 91 90 02 	lds	r26, 0x0290
    2ace:	b0 91 91 02 	lds	r27, 0x0291
    2ad2:	84 17       	cp	r24, r20
    2ad4:	95 07       	cpc	r25, r21
    2ad6:	a6 07       	cpc	r26, r22
    2ad8:	b7 07       	cpc	r27, r23
    2ada:	c8 f4       	brcc	.+50     	; 0x2b0e <color_sensor+0xce>
    2adc:	40 91 9c 02 	lds	r20, 0x029C
    2ae0:	50 91 9d 02 	lds	r21, 0x029D
    2ae4:	60 91 9e 02 	lds	r22, 0x029E
    2ae8:	70 91 9f 02 	lds	r23, 0x029F
    2aec:	80 91 98 02 	lds	r24, 0x0298
    2af0:	90 91 99 02 	lds	r25, 0x0299
    2af4:	a0 91 9a 02 	lds	r26, 0x029A
    2af8:	b0 91 9b 02 	lds	r27, 0x029B
    2afc:	84 17       	cp	r24, r20
    2afe:	95 07       	cpc	r25, r21
    2b00:	a6 07       	cpc	r26, r22
    2b02:	b7 07       	cpc	r27, r23
    2b04:	20 f4       	brcc	.+8      	; 0x2b0e <color_sensor+0xce>
		color_identified='R';
    2b06:	82 e5       	ldi	r24, 0x52	; 82
    2b08:	80 93 42 02 	sts	0x0242, r24
    2b0c:	5b c0       	rjmp	.+182    	; 0x2bc4 <color_sensor+0x184>
		else if(blue>red && blue>green)
    2b0e:	40 91 8e 02 	lds	r20, 0x028E
    2b12:	50 91 8f 02 	lds	r21, 0x028F
    2b16:	60 91 90 02 	lds	r22, 0x0290
    2b1a:	70 91 91 02 	lds	r23, 0x0291
    2b1e:	80 91 9c 02 	lds	r24, 0x029C
    2b22:	90 91 9d 02 	lds	r25, 0x029D
    2b26:	a0 91 9e 02 	lds	r26, 0x029E
    2b2a:	b0 91 9f 02 	lds	r27, 0x029F
    2b2e:	84 17       	cp	r24, r20
    2b30:	95 07       	cpc	r25, r21
    2b32:	a6 07       	cpc	r26, r22
    2b34:	b7 07       	cpc	r27, r23
    2b36:	c8 f4       	brcc	.+50     	; 0x2b6a <color_sensor+0x12a>
    2b38:	40 91 8e 02 	lds	r20, 0x028E
    2b3c:	50 91 8f 02 	lds	r21, 0x028F
    2b40:	60 91 90 02 	lds	r22, 0x0290
    2b44:	70 91 91 02 	lds	r23, 0x0291
    2b48:	80 91 98 02 	lds	r24, 0x0298
    2b4c:	90 91 99 02 	lds	r25, 0x0299
    2b50:	a0 91 9a 02 	lds	r26, 0x029A
    2b54:	b0 91 9b 02 	lds	r27, 0x029B
    2b58:	84 17       	cp	r24, r20
    2b5a:	95 07       	cpc	r25, r21
    2b5c:	a6 07       	cpc	r26, r22
    2b5e:	b7 07       	cpc	r27, r23
    2b60:	20 f4       	brcc	.+8      	; 0x2b6a <color_sensor+0x12a>
		color_identified='B';
    2b62:	82 e4       	ldi	r24, 0x42	; 66
    2b64:	80 93 42 02 	sts	0x0242, r24
    2b68:	2d c0       	rjmp	.+90     	; 0x2bc4 <color_sensor+0x184>
		else if(green>red && green>blue)
    2b6a:	40 91 98 02 	lds	r20, 0x0298
    2b6e:	50 91 99 02 	lds	r21, 0x0299
    2b72:	60 91 9a 02 	lds	r22, 0x029A
    2b76:	70 91 9b 02 	lds	r23, 0x029B
    2b7a:	80 91 9c 02 	lds	r24, 0x029C
    2b7e:	90 91 9d 02 	lds	r25, 0x029D
    2b82:	a0 91 9e 02 	lds	r26, 0x029E
    2b86:	b0 91 9f 02 	lds	r27, 0x029F
    2b8a:	84 17       	cp	r24, r20
    2b8c:	95 07       	cpc	r25, r21
    2b8e:	a6 07       	cpc	r26, r22
    2b90:	b7 07       	cpc	r27, r23
    2b92:	c0 f4       	brcc	.+48     	; 0x2bc4 <color_sensor+0x184>
    2b94:	40 91 98 02 	lds	r20, 0x0298
    2b98:	50 91 99 02 	lds	r21, 0x0299
    2b9c:	60 91 9a 02 	lds	r22, 0x029A
    2ba0:	70 91 9b 02 	lds	r23, 0x029B
    2ba4:	80 91 8e 02 	lds	r24, 0x028E
    2ba8:	90 91 8f 02 	lds	r25, 0x028F
    2bac:	a0 91 90 02 	lds	r26, 0x0290
    2bb0:	b0 91 91 02 	lds	r27, 0x0291
    2bb4:	84 17       	cp	r24, r20
    2bb6:	95 07       	cpc	r25, r21
    2bb8:	a6 07       	cpc	r26, r22
    2bba:	b7 07       	cpc	r27, r23
    2bbc:	18 f4       	brcc	.+6      	; 0x2bc4 <color_sensor+0x184>
		color_identified='G';
    2bbe:	87 e4       	ldi	r24, 0x47	; 71
    2bc0:	80 93 42 02 	sts	0x0242, r24
	}
	lcd_cursor(2,10);
    2bc4:	82 e0       	ldi	r24, 0x02	; 2
    2bc6:	6a e0       	ldi	r22, 0x0A	; 10
    2bc8:	0e 94 7e 02 	call	0x4fc	; 0x4fc <lcd_cursor>
	lcd_wr_char(color_identified);
    2bcc:	80 91 42 02 	lds	r24, 0x0242
    2bd0:	0e 94 11 02 	call	0x422	; 0x422 <lcd_wr_char>
}
    2bd4:	08 95       	ret

00002bd6 <main>:
*
*/

int main(void)
{
	struct_config();
    2bd6:	0e 94 2b 03 	call	0x656	; 0x656 <struct_config>
	lcd_port_config();
    2bda:	0e 94 6b 05 	call	0xad6	; 0xad6 <lcd_port_config>
	lcd_init();
    2bde:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <lcd_init>
	INT_position();
    2be2:	0e 94 be 07 	call	0xf7c	; 0xf7c <INT_position>
	sppeed_config();
    2be6:	0e 94 8d 05 	call	0xb1a	; 0xb1a <sppeed_config>
	servo_config();
    2bea:	0e 94 cd 07 	call	0xf9a	; 0xf9a <servo_config>
	ADC_config();
    2bee:	0e 94 7f 08 	call	0x10fe	; 0x10fe <ADC_config>
	init_devices();
    2bf2:	0e 94 a1 14 	call	0x2942	; 0x2942 <init_devices>
	color_sensor_scaling();
    2bf6:	0e 94 b1 14 	call	0x2962	; 0x2962 <color_sensor_scaling>
	navigate();			//navigate the bot at starting
    2bfa:	0e 94 02 01 	call	0x204	; 0x204 <navigate>
	servo1_mov(80);		//move arm to its initial position
    2bfe:	80 e5       	ldi	r24, 0x50	; 80
    2c00:	90 e0       	ldi	r25, 0x00	; 0
    2c02:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <servo1_mov>
	servo2_mov(45);
    2c06:	8d e2       	ldi	r24, 0x2D	; 45
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	0e 94 3c 08 	call	0x1078	; 0x1078 <servo2_mov>
    2c0e:	8f ef       	ldi	r24, 0xFF	; 255
    2c10:	9f e7       	ldi	r25, 0x7F	; 127
    2c12:	a6 e1       	ldi	r26, 0x16	; 22
    2c14:	81 50       	subi	r24, 0x01	; 1
    2c16:	90 40       	sbci	r25, 0x00	; 0
    2c18:	a0 40       	sbci	r26, 0x00	; 0
    2c1a:	e1 f7       	brne	.-8      	; 0x2c14 <main+0x3e>
    2c1c:	00 c0       	rjmp	.+0      	; 0x2c1e <main+0x48>
    2c1e:	00 00       	nop
	_delay_ms(500);
	servo2_free();     // main 6 tasks of the bot
    2c20:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <servo2_free>
	while(1)				// Bot is instructed to follow line continuously 
	{
		line_following();
    2c24:	0e 94 ff 13 	call	0x27fe	; 0x27fe <line_following>
		if(deposition_zone_A+deposition_zone_B+deposition_zone_C==0)		// When all the three wastes are deposited at the deposition zone the bot																	  
    2c28:	80 91 28 02 	lds	r24, 0x0228
    2c2c:	90 91 29 02 	lds	r25, 0x0229
    2c30:	20 91 26 02 	lds	r18, 0x0226
    2c34:	30 91 27 02 	lds	r19, 0x0227
    2c38:	82 0f       	add	r24, r18
    2c3a:	93 1f       	adc	r25, r19
    2c3c:	20 91 24 02 	lds	r18, 0x0224
    2c40:	30 91 25 02 	lds	r19, 0x0225
    2c44:	82 0f       	add	r24, r18
    2c46:	93 1f       	adc	r25, r19
    2c48:	00 97       	sbiw	r24, 0x00	; 0
    2c4a:	61 f7       	brne	.-40     	; 0x2c24 <main+0x4e>
		{																	// will beep the buzzer for 5 sec and then exits from the program.
			buzzer(1);
    2c4c:	81 e0       	ldi	r24, 0x01	; 1
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	0e 94 60 05 	call	0xac0	; 0xac0 <buzzer>
    2c54:	8f ef       	ldi	r24, 0xFF	; 255
    2c56:	9f ef       	ldi	r25, 0xFF	; 255
    2c58:	a0 ee       	ldi	r26, 0xE0	; 224
    2c5a:	81 50       	subi	r24, 0x01	; 1
    2c5c:	90 40       	sbci	r25, 0x00	; 0
    2c5e:	a0 40       	sbci	r26, 0x00	; 0
    2c60:	e1 f7       	brne	.-8      	; 0x2c5a <main+0x84>
    2c62:	00 c0       	rjmp	.+0      	; 0x2c64 <main+0x8e>
    2c64:	00 00       	nop
			_delay_ms(5000);
			buzzer(0);
    2c66:	80 e0       	ldi	r24, 0x00	; 0
    2c68:	90 e0       	ldi	r25, 0x00	; 0
    2c6a:	0e 94 60 05 	call	0xac0	; 0xac0 <buzzer>
    2c6e:	8f ef       	ldi	r24, 0xFF	; 255
    2c70:	9f e7       	ldi	r25, 0x7F	; 127
    2c72:	a6 e1       	ldi	r26, 0x16	; 22
    2c74:	81 50       	subi	r24, 0x01	; 1
    2c76:	90 40       	sbci	r25, 0x00	; 0
    2c78:	a0 40       	sbci	r26, 0x00	; 0
    2c7a:	e1 f7       	brne	.-8      	; 0x2c74 <main+0x9e>
    2c7c:	00 c0       	rjmp	.+0      	; 0x2c7e <main+0xa8>
    2c7e:	00 00       	nop
			_delay_ms(500);
			break;
		}
	}	
}
    2c80:	80 e0       	ldi	r24, 0x00	; 0
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	08 95       	ret

00002c86 <__subsf3>:
    2c86:	50 58       	subi	r21, 0x80	; 128

00002c88 <__addsf3>:
    2c88:	bb 27       	eor	r27, r27
    2c8a:	aa 27       	eor	r26, r26
    2c8c:	0e d0       	rcall	.+28     	; 0x2caa <__addsf3x>
    2c8e:	b1 c1       	rjmp	.+866    	; 0x2ff2 <__fp_round>
    2c90:	a2 d1       	rcall	.+836    	; 0x2fd6 <__fp_pscA>
    2c92:	30 f0       	brcs	.+12     	; 0x2ca0 <__addsf3+0x18>
    2c94:	a7 d1       	rcall	.+846    	; 0x2fe4 <__fp_pscB>
    2c96:	20 f0       	brcs	.+8      	; 0x2ca0 <__addsf3+0x18>
    2c98:	31 f4       	brne	.+12     	; 0x2ca6 <__addsf3+0x1e>
    2c9a:	9f 3f       	cpi	r25, 0xFF	; 255
    2c9c:	11 f4       	brne	.+4      	; 0x2ca2 <__addsf3+0x1a>
    2c9e:	1e f4       	brtc	.+6      	; 0x2ca6 <__addsf3+0x1e>
    2ca0:	97 c1       	rjmp	.+814    	; 0x2fd0 <__fp_nan>
    2ca2:	0e f4       	brtc	.+2      	; 0x2ca6 <__addsf3+0x1e>
    2ca4:	e0 95       	com	r30
    2ca6:	e7 fb       	bst	r30, 7
    2ca8:	64 c1       	rjmp	.+712    	; 0x2f72 <__fp_inf>

00002caa <__addsf3x>:
    2caa:	e9 2f       	mov	r30, r25
    2cac:	b3 d1       	rcall	.+870    	; 0x3014 <__fp_split3>
    2cae:	80 f3       	brcs	.-32     	; 0x2c90 <__addsf3+0x8>
    2cb0:	ba 17       	cp	r27, r26
    2cb2:	62 07       	cpc	r22, r18
    2cb4:	73 07       	cpc	r23, r19
    2cb6:	84 07       	cpc	r24, r20
    2cb8:	95 07       	cpc	r25, r21
    2cba:	18 f0       	brcs	.+6      	; 0x2cc2 <__addsf3x+0x18>
    2cbc:	71 f4       	brne	.+28     	; 0x2cda <__addsf3x+0x30>
    2cbe:	9e f5       	brtc	.+102    	; 0x2d26 <__addsf3x+0x7c>
    2cc0:	e2 c1       	rjmp	.+964    	; 0x3086 <__fp_zero>
    2cc2:	0e f4       	brtc	.+2      	; 0x2cc6 <__addsf3x+0x1c>
    2cc4:	e0 95       	com	r30
    2cc6:	0b 2e       	mov	r0, r27
    2cc8:	ba 2f       	mov	r27, r26
    2cca:	a0 2d       	mov	r26, r0
    2ccc:	0b 01       	movw	r0, r22
    2cce:	b9 01       	movw	r22, r18
    2cd0:	90 01       	movw	r18, r0
    2cd2:	0c 01       	movw	r0, r24
    2cd4:	ca 01       	movw	r24, r20
    2cd6:	a0 01       	movw	r20, r0
    2cd8:	11 24       	eor	r1, r1
    2cda:	ff 27       	eor	r31, r31
    2cdc:	59 1b       	sub	r21, r25
    2cde:	99 f0       	breq	.+38     	; 0x2d06 <__addsf3x+0x5c>
    2ce0:	59 3f       	cpi	r21, 0xF9	; 249
    2ce2:	50 f4       	brcc	.+20     	; 0x2cf8 <__addsf3x+0x4e>
    2ce4:	50 3e       	cpi	r21, 0xE0	; 224
    2ce6:	68 f1       	brcs	.+90     	; 0x2d42 <__addsf3x+0x98>
    2ce8:	1a 16       	cp	r1, r26
    2cea:	f0 40       	sbci	r31, 0x00	; 0
    2cec:	a2 2f       	mov	r26, r18
    2cee:	23 2f       	mov	r18, r19
    2cf0:	34 2f       	mov	r19, r20
    2cf2:	44 27       	eor	r20, r20
    2cf4:	58 5f       	subi	r21, 0xF8	; 248
    2cf6:	f3 cf       	rjmp	.-26     	; 0x2cde <__addsf3x+0x34>
    2cf8:	46 95       	lsr	r20
    2cfa:	37 95       	ror	r19
    2cfc:	27 95       	ror	r18
    2cfe:	a7 95       	ror	r26
    2d00:	f0 40       	sbci	r31, 0x00	; 0
    2d02:	53 95       	inc	r21
    2d04:	c9 f7       	brne	.-14     	; 0x2cf8 <__addsf3x+0x4e>
    2d06:	7e f4       	brtc	.+30     	; 0x2d26 <__addsf3x+0x7c>
    2d08:	1f 16       	cp	r1, r31
    2d0a:	ba 0b       	sbc	r27, r26
    2d0c:	62 0b       	sbc	r22, r18
    2d0e:	73 0b       	sbc	r23, r19
    2d10:	84 0b       	sbc	r24, r20
    2d12:	ba f0       	brmi	.+46     	; 0x2d42 <__addsf3x+0x98>
    2d14:	91 50       	subi	r25, 0x01	; 1
    2d16:	a1 f0       	breq	.+40     	; 0x2d40 <__addsf3x+0x96>
    2d18:	ff 0f       	add	r31, r31
    2d1a:	bb 1f       	adc	r27, r27
    2d1c:	66 1f       	adc	r22, r22
    2d1e:	77 1f       	adc	r23, r23
    2d20:	88 1f       	adc	r24, r24
    2d22:	c2 f7       	brpl	.-16     	; 0x2d14 <__addsf3x+0x6a>
    2d24:	0e c0       	rjmp	.+28     	; 0x2d42 <__addsf3x+0x98>
    2d26:	ba 0f       	add	r27, r26
    2d28:	62 1f       	adc	r22, r18
    2d2a:	73 1f       	adc	r23, r19
    2d2c:	84 1f       	adc	r24, r20
    2d2e:	48 f4       	brcc	.+18     	; 0x2d42 <__addsf3x+0x98>
    2d30:	87 95       	ror	r24
    2d32:	77 95       	ror	r23
    2d34:	67 95       	ror	r22
    2d36:	b7 95       	ror	r27
    2d38:	f7 95       	ror	r31
    2d3a:	9e 3f       	cpi	r25, 0xFE	; 254
    2d3c:	08 f0       	brcs	.+2      	; 0x2d40 <__addsf3x+0x96>
    2d3e:	b3 cf       	rjmp	.-154    	; 0x2ca6 <__addsf3+0x1e>
    2d40:	93 95       	inc	r25
    2d42:	88 0f       	add	r24, r24
    2d44:	08 f0       	brcs	.+2      	; 0x2d48 <__addsf3x+0x9e>
    2d46:	99 27       	eor	r25, r25
    2d48:	ee 0f       	add	r30, r30
    2d4a:	97 95       	ror	r25
    2d4c:	87 95       	ror	r24
    2d4e:	08 95       	ret

00002d50 <ceil>:
    2d50:	83 d1       	rcall	.+774    	; 0x3058 <__fp_trunc>
    2d52:	80 f0       	brcs	.+32     	; 0x2d74 <ceil+0x24>
    2d54:	9f 37       	cpi	r25, 0x7F	; 127
    2d56:	40 f4       	brcc	.+16     	; 0x2d68 <ceil+0x18>
    2d58:	91 11       	cpse	r25, r1
    2d5a:	0e f4       	brtc	.+2      	; 0x2d5e <ceil+0xe>
    2d5c:	95 c1       	rjmp	.+810    	; 0x3088 <__fp_szero>
    2d5e:	60 e0       	ldi	r22, 0x00	; 0
    2d60:	70 e0       	ldi	r23, 0x00	; 0
    2d62:	80 e8       	ldi	r24, 0x80	; 128
    2d64:	9f e3       	ldi	r25, 0x3F	; 63
    2d66:	08 95       	ret
    2d68:	26 f0       	brts	.+8      	; 0x2d72 <ceil+0x22>
    2d6a:	1b 16       	cp	r1, r27
    2d6c:	61 1d       	adc	r22, r1
    2d6e:	71 1d       	adc	r23, r1
    2d70:	81 1d       	adc	r24, r1
    2d72:	05 c1       	rjmp	.+522    	; 0x2f7e <__fp_mintl>
    2d74:	1f c1       	rjmp	.+574    	; 0x2fb4 <__fp_mpack>

00002d76 <__cmpsf2>:
    2d76:	d9 d0       	rcall	.+434    	; 0x2f2a <__fp_cmp>
    2d78:	08 f4       	brcc	.+2      	; 0x2d7c <__cmpsf2+0x6>
    2d7a:	81 e0       	ldi	r24, 0x01	; 1
    2d7c:	08 95       	ret

00002d7e <__divsf3>:
    2d7e:	0c d0       	rcall	.+24     	; 0x2d98 <__divsf3x>
    2d80:	38 c1       	rjmp	.+624    	; 0x2ff2 <__fp_round>
    2d82:	30 d1       	rcall	.+608    	; 0x2fe4 <__fp_pscB>
    2d84:	40 f0       	brcs	.+16     	; 0x2d96 <__divsf3+0x18>
    2d86:	27 d1       	rcall	.+590    	; 0x2fd6 <__fp_pscA>
    2d88:	30 f0       	brcs	.+12     	; 0x2d96 <__divsf3+0x18>
    2d8a:	21 f4       	brne	.+8      	; 0x2d94 <__divsf3+0x16>
    2d8c:	5f 3f       	cpi	r21, 0xFF	; 255
    2d8e:	19 f0       	breq	.+6      	; 0x2d96 <__divsf3+0x18>
    2d90:	f0 c0       	rjmp	.+480    	; 0x2f72 <__fp_inf>
    2d92:	51 11       	cpse	r21, r1
    2d94:	79 c1       	rjmp	.+754    	; 0x3088 <__fp_szero>
    2d96:	1c c1       	rjmp	.+568    	; 0x2fd0 <__fp_nan>

00002d98 <__divsf3x>:
    2d98:	3d d1       	rcall	.+634    	; 0x3014 <__fp_split3>
    2d9a:	98 f3       	brcs	.-26     	; 0x2d82 <__divsf3+0x4>

00002d9c <__divsf3_pse>:
    2d9c:	99 23       	and	r25, r25
    2d9e:	c9 f3       	breq	.-14     	; 0x2d92 <__divsf3+0x14>
    2da0:	55 23       	and	r21, r21
    2da2:	b1 f3       	breq	.-20     	; 0x2d90 <__divsf3+0x12>
    2da4:	95 1b       	sub	r25, r21
    2da6:	55 0b       	sbc	r21, r21
    2da8:	bb 27       	eor	r27, r27
    2daa:	aa 27       	eor	r26, r26
    2dac:	62 17       	cp	r22, r18
    2dae:	73 07       	cpc	r23, r19
    2db0:	84 07       	cpc	r24, r20
    2db2:	38 f0       	brcs	.+14     	; 0x2dc2 <__divsf3_pse+0x26>
    2db4:	9f 5f       	subi	r25, 0xFF	; 255
    2db6:	5f 4f       	sbci	r21, 0xFF	; 255
    2db8:	22 0f       	add	r18, r18
    2dba:	33 1f       	adc	r19, r19
    2dbc:	44 1f       	adc	r20, r20
    2dbe:	aa 1f       	adc	r26, r26
    2dc0:	a9 f3       	breq	.-22     	; 0x2dac <__divsf3_pse+0x10>
    2dc2:	33 d0       	rcall	.+102    	; 0x2e2a <__divsf3_pse+0x8e>
    2dc4:	0e 2e       	mov	r0, r30
    2dc6:	3a f0       	brmi	.+14     	; 0x2dd6 <__divsf3_pse+0x3a>
    2dc8:	e0 e8       	ldi	r30, 0x80	; 128
    2dca:	30 d0       	rcall	.+96     	; 0x2e2c <__divsf3_pse+0x90>
    2dcc:	91 50       	subi	r25, 0x01	; 1
    2dce:	50 40       	sbci	r21, 0x00	; 0
    2dd0:	e6 95       	lsr	r30
    2dd2:	00 1c       	adc	r0, r0
    2dd4:	ca f7       	brpl	.-14     	; 0x2dc8 <__divsf3_pse+0x2c>
    2dd6:	29 d0       	rcall	.+82     	; 0x2e2a <__divsf3_pse+0x8e>
    2dd8:	fe 2f       	mov	r31, r30
    2dda:	27 d0       	rcall	.+78     	; 0x2e2a <__divsf3_pse+0x8e>
    2ddc:	66 0f       	add	r22, r22
    2dde:	77 1f       	adc	r23, r23
    2de0:	88 1f       	adc	r24, r24
    2de2:	bb 1f       	adc	r27, r27
    2de4:	26 17       	cp	r18, r22
    2de6:	37 07       	cpc	r19, r23
    2de8:	48 07       	cpc	r20, r24
    2dea:	ab 07       	cpc	r26, r27
    2dec:	b0 e8       	ldi	r27, 0x80	; 128
    2dee:	09 f0       	breq	.+2      	; 0x2df2 <__divsf3_pse+0x56>
    2df0:	bb 0b       	sbc	r27, r27
    2df2:	80 2d       	mov	r24, r0
    2df4:	bf 01       	movw	r22, r30
    2df6:	ff 27       	eor	r31, r31
    2df8:	93 58       	subi	r25, 0x83	; 131
    2dfa:	5f 4f       	sbci	r21, 0xFF	; 255
    2dfc:	2a f0       	brmi	.+10     	; 0x2e08 <__divsf3_pse+0x6c>
    2dfe:	9e 3f       	cpi	r25, 0xFE	; 254
    2e00:	51 05       	cpc	r21, r1
    2e02:	68 f0       	brcs	.+26     	; 0x2e1e <__divsf3_pse+0x82>
    2e04:	b6 c0       	rjmp	.+364    	; 0x2f72 <__fp_inf>
    2e06:	40 c1       	rjmp	.+640    	; 0x3088 <__fp_szero>
    2e08:	5f 3f       	cpi	r21, 0xFF	; 255
    2e0a:	ec f3       	brlt	.-6      	; 0x2e06 <__divsf3_pse+0x6a>
    2e0c:	98 3e       	cpi	r25, 0xE8	; 232
    2e0e:	dc f3       	brlt	.-10     	; 0x2e06 <__divsf3_pse+0x6a>
    2e10:	86 95       	lsr	r24
    2e12:	77 95       	ror	r23
    2e14:	67 95       	ror	r22
    2e16:	b7 95       	ror	r27
    2e18:	f7 95       	ror	r31
    2e1a:	9f 5f       	subi	r25, 0xFF	; 255
    2e1c:	c9 f7       	brne	.-14     	; 0x2e10 <__divsf3_pse+0x74>
    2e1e:	88 0f       	add	r24, r24
    2e20:	91 1d       	adc	r25, r1
    2e22:	96 95       	lsr	r25
    2e24:	87 95       	ror	r24
    2e26:	97 f9       	bld	r25, 7
    2e28:	08 95       	ret
    2e2a:	e1 e0       	ldi	r30, 0x01	; 1
    2e2c:	66 0f       	add	r22, r22
    2e2e:	77 1f       	adc	r23, r23
    2e30:	88 1f       	adc	r24, r24
    2e32:	bb 1f       	adc	r27, r27
    2e34:	62 17       	cp	r22, r18
    2e36:	73 07       	cpc	r23, r19
    2e38:	84 07       	cpc	r24, r20
    2e3a:	ba 07       	cpc	r27, r26
    2e3c:	20 f0       	brcs	.+8      	; 0x2e46 <__divsf3_pse+0xaa>
    2e3e:	62 1b       	sub	r22, r18
    2e40:	73 0b       	sbc	r23, r19
    2e42:	84 0b       	sbc	r24, r20
    2e44:	ba 0b       	sbc	r27, r26
    2e46:	ee 1f       	adc	r30, r30
    2e48:	88 f7       	brcc	.-30     	; 0x2e2c <__divsf3_pse+0x90>
    2e4a:	e0 95       	com	r30
    2e4c:	08 95       	ret

00002e4e <__fixsfsi>:
    2e4e:	04 d0       	rcall	.+8      	; 0x2e58 <__fixunssfsi>
    2e50:	68 94       	set
    2e52:	b1 11       	cpse	r27, r1
    2e54:	19 c1       	rjmp	.+562    	; 0x3088 <__fp_szero>
    2e56:	08 95       	ret

00002e58 <__fixunssfsi>:
    2e58:	e5 d0       	rcall	.+458    	; 0x3024 <__fp_splitA>
    2e5a:	88 f0       	brcs	.+34     	; 0x2e7e <__fixunssfsi+0x26>
    2e5c:	9f 57       	subi	r25, 0x7F	; 127
    2e5e:	90 f0       	brcs	.+36     	; 0x2e84 <__fixunssfsi+0x2c>
    2e60:	b9 2f       	mov	r27, r25
    2e62:	99 27       	eor	r25, r25
    2e64:	b7 51       	subi	r27, 0x17	; 23
    2e66:	a0 f0       	brcs	.+40     	; 0x2e90 <__fixunssfsi+0x38>
    2e68:	d1 f0       	breq	.+52     	; 0x2e9e <__fixunssfsi+0x46>
    2e6a:	66 0f       	add	r22, r22
    2e6c:	77 1f       	adc	r23, r23
    2e6e:	88 1f       	adc	r24, r24
    2e70:	99 1f       	adc	r25, r25
    2e72:	1a f0       	brmi	.+6      	; 0x2e7a <__fixunssfsi+0x22>
    2e74:	ba 95       	dec	r27
    2e76:	c9 f7       	brne	.-14     	; 0x2e6a <__fixunssfsi+0x12>
    2e78:	12 c0       	rjmp	.+36     	; 0x2e9e <__fixunssfsi+0x46>
    2e7a:	b1 30       	cpi	r27, 0x01	; 1
    2e7c:	81 f0       	breq	.+32     	; 0x2e9e <__fixunssfsi+0x46>
    2e7e:	03 d1       	rcall	.+518    	; 0x3086 <__fp_zero>
    2e80:	b1 e0       	ldi	r27, 0x01	; 1
    2e82:	08 95       	ret
    2e84:	00 c1       	rjmp	.+512    	; 0x3086 <__fp_zero>
    2e86:	67 2f       	mov	r22, r23
    2e88:	78 2f       	mov	r23, r24
    2e8a:	88 27       	eor	r24, r24
    2e8c:	b8 5f       	subi	r27, 0xF8	; 248
    2e8e:	39 f0       	breq	.+14     	; 0x2e9e <__fixunssfsi+0x46>
    2e90:	b9 3f       	cpi	r27, 0xF9	; 249
    2e92:	cc f3       	brlt	.-14     	; 0x2e86 <__fixunssfsi+0x2e>
    2e94:	86 95       	lsr	r24
    2e96:	77 95       	ror	r23
    2e98:	67 95       	ror	r22
    2e9a:	b3 95       	inc	r27
    2e9c:	d9 f7       	brne	.-10     	; 0x2e94 <__fixunssfsi+0x3c>
    2e9e:	3e f4       	brtc	.+14     	; 0x2eae <__fixunssfsi+0x56>
    2ea0:	90 95       	com	r25
    2ea2:	80 95       	com	r24
    2ea4:	70 95       	com	r23
    2ea6:	61 95       	neg	r22
    2ea8:	7f 4f       	sbci	r23, 0xFF	; 255
    2eaa:	8f 4f       	sbci	r24, 0xFF	; 255
    2eac:	9f 4f       	sbci	r25, 0xFF	; 255
    2eae:	08 95       	ret

00002eb0 <__floatunsisf>:
    2eb0:	e8 94       	clt
    2eb2:	09 c0       	rjmp	.+18     	; 0x2ec6 <__floatsisf+0x12>

00002eb4 <__floatsisf>:
    2eb4:	97 fb       	bst	r25, 7
    2eb6:	3e f4       	brtc	.+14     	; 0x2ec6 <__floatsisf+0x12>
    2eb8:	90 95       	com	r25
    2eba:	80 95       	com	r24
    2ebc:	70 95       	com	r23
    2ebe:	61 95       	neg	r22
    2ec0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec2:	8f 4f       	sbci	r24, 0xFF	; 255
    2ec4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ec6:	99 23       	and	r25, r25
    2ec8:	a9 f0       	breq	.+42     	; 0x2ef4 <__floatsisf+0x40>
    2eca:	f9 2f       	mov	r31, r25
    2ecc:	96 e9       	ldi	r25, 0x96	; 150
    2ece:	bb 27       	eor	r27, r27
    2ed0:	93 95       	inc	r25
    2ed2:	f6 95       	lsr	r31
    2ed4:	87 95       	ror	r24
    2ed6:	77 95       	ror	r23
    2ed8:	67 95       	ror	r22
    2eda:	b7 95       	ror	r27
    2edc:	f1 11       	cpse	r31, r1
    2ede:	f8 cf       	rjmp	.-16     	; 0x2ed0 <__floatsisf+0x1c>
    2ee0:	fa f4       	brpl	.+62     	; 0x2f20 <__floatsisf+0x6c>
    2ee2:	bb 0f       	add	r27, r27
    2ee4:	11 f4       	brne	.+4      	; 0x2eea <__floatsisf+0x36>
    2ee6:	60 ff       	sbrs	r22, 0
    2ee8:	1b c0       	rjmp	.+54     	; 0x2f20 <__floatsisf+0x6c>
    2eea:	6f 5f       	subi	r22, 0xFF	; 255
    2eec:	7f 4f       	sbci	r23, 0xFF	; 255
    2eee:	8f 4f       	sbci	r24, 0xFF	; 255
    2ef0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ef2:	16 c0       	rjmp	.+44     	; 0x2f20 <__floatsisf+0x6c>
    2ef4:	88 23       	and	r24, r24
    2ef6:	11 f0       	breq	.+4      	; 0x2efc <__floatsisf+0x48>
    2ef8:	96 e9       	ldi	r25, 0x96	; 150
    2efa:	11 c0       	rjmp	.+34     	; 0x2f1e <__floatsisf+0x6a>
    2efc:	77 23       	and	r23, r23
    2efe:	21 f0       	breq	.+8      	; 0x2f08 <__floatsisf+0x54>
    2f00:	9e e8       	ldi	r25, 0x8E	; 142
    2f02:	87 2f       	mov	r24, r23
    2f04:	76 2f       	mov	r23, r22
    2f06:	05 c0       	rjmp	.+10     	; 0x2f12 <__floatsisf+0x5e>
    2f08:	66 23       	and	r22, r22
    2f0a:	71 f0       	breq	.+28     	; 0x2f28 <__floatsisf+0x74>
    2f0c:	96 e8       	ldi	r25, 0x86	; 134
    2f0e:	86 2f       	mov	r24, r22
    2f10:	70 e0       	ldi	r23, 0x00	; 0
    2f12:	60 e0       	ldi	r22, 0x00	; 0
    2f14:	2a f0       	brmi	.+10     	; 0x2f20 <__floatsisf+0x6c>
    2f16:	9a 95       	dec	r25
    2f18:	66 0f       	add	r22, r22
    2f1a:	77 1f       	adc	r23, r23
    2f1c:	88 1f       	adc	r24, r24
    2f1e:	da f7       	brpl	.-10     	; 0x2f16 <__floatsisf+0x62>
    2f20:	88 0f       	add	r24, r24
    2f22:	96 95       	lsr	r25
    2f24:	87 95       	ror	r24
    2f26:	97 f9       	bld	r25, 7
    2f28:	08 95       	ret

00002f2a <__fp_cmp>:
    2f2a:	99 0f       	add	r25, r25
    2f2c:	00 08       	sbc	r0, r0
    2f2e:	55 0f       	add	r21, r21
    2f30:	aa 0b       	sbc	r26, r26
    2f32:	e0 e8       	ldi	r30, 0x80	; 128
    2f34:	fe ef       	ldi	r31, 0xFE	; 254
    2f36:	16 16       	cp	r1, r22
    2f38:	17 06       	cpc	r1, r23
    2f3a:	e8 07       	cpc	r30, r24
    2f3c:	f9 07       	cpc	r31, r25
    2f3e:	c0 f0       	brcs	.+48     	; 0x2f70 <__fp_cmp+0x46>
    2f40:	12 16       	cp	r1, r18
    2f42:	13 06       	cpc	r1, r19
    2f44:	e4 07       	cpc	r30, r20
    2f46:	f5 07       	cpc	r31, r21
    2f48:	98 f0       	brcs	.+38     	; 0x2f70 <__fp_cmp+0x46>
    2f4a:	62 1b       	sub	r22, r18
    2f4c:	73 0b       	sbc	r23, r19
    2f4e:	84 0b       	sbc	r24, r20
    2f50:	95 0b       	sbc	r25, r21
    2f52:	39 f4       	brne	.+14     	; 0x2f62 <__fp_cmp+0x38>
    2f54:	0a 26       	eor	r0, r26
    2f56:	61 f0       	breq	.+24     	; 0x2f70 <__fp_cmp+0x46>
    2f58:	23 2b       	or	r18, r19
    2f5a:	24 2b       	or	r18, r20
    2f5c:	25 2b       	or	r18, r21
    2f5e:	21 f4       	brne	.+8      	; 0x2f68 <__fp_cmp+0x3e>
    2f60:	08 95       	ret
    2f62:	0a 26       	eor	r0, r26
    2f64:	09 f4       	brne	.+2      	; 0x2f68 <__fp_cmp+0x3e>
    2f66:	a1 40       	sbci	r26, 0x01	; 1
    2f68:	a6 95       	lsr	r26
    2f6a:	8f ef       	ldi	r24, 0xFF	; 255
    2f6c:	81 1d       	adc	r24, r1
    2f6e:	81 1d       	adc	r24, r1
    2f70:	08 95       	ret

00002f72 <__fp_inf>:
    2f72:	97 f9       	bld	r25, 7
    2f74:	9f 67       	ori	r25, 0x7F	; 127
    2f76:	80 e8       	ldi	r24, 0x80	; 128
    2f78:	70 e0       	ldi	r23, 0x00	; 0
    2f7a:	60 e0       	ldi	r22, 0x00	; 0
    2f7c:	08 95       	ret

00002f7e <__fp_mintl>:
    2f7e:	88 23       	and	r24, r24
    2f80:	71 f4       	brne	.+28     	; 0x2f9e <__fp_mintl+0x20>
    2f82:	77 23       	and	r23, r23
    2f84:	21 f0       	breq	.+8      	; 0x2f8e <__fp_mintl+0x10>
    2f86:	98 50       	subi	r25, 0x08	; 8
    2f88:	87 2b       	or	r24, r23
    2f8a:	76 2f       	mov	r23, r22
    2f8c:	07 c0       	rjmp	.+14     	; 0x2f9c <__fp_mintl+0x1e>
    2f8e:	66 23       	and	r22, r22
    2f90:	11 f4       	brne	.+4      	; 0x2f96 <__fp_mintl+0x18>
    2f92:	99 27       	eor	r25, r25
    2f94:	0d c0       	rjmp	.+26     	; 0x2fb0 <__fp_mintl+0x32>
    2f96:	90 51       	subi	r25, 0x10	; 16
    2f98:	86 2b       	or	r24, r22
    2f9a:	70 e0       	ldi	r23, 0x00	; 0
    2f9c:	60 e0       	ldi	r22, 0x00	; 0
    2f9e:	2a f0       	brmi	.+10     	; 0x2faa <__fp_mintl+0x2c>
    2fa0:	9a 95       	dec	r25
    2fa2:	66 0f       	add	r22, r22
    2fa4:	77 1f       	adc	r23, r23
    2fa6:	88 1f       	adc	r24, r24
    2fa8:	da f7       	brpl	.-10     	; 0x2fa0 <__fp_mintl+0x22>
    2faa:	88 0f       	add	r24, r24
    2fac:	96 95       	lsr	r25
    2fae:	87 95       	ror	r24
    2fb0:	97 f9       	bld	r25, 7
    2fb2:	08 95       	ret

00002fb4 <__fp_mpack>:
    2fb4:	9f 3f       	cpi	r25, 0xFF	; 255
    2fb6:	31 f0       	breq	.+12     	; 0x2fc4 <__fp_mpack_finite+0xc>

00002fb8 <__fp_mpack_finite>:
    2fb8:	91 50       	subi	r25, 0x01	; 1
    2fba:	20 f4       	brcc	.+8      	; 0x2fc4 <__fp_mpack_finite+0xc>
    2fbc:	87 95       	ror	r24
    2fbe:	77 95       	ror	r23
    2fc0:	67 95       	ror	r22
    2fc2:	b7 95       	ror	r27
    2fc4:	88 0f       	add	r24, r24
    2fc6:	91 1d       	adc	r25, r1
    2fc8:	96 95       	lsr	r25
    2fca:	87 95       	ror	r24
    2fcc:	97 f9       	bld	r25, 7
    2fce:	08 95       	ret

00002fd0 <__fp_nan>:
    2fd0:	9f ef       	ldi	r25, 0xFF	; 255
    2fd2:	80 ec       	ldi	r24, 0xC0	; 192
    2fd4:	08 95       	ret

00002fd6 <__fp_pscA>:
    2fd6:	00 24       	eor	r0, r0
    2fd8:	0a 94       	dec	r0
    2fda:	16 16       	cp	r1, r22
    2fdc:	17 06       	cpc	r1, r23
    2fde:	18 06       	cpc	r1, r24
    2fe0:	09 06       	cpc	r0, r25
    2fe2:	08 95       	ret

00002fe4 <__fp_pscB>:
    2fe4:	00 24       	eor	r0, r0
    2fe6:	0a 94       	dec	r0
    2fe8:	12 16       	cp	r1, r18
    2fea:	13 06       	cpc	r1, r19
    2fec:	14 06       	cpc	r1, r20
    2fee:	05 06       	cpc	r0, r21
    2ff0:	08 95       	ret

00002ff2 <__fp_round>:
    2ff2:	09 2e       	mov	r0, r25
    2ff4:	03 94       	inc	r0
    2ff6:	00 0c       	add	r0, r0
    2ff8:	11 f4       	brne	.+4      	; 0x2ffe <__fp_round+0xc>
    2ffa:	88 23       	and	r24, r24
    2ffc:	52 f0       	brmi	.+20     	; 0x3012 <__fp_round+0x20>
    2ffe:	bb 0f       	add	r27, r27
    3000:	40 f4       	brcc	.+16     	; 0x3012 <__fp_round+0x20>
    3002:	bf 2b       	or	r27, r31
    3004:	11 f4       	brne	.+4      	; 0x300a <__fp_round+0x18>
    3006:	60 ff       	sbrs	r22, 0
    3008:	04 c0       	rjmp	.+8      	; 0x3012 <__fp_round+0x20>
    300a:	6f 5f       	subi	r22, 0xFF	; 255
    300c:	7f 4f       	sbci	r23, 0xFF	; 255
    300e:	8f 4f       	sbci	r24, 0xFF	; 255
    3010:	9f 4f       	sbci	r25, 0xFF	; 255
    3012:	08 95       	ret

00003014 <__fp_split3>:
    3014:	57 fd       	sbrc	r21, 7
    3016:	90 58       	subi	r25, 0x80	; 128
    3018:	44 0f       	add	r20, r20
    301a:	55 1f       	adc	r21, r21
    301c:	59 f0       	breq	.+22     	; 0x3034 <__fp_splitA+0x10>
    301e:	5f 3f       	cpi	r21, 0xFF	; 255
    3020:	71 f0       	breq	.+28     	; 0x303e <__fp_splitA+0x1a>
    3022:	47 95       	ror	r20

00003024 <__fp_splitA>:
    3024:	88 0f       	add	r24, r24
    3026:	97 fb       	bst	r25, 7
    3028:	99 1f       	adc	r25, r25
    302a:	61 f0       	breq	.+24     	; 0x3044 <__fp_splitA+0x20>
    302c:	9f 3f       	cpi	r25, 0xFF	; 255
    302e:	79 f0       	breq	.+30     	; 0x304e <__fp_splitA+0x2a>
    3030:	87 95       	ror	r24
    3032:	08 95       	ret
    3034:	12 16       	cp	r1, r18
    3036:	13 06       	cpc	r1, r19
    3038:	14 06       	cpc	r1, r20
    303a:	55 1f       	adc	r21, r21
    303c:	f2 cf       	rjmp	.-28     	; 0x3022 <__fp_split3+0xe>
    303e:	46 95       	lsr	r20
    3040:	f1 df       	rcall	.-30     	; 0x3024 <__fp_splitA>
    3042:	08 c0       	rjmp	.+16     	; 0x3054 <__fp_splitA+0x30>
    3044:	16 16       	cp	r1, r22
    3046:	17 06       	cpc	r1, r23
    3048:	18 06       	cpc	r1, r24
    304a:	99 1f       	adc	r25, r25
    304c:	f1 cf       	rjmp	.-30     	; 0x3030 <__fp_splitA+0xc>
    304e:	86 95       	lsr	r24
    3050:	71 05       	cpc	r23, r1
    3052:	61 05       	cpc	r22, r1
    3054:	08 94       	sec
    3056:	08 95       	ret

00003058 <__fp_trunc>:
    3058:	e5 df       	rcall	.-54     	; 0x3024 <__fp_splitA>
    305a:	a0 f0       	brcs	.+40     	; 0x3084 <__fp_trunc+0x2c>
    305c:	be e7       	ldi	r27, 0x7E	; 126
    305e:	b9 17       	cp	r27, r25
    3060:	88 f4       	brcc	.+34     	; 0x3084 <__fp_trunc+0x2c>
    3062:	bb 27       	eor	r27, r27
    3064:	9f 38       	cpi	r25, 0x8F	; 143
    3066:	60 f4       	brcc	.+24     	; 0x3080 <__fp_trunc+0x28>
    3068:	16 16       	cp	r1, r22
    306a:	b1 1d       	adc	r27, r1
    306c:	67 2f       	mov	r22, r23
    306e:	78 2f       	mov	r23, r24
    3070:	88 27       	eor	r24, r24
    3072:	98 5f       	subi	r25, 0xF8	; 248
    3074:	f7 cf       	rjmp	.-18     	; 0x3064 <__fp_trunc+0xc>
    3076:	86 95       	lsr	r24
    3078:	77 95       	ror	r23
    307a:	67 95       	ror	r22
    307c:	b1 1d       	adc	r27, r1
    307e:	93 95       	inc	r25
    3080:	96 39       	cpi	r25, 0x96	; 150
    3082:	c8 f3       	brcs	.-14     	; 0x3076 <__fp_trunc+0x1e>
    3084:	08 95       	ret

00003086 <__fp_zero>:
    3086:	e8 94       	clt

00003088 <__fp_szero>:
    3088:	bb 27       	eor	r27, r27
    308a:	66 27       	eor	r22, r22
    308c:	77 27       	eor	r23, r23
    308e:	cb 01       	movw	r24, r22
    3090:	97 f9       	bld	r25, 7
    3092:	08 95       	ret

00003094 <__mulsf3>:
    3094:	0b d0       	rcall	.+22     	; 0x30ac <__mulsf3x>
    3096:	ad cf       	rjmp	.-166    	; 0x2ff2 <__fp_round>
    3098:	9e df       	rcall	.-196    	; 0x2fd6 <__fp_pscA>
    309a:	28 f0       	brcs	.+10     	; 0x30a6 <__mulsf3+0x12>
    309c:	a3 df       	rcall	.-186    	; 0x2fe4 <__fp_pscB>
    309e:	18 f0       	brcs	.+6      	; 0x30a6 <__mulsf3+0x12>
    30a0:	95 23       	and	r25, r21
    30a2:	09 f0       	breq	.+2      	; 0x30a6 <__mulsf3+0x12>
    30a4:	66 cf       	rjmp	.-308    	; 0x2f72 <__fp_inf>
    30a6:	94 cf       	rjmp	.-216    	; 0x2fd0 <__fp_nan>
    30a8:	11 24       	eor	r1, r1
    30aa:	ee cf       	rjmp	.-36     	; 0x3088 <__fp_szero>

000030ac <__mulsf3x>:
    30ac:	b3 df       	rcall	.-154    	; 0x3014 <__fp_split3>
    30ae:	a0 f3       	brcs	.-24     	; 0x3098 <__mulsf3+0x4>

000030b0 <__mulsf3_pse>:
    30b0:	95 9f       	mul	r25, r21
    30b2:	d1 f3       	breq	.-12     	; 0x30a8 <__mulsf3+0x14>
    30b4:	95 0f       	add	r25, r21
    30b6:	50 e0       	ldi	r21, 0x00	; 0
    30b8:	55 1f       	adc	r21, r21
    30ba:	62 9f       	mul	r22, r18
    30bc:	f0 01       	movw	r30, r0
    30be:	72 9f       	mul	r23, r18
    30c0:	bb 27       	eor	r27, r27
    30c2:	f0 0d       	add	r31, r0
    30c4:	b1 1d       	adc	r27, r1
    30c6:	63 9f       	mul	r22, r19
    30c8:	aa 27       	eor	r26, r26
    30ca:	f0 0d       	add	r31, r0
    30cc:	b1 1d       	adc	r27, r1
    30ce:	aa 1f       	adc	r26, r26
    30d0:	64 9f       	mul	r22, r20
    30d2:	66 27       	eor	r22, r22
    30d4:	b0 0d       	add	r27, r0
    30d6:	a1 1d       	adc	r26, r1
    30d8:	66 1f       	adc	r22, r22
    30da:	82 9f       	mul	r24, r18
    30dc:	22 27       	eor	r18, r18
    30de:	b0 0d       	add	r27, r0
    30e0:	a1 1d       	adc	r26, r1
    30e2:	62 1f       	adc	r22, r18
    30e4:	73 9f       	mul	r23, r19
    30e6:	b0 0d       	add	r27, r0
    30e8:	a1 1d       	adc	r26, r1
    30ea:	62 1f       	adc	r22, r18
    30ec:	83 9f       	mul	r24, r19
    30ee:	a0 0d       	add	r26, r0
    30f0:	61 1d       	adc	r22, r1
    30f2:	22 1f       	adc	r18, r18
    30f4:	74 9f       	mul	r23, r20
    30f6:	33 27       	eor	r19, r19
    30f8:	a0 0d       	add	r26, r0
    30fa:	61 1d       	adc	r22, r1
    30fc:	23 1f       	adc	r18, r19
    30fe:	84 9f       	mul	r24, r20
    3100:	60 0d       	add	r22, r0
    3102:	21 1d       	adc	r18, r1
    3104:	82 2f       	mov	r24, r18
    3106:	76 2f       	mov	r23, r22
    3108:	6a 2f       	mov	r22, r26
    310a:	11 24       	eor	r1, r1
    310c:	9f 57       	subi	r25, 0x7F	; 127
    310e:	50 40       	sbci	r21, 0x00	; 0
    3110:	8a f0       	brmi	.+34     	; 0x3134 <__mulsf3_pse+0x84>
    3112:	e1 f0       	breq	.+56     	; 0x314c <__mulsf3_pse+0x9c>
    3114:	88 23       	and	r24, r24
    3116:	4a f0       	brmi	.+18     	; 0x312a <__mulsf3_pse+0x7a>
    3118:	ee 0f       	add	r30, r30
    311a:	ff 1f       	adc	r31, r31
    311c:	bb 1f       	adc	r27, r27
    311e:	66 1f       	adc	r22, r22
    3120:	77 1f       	adc	r23, r23
    3122:	88 1f       	adc	r24, r24
    3124:	91 50       	subi	r25, 0x01	; 1
    3126:	50 40       	sbci	r21, 0x00	; 0
    3128:	a9 f7       	brne	.-22     	; 0x3114 <__mulsf3_pse+0x64>
    312a:	9e 3f       	cpi	r25, 0xFE	; 254
    312c:	51 05       	cpc	r21, r1
    312e:	70 f0       	brcs	.+28     	; 0x314c <__mulsf3_pse+0x9c>
    3130:	20 cf       	rjmp	.-448    	; 0x2f72 <__fp_inf>
    3132:	aa cf       	rjmp	.-172    	; 0x3088 <__fp_szero>
    3134:	5f 3f       	cpi	r21, 0xFF	; 255
    3136:	ec f3       	brlt	.-6      	; 0x3132 <__mulsf3_pse+0x82>
    3138:	98 3e       	cpi	r25, 0xE8	; 232
    313a:	dc f3       	brlt	.-10     	; 0x3132 <__mulsf3_pse+0x82>
    313c:	86 95       	lsr	r24
    313e:	77 95       	ror	r23
    3140:	67 95       	ror	r22
    3142:	b7 95       	ror	r27
    3144:	f7 95       	ror	r31
    3146:	e7 95       	ror	r30
    3148:	9f 5f       	subi	r25, 0xFF	; 255
    314a:	c1 f7       	brne	.-16     	; 0x313c <__mulsf3_pse+0x8c>
    314c:	fe 2b       	or	r31, r30
    314e:	88 0f       	add	r24, r24
    3150:	91 1d       	adc	r25, r1
    3152:	96 95       	lsr	r25
    3154:	87 95       	ror	r24
    3156:	97 f9       	bld	r25, 7
    3158:	08 95       	ret

0000315a <pow>:
    315a:	fa 01       	movw	r30, r20
    315c:	ee 0f       	add	r30, r30
    315e:	ff 1f       	adc	r31, r31
    3160:	30 96       	adiw	r30, 0x00	; 0
    3162:	21 05       	cpc	r18, r1
    3164:	31 05       	cpc	r19, r1
    3166:	99 f1       	breq	.+102    	; 0x31ce <pow+0x74>
    3168:	61 15       	cp	r22, r1
    316a:	71 05       	cpc	r23, r1
    316c:	61 f4       	brne	.+24     	; 0x3186 <pow+0x2c>
    316e:	80 38       	cpi	r24, 0x80	; 128
    3170:	bf e3       	ldi	r27, 0x3F	; 63
    3172:	9b 07       	cpc	r25, r27
    3174:	49 f1       	breq	.+82     	; 0x31c8 <pow+0x6e>
    3176:	68 94       	set
    3178:	90 38       	cpi	r25, 0x80	; 128
    317a:	81 05       	cpc	r24, r1
    317c:	61 f0       	breq	.+24     	; 0x3196 <pow+0x3c>
    317e:	80 38       	cpi	r24, 0x80	; 128
    3180:	bf ef       	ldi	r27, 0xFF	; 255
    3182:	9b 07       	cpc	r25, r27
    3184:	41 f0       	breq	.+16     	; 0x3196 <pow+0x3c>
    3186:	99 23       	and	r25, r25
    3188:	42 f5       	brpl	.+80     	; 0x31da <pow+0x80>
    318a:	ff 3f       	cpi	r31, 0xFF	; 255
    318c:	e1 05       	cpc	r30, r1
    318e:	31 05       	cpc	r19, r1
    3190:	21 05       	cpc	r18, r1
    3192:	11 f1       	breq	.+68     	; 0x31d8 <pow+0x7e>
    3194:	e8 94       	clt
    3196:	08 94       	sec
    3198:	e7 95       	ror	r30
    319a:	d9 01       	movw	r26, r18
    319c:	aa 23       	and	r26, r26
    319e:	29 f4       	brne	.+10     	; 0x31aa <pow+0x50>
    31a0:	ab 2f       	mov	r26, r27
    31a2:	be 2f       	mov	r27, r30
    31a4:	f8 5f       	subi	r31, 0xF8	; 248
    31a6:	d0 f3       	brcs	.-12     	; 0x319c <pow+0x42>
    31a8:	10 c0       	rjmp	.+32     	; 0x31ca <pow+0x70>
    31aa:	ff 5f       	subi	r31, 0xFF	; 255
    31ac:	70 f4       	brcc	.+28     	; 0x31ca <pow+0x70>
    31ae:	a6 95       	lsr	r26
    31b0:	e0 f7       	brcc	.-8      	; 0x31aa <pow+0x50>
    31b2:	f7 39       	cpi	r31, 0x97	; 151
    31b4:	50 f0       	brcs	.+20     	; 0x31ca <pow+0x70>
    31b6:	19 f0       	breq	.+6      	; 0x31be <pow+0x64>
    31b8:	ff 3a       	cpi	r31, 0xAF	; 175
    31ba:	38 f4       	brcc	.+14     	; 0x31ca <pow+0x70>
    31bc:	9f 77       	andi	r25, 0x7F	; 127
    31be:	9f 93       	push	r25
    31c0:	0c d0       	rcall	.+24     	; 0x31da <pow+0x80>
    31c2:	0f 90       	pop	r0
    31c4:	07 fc       	sbrc	r0, 7
    31c6:	90 58       	subi	r25, 0x80	; 128
    31c8:	08 95       	ret
    31ca:	3e f0       	brts	.+14     	; 0x31da <pow+0x80>
    31cc:	01 cf       	rjmp	.-510    	; 0x2fd0 <__fp_nan>
    31ce:	60 e0       	ldi	r22, 0x00	; 0
    31d0:	70 e0       	ldi	r23, 0x00	; 0
    31d2:	80 e8       	ldi	r24, 0x80	; 128
    31d4:	9f e3       	ldi	r25, 0x3F	; 63
    31d6:	08 95       	ret
    31d8:	4f e7       	ldi	r20, 0x7F	; 127
    31da:	9f 77       	andi	r25, 0x7F	; 127
    31dc:	5f 93       	push	r21
    31de:	4f 93       	push	r20
    31e0:	3f 93       	push	r19
    31e2:	2f 93       	push	r18
    31e4:	9e d0       	rcall	.+316    	; 0x3322 <log>
    31e6:	2f 91       	pop	r18
    31e8:	3f 91       	pop	r19
    31ea:	4f 91       	pop	r20
    31ec:	5f 91       	pop	r21
    31ee:	52 df       	rcall	.-348    	; 0x3094 <__mulsf3>
    31f0:	05 c0       	rjmp	.+10     	; 0x31fc <exp>
    31f2:	19 f4       	brne	.+6      	; 0x31fa <pow+0xa0>
    31f4:	0e f0       	brts	.+2      	; 0x31f8 <pow+0x9e>
    31f6:	bd ce       	rjmp	.-646    	; 0x2f72 <__fp_inf>
    31f8:	46 cf       	rjmp	.-372    	; 0x3086 <__fp_zero>
    31fa:	ea ce       	rjmp	.-556    	; 0x2fd0 <__fp_nan>

000031fc <exp>:
    31fc:	13 df       	rcall	.-474    	; 0x3024 <__fp_splitA>
    31fe:	c8 f3       	brcs	.-14     	; 0x31f2 <pow+0x98>
    3200:	96 38       	cpi	r25, 0x86	; 134
    3202:	c0 f7       	brcc	.-16     	; 0x31f4 <pow+0x9a>
    3204:	07 f8       	bld	r0, 7
    3206:	0f 92       	push	r0
    3208:	e8 94       	clt
    320a:	2b e3       	ldi	r18, 0x3B	; 59
    320c:	3a ea       	ldi	r19, 0xAA	; 170
    320e:	48 eb       	ldi	r20, 0xB8	; 184
    3210:	5f e7       	ldi	r21, 0x7F	; 127
    3212:	4e df       	rcall	.-356    	; 0x30b0 <__mulsf3_pse>
    3214:	0f 92       	push	r0
    3216:	0f 92       	push	r0
    3218:	0f 92       	push	r0
    321a:	4d b7       	in	r20, 0x3d	; 61
    321c:	5e b7       	in	r21, 0x3e	; 62
    321e:	0f 92       	push	r0
    3220:	c0 d0       	rcall	.+384    	; 0x33a2 <modf>
    3222:	e4 ee       	ldi	r30, 0xE4	; 228
    3224:	f0 e0       	ldi	r31, 0x00	; 0
    3226:	16 d0       	rcall	.+44     	; 0x3254 <__fp_powser>
    3228:	4f 91       	pop	r20
    322a:	5f 91       	pop	r21
    322c:	ef 91       	pop	r30
    322e:	ff 91       	pop	r31
    3230:	e5 95       	asr	r30
    3232:	ee 1f       	adc	r30, r30
    3234:	ff 1f       	adc	r31, r31
    3236:	49 f0       	breq	.+18     	; 0x324a <exp+0x4e>
    3238:	fe 57       	subi	r31, 0x7E	; 126
    323a:	e0 68       	ori	r30, 0x80	; 128
    323c:	44 27       	eor	r20, r20
    323e:	ee 0f       	add	r30, r30
    3240:	44 1f       	adc	r20, r20
    3242:	fa 95       	dec	r31
    3244:	e1 f7       	brne	.-8      	; 0x323e <exp+0x42>
    3246:	41 95       	neg	r20
    3248:	55 0b       	sbc	r21, r21
    324a:	32 d0       	rcall	.+100    	; 0x32b0 <ldexp>
    324c:	0f 90       	pop	r0
    324e:	07 fe       	sbrs	r0, 7
    3250:	26 c0       	rjmp	.+76     	; 0x329e <inverse>
    3252:	08 95       	ret

00003254 <__fp_powser>:
    3254:	df 93       	push	r29
    3256:	cf 93       	push	r28
    3258:	1f 93       	push	r17
    325a:	0f 93       	push	r16
    325c:	ff 92       	push	r15
    325e:	ef 92       	push	r14
    3260:	df 92       	push	r13
    3262:	7b 01       	movw	r14, r22
    3264:	8c 01       	movw	r16, r24
    3266:	68 94       	set
    3268:	05 c0       	rjmp	.+10     	; 0x3274 <__fp_powser+0x20>
    326a:	da 2e       	mov	r13, r26
    326c:	ef 01       	movw	r28, r30
    326e:	1e df       	rcall	.-452    	; 0x30ac <__mulsf3x>
    3270:	fe 01       	movw	r30, r28
    3272:	e8 94       	clt
    3274:	a5 91       	lpm	r26, Z+
    3276:	25 91       	lpm	r18, Z+
    3278:	35 91       	lpm	r19, Z+
    327a:	45 91       	lpm	r20, Z+
    327c:	55 91       	lpm	r21, Z+
    327e:	ae f3       	brts	.-22     	; 0x326a <__fp_powser+0x16>
    3280:	ef 01       	movw	r28, r30
    3282:	13 dd       	rcall	.-1498   	; 0x2caa <__addsf3x>
    3284:	fe 01       	movw	r30, r28
    3286:	97 01       	movw	r18, r14
    3288:	a8 01       	movw	r20, r16
    328a:	da 94       	dec	r13
    328c:	79 f7       	brne	.-34     	; 0x326c <__fp_powser+0x18>
    328e:	df 90       	pop	r13
    3290:	ef 90       	pop	r14
    3292:	ff 90       	pop	r15
    3294:	0f 91       	pop	r16
    3296:	1f 91       	pop	r17
    3298:	cf 91       	pop	r28
    329a:	df 91       	pop	r29
    329c:	08 95       	ret

0000329e <inverse>:
    329e:	9b 01       	movw	r18, r22
    32a0:	ac 01       	movw	r20, r24
    32a2:	60 e0       	ldi	r22, 0x00	; 0
    32a4:	70 e0       	ldi	r23, 0x00	; 0
    32a6:	80 e8       	ldi	r24, 0x80	; 128
    32a8:	9f e3       	ldi	r25, 0x3F	; 63
    32aa:	69 cd       	rjmp	.-1326   	; 0x2d7e <__divsf3>
    32ac:	62 ce       	rjmp	.-828    	; 0x2f72 <__fp_inf>
    32ae:	82 ce       	rjmp	.-764    	; 0x2fb4 <__fp_mpack>

000032b0 <ldexp>:
    32b0:	b9 de       	rcall	.-654    	; 0x3024 <__fp_splitA>
    32b2:	e8 f3       	brcs	.-6      	; 0x32ae <inverse+0x10>
    32b4:	99 23       	and	r25, r25
    32b6:	d9 f3       	breq	.-10     	; 0x32ae <inverse+0x10>
    32b8:	94 0f       	add	r25, r20
    32ba:	51 1d       	adc	r21, r1
    32bc:	bb f3       	brvs	.-18     	; 0x32ac <inverse+0xe>
    32be:	91 50       	subi	r25, 0x01	; 1
    32c0:	50 40       	sbci	r21, 0x00	; 0
    32c2:	94 f0       	brlt	.+36     	; 0x32e8 <ldexp+0x38>
    32c4:	59 f0       	breq	.+22     	; 0x32dc <ldexp+0x2c>
    32c6:	88 23       	and	r24, r24
    32c8:	32 f0       	brmi	.+12     	; 0x32d6 <ldexp+0x26>
    32ca:	66 0f       	add	r22, r22
    32cc:	77 1f       	adc	r23, r23
    32ce:	88 1f       	adc	r24, r24
    32d0:	91 50       	subi	r25, 0x01	; 1
    32d2:	50 40       	sbci	r21, 0x00	; 0
    32d4:	c1 f7       	brne	.-16     	; 0x32c6 <ldexp+0x16>
    32d6:	9e 3f       	cpi	r25, 0xFE	; 254
    32d8:	51 05       	cpc	r21, r1
    32da:	44 f7       	brge	.-48     	; 0x32ac <inverse+0xe>
    32dc:	88 0f       	add	r24, r24
    32de:	91 1d       	adc	r25, r1
    32e0:	96 95       	lsr	r25
    32e2:	87 95       	ror	r24
    32e4:	97 f9       	bld	r25, 7
    32e6:	08 95       	ret
    32e8:	5f 3f       	cpi	r21, 0xFF	; 255
    32ea:	ac f0       	brlt	.+42     	; 0x3316 <ldexp+0x66>
    32ec:	98 3e       	cpi	r25, 0xE8	; 232
    32ee:	9c f0       	brlt	.+38     	; 0x3316 <ldexp+0x66>
    32f0:	bb 27       	eor	r27, r27
    32f2:	86 95       	lsr	r24
    32f4:	77 95       	ror	r23
    32f6:	67 95       	ror	r22
    32f8:	b7 95       	ror	r27
    32fa:	08 f4       	brcc	.+2      	; 0x32fe <ldexp+0x4e>
    32fc:	b1 60       	ori	r27, 0x01	; 1
    32fe:	93 95       	inc	r25
    3300:	c1 f7       	brne	.-16     	; 0x32f2 <ldexp+0x42>
    3302:	bb 0f       	add	r27, r27
    3304:	58 f7       	brcc	.-42     	; 0x32dc <ldexp+0x2c>
    3306:	11 f4       	brne	.+4      	; 0x330c <ldexp+0x5c>
    3308:	60 ff       	sbrs	r22, 0
    330a:	e8 cf       	rjmp	.-48     	; 0x32dc <ldexp+0x2c>
    330c:	6f 5f       	subi	r22, 0xFF	; 255
    330e:	7f 4f       	sbci	r23, 0xFF	; 255
    3310:	8f 4f       	sbci	r24, 0xFF	; 255
    3312:	9f 4f       	sbci	r25, 0xFF	; 255
    3314:	e3 cf       	rjmp	.-58     	; 0x32dc <ldexp+0x2c>
    3316:	b8 ce       	rjmp	.-656    	; 0x3088 <__fp_szero>
    3318:	0e f0       	brts	.+2      	; 0x331c <ldexp+0x6c>
    331a:	4c ce       	rjmp	.-872    	; 0x2fb4 <__fp_mpack>
    331c:	59 ce       	rjmp	.-846    	; 0x2fd0 <__fp_nan>
    331e:	68 94       	set
    3320:	28 ce       	rjmp	.-944    	; 0x2f72 <__fp_inf>

00003322 <log>:
    3322:	80 de       	rcall	.-768    	; 0x3024 <__fp_splitA>
    3324:	c8 f3       	brcs	.-14     	; 0x3318 <ldexp+0x68>
    3326:	99 23       	and	r25, r25
    3328:	d1 f3       	breq	.-12     	; 0x331e <ldexp+0x6e>
    332a:	c6 f3       	brts	.-16     	; 0x331c <ldexp+0x6c>
    332c:	df 93       	push	r29
    332e:	cf 93       	push	r28
    3330:	1f 93       	push	r17
    3332:	0f 93       	push	r16
    3334:	ff 92       	push	r15
    3336:	c9 2f       	mov	r28, r25
    3338:	dd 27       	eor	r29, r29
    333a:	88 23       	and	r24, r24
    333c:	2a f0       	brmi	.+10     	; 0x3348 <log+0x26>
    333e:	21 97       	sbiw	r28, 0x01	; 1
    3340:	66 0f       	add	r22, r22
    3342:	77 1f       	adc	r23, r23
    3344:	88 1f       	adc	r24, r24
    3346:	da f7       	brpl	.-10     	; 0x333e <log+0x1c>
    3348:	20 e0       	ldi	r18, 0x00	; 0
    334a:	30 e0       	ldi	r19, 0x00	; 0
    334c:	40 e8       	ldi	r20, 0x80	; 128
    334e:	5f eb       	ldi	r21, 0xBF	; 191
    3350:	9f e3       	ldi	r25, 0x3F	; 63
    3352:	88 39       	cpi	r24, 0x98	; 152
    3354:	20 f0       	brcs	.+8      	; 0x335e <log+0x3c>
    3356:	80 3e       	cpi	r24, 0xE0	; 224
    3358:	30 f0       	brcs	.+12     	; 0x3366 <log+0x44>
    335a:	21 96       	adiw	r28, 0x01	; 1
    335c:	8f 77       	andi	r24, 0x7F	; 127
    335e:	94 dc       	rcall	.-1752   	; 0x2c88 <__addsf3>
    3360:	ec e0       	ldi	r30, 0x0C	; 12
    3362:	f1 e0       	ldi	r31, 0x01	; 1
    3364:	03 c0       	rjmp	.+6      	; 0x336c <log+0x4a>
    3366:	90 dc       	rcall	.-1760   	; 0x2c88 <__addsf3>
    3368:	e9 e3       	ldi	r30, 0x39	; 57
    336a:	f1 e0       	ldi	r31, 0x01	; 1
    336c:	73 df       	rcall	.-282    	; 0x3254 <__fp_powser>
    336e:	8b 01       	movw	r16, r22
    3370:	be 01       	movw	r22, r28
    3372:	ec 01       	movw	r28, r24
    3374:	fb 2e       	mov	r15, r27
    3376:	6f 57       	subi	r22, 0x7F	; 127
    3378:	71 09       	sbc	r23, r1
    337a:	75 95       	asr	r23
    337c:	77 1f       	adc	r23, r23
    337e:	88 0b       	sbc	r24, r24
    3380:	99 0b       	sbc	r25, r25
    3382:	98 dd       	rcall	.-1232   	; 0x2eb4 <__floatsisf>
    3384:	28 e1       	ldi	r18, 0x18	; 24
    3386:	32 e7       	ldi	r19, 0x72	; 114
    3388:	41 e3       	ldi	r20, 0x31	; 49
    338a:	5f e3       	ldi	r21, 0x3F	; 63
    338c:	8f de       	rcall	.-738    	; 0x30ac <__mulsf3x>
    338e:	af 2d       	mov	r26, r15
    3390:	98 01       	movw	r18, r16
    3392:	ae 01       	movw	r20, r28
    3394:	ff 90       	pop	r15
    3396:	0f 91       	pop	r16
    3398:	1f 91       	pop	r17
    339a:	cf 91       	pop	r28
    339c:	df 91       	pop	r29
    339e:	85 dc       	rcall	.-1782   	; 0x2caa <__addsf3x>
    33a0:	28 ce       	rjmp	.-944    	; 0x2ff2 <__fp_round>

000033a2 <modf>:
    33a2:	fa 01       	movw	r30, r20
    33a4:	dc 01       	movw	r26, r24
    33a6:	aa 0f       	add	r26, r26
    33a8:	bb 1f       	adc	r27, r27
    33aa:	9b 01       	movw	r18, r22
    33ac:	ac 01       	movw	r20, r24
    33ae:	bf 57       	subi	r27, 0x7F	; 127
    33b0:	28 f4       	brcc	.+10     	; 0x33bc <modf+0x1a>
    33b2:	22 27       	eor	r18, r18
    33b4:	33 27       	eor	r19, r19
    33b6:	44 27       	eor	r20, r20
    33b8:	50 78       	andi	r21, 0x80	; 128
    33ba:	1f c0       	rjmp	.+62     	; 0x33fa <modf+0x58>
    33bc:	b7 51       	subi	r27, 0x17	; 23
    33be:	88 f4       	brcc	.+34     	; 0x33e2 <modf+0x40>
    33c0:	ab 2f       	mov	r26, r27
    33c2:	00 24       	eor	r0, r0
    33c4:	46 95       	lsr	r20
    33c6:	37 95       	ror	r19
    33c8:	27 95       	ror	r18
    33ca:	01 1c       	adc	r0, r1
    33cc:	a3 95       	inc	r26
    33ce:	d2 f3       	brmi	.-12     	; 0x33c4 <modf+0x22>
    33d0:	00 20       	and	r0, r0
    33d2:	69 f0       	breq	.+26     	; 0x33ee <modf+0x4c>
    33d4:	22 0f       	add	r18, r18
    33d6:	33 1f       	adc	r19, r19
    33d8:	44 1f       	adc	r20, r20
    33da:	b3 95       	inc	r27
    33dc:	da f3       	brmi	.-10     	; 0x33d4 <modf+0x32>
    33de:	0d d0       	rcall	.+26     	; 0x33fa <modf+0x58>
    33e0:	52 cc       	rjmp	.-1884   	; 0x2c86 <__subsf3>
    33e2:	61 30       	cpi	r22, 0x01	; 1
    33e4:	71 05       	cpc	r23, r1
    33e6:	a0 e8       	ldi	r26, 0x80	; 128
    33e8:	8a 07       	cpc	r24, r26
    33ea:	b9 46       	sbci	r27, 0x69	; 105
    33ec:	30 f4       	brcc	.+12     	; 0x33fa <modf+0x58>
    33ee:	9b 01       	movw	r18, r22
    33f0:	ac 01       	movw	r20, r24
    33f2:	66 27       	eor	r22, r22
    33f4:	77 27       	eor	r23, r23
    33f6:	88 27       	eor	r24, r24
    33f8:	90 78       	andi	r25, 0x80	; 128
    33fa:	30 96       	adiw	r30, 0x00	; 0
    33fc:	21 f0       	breq	.+8      	; 0x3406 <modf+0x64>
    33fe:	20 83       	st	Z, r18
    3400:	31 83       	std	Z+1, r19	; 0x01
    3402:	42 83       	std	Z+2, r20	; 0x02
    3404:	53 83       	std	Z+3, r21	; 0x03
    3406:	08 95       	ret

00003408 <__udivmodqi4>:
    3408:	99 1b       	sub	r25, r25
    340a:	79 e0       	ldi	r23, 0x09	; 9
    340c:	04 c0       	rjmp	.+8      	; 0x3416 <__udivmodqi4_ep>

0000340e <__udivmodqi4_loop>:
    340e:	99 1f       	adc	r25, r25
    3410:	96 17       	cp	r25, r22
    3412:	08 f0       	brcs	.+2      	; 0x3416 <__udivmodqi4_ep>
    3414:	96 1b       	sub	r25, r22

00003416 <__udivmodqi4_ep>:
    3416:	88 1f       	adc	r24, r24
    3418:	7a 95       	dec	r23
    341a:	c9 f7       	brne	.-14     	; 0x340e <__udivmodqi4_loop>
    341c:	80 95       	com	r24
    341e:	08 95       	ret

00003420 <__udivmodhi4>:
    3420:	aa 1b       	sub	r26, r26
    3422:	bb 1b       	sub	r27, r27
    3424:	51 e1       	ldi	r21, 0x11	; 17
    3426:	07 c0       	rjmp	.+14     	; 0x3436 <__udivmodhi4_ep>

00003428 <__udivmodhi4_loop>:
    3428:	aa 1f       	adc	r26, r26
    342a:	bb 1f       	adc	r27, r27
    342c:	a6 17       	cp	r26, r22
    342e:	b7 07       	cpc	r27, r23
    3430:	10 f0       	brcs	.+4      	; 0x3436 <__udivmodhi4_ep>
    3432:	a6 1b       	sub	r26, r22
    3434:	b7 0b       	sbc	r27, r23

00003436 <__udivmodhi4_ep>:
    3436:	88 1f       	adc	r24, r24
    3438:	99 1f       	adc	r25, r25
    343a:	5a 95       	dec	r21
    343c:	a9 f7       	brne	.-22     	; 0x3428 <__udivmodhi4_loop>
    343e:	80 95       	com	r24
    3440:	90 95       	com	r25
    3442:	bc 01       	movw	r22, r24
    3444:	cd 01       	movw	r24, r26
    3446:	08 95       	ret

00003448 <__divmodhi4>:
    3448:	97 fb       	bst	r25, 7
    344a:	09 2e       	mov	r0, r25
    344c:	07 26       	eor	r0, r23
    344e:	0a d0       	rcall	.+20     	; 0x3464 <__divmodhi4_neg1>
    3450:	77 fd       	sbrc	r23, 7
    3452:	04 d0       	rcall	.+8      	; 0x345c <__divmodhi4_neg2>
    3454:	e5 df       	rcall	.-54     	; 0x3420 <__udivmodhi4>
    3456:	06 d0       	rcall	.+12     	; 0x3464 <__divmodhi4_neg1>
    3458:	00 20       	and	r0, r0
    345a:	1a f4       	brpl	.+6      	; 0x3462 <__divmodhi4_exit>

0000345c <__divmodhi4_neg2>:
    345c:	70 95       	com	r23
    345e:	61 95       	neg	r22
    3460:	7f 4f       	sbci	r23, 0xFF	; 255

00003462 <__divmodhi4_exit>:
    3462:	08 95       	ret

00003464 <__divmodhi4_neg1>:
    3464:	f6 f7       	brtc	.-4      	; 0x3462 <__divmodhi4_exit>
    3466:	90 95       	com	r25
    3468:	81 95       	neg	r24
    346a:	9f 4f       	sbci	r25, 0xFF	; 255
    346c:	08 95       	ret

0000346e <malloc>:
    346e:	cf 93       	push	r28
    3470:	df 93       	push	r29
    3472:	ac 01       	movw	r20, r24
    3474:	82 30       	cpi	r24, 0x02	; 2
    3476:	91 05       	cpc	r25, r1
    3478:	10 f4       	brcc	.+4      	; 0x347e <malloc+0x10>
    347a:	42 e0       	ldi	r20, 0x02	; 2
    347c:	50 e0       	ldi	r21, 0x00	; 0
    347e:	e0 91 42 05 	lds	r30, 0x0542
    3482:	f0 91 43 05 	lds	r31, 0x0543
    3486:	20 e0       	ldi	r18, 0x00	; 0
    3488:	30 e0       	ldi	r19, 0x00	; 0
    348a:	a0 e0       	ldi	r26, 0x00	; 0
    348c:	b0 e0       	ldi	r27, 0x00	; 0
    348e:	24 c0       	rjmp	.+72     	; 0x34d8 <malloc+0x6a>
    3490:	80 81       	ld	r24, Z
    3492:	91 81       	ldd	r25, Z+1	; 0x01
    3494:	84 17       	cp	r24, r20
    3496:	95 07       	cpc	r25, r21
    3498:	d0 f0       	brcs	.+52     	; 0x34ce <malloc+0x60>
    349a:	84 17       	cp	r24, r20
    349c:	95 07       	cpc	r25, r21
    349e:	71 f4       	brne	.+28     	; 0x34bc <malloc+0x4e>
    34a0:	82 81       	ldd	r24, Z+2	; 0x02
    34a2:	93 81       	ldd	r25, Z+3	; 0x03
    34a4:	10 97       	sbiw	r26, 0x00	; 0
    34a6:	29 f0       	breq	.+10     	; 0x34b2 <malloc+0x44>
    34a8:	13 96       	adiw	r26, 0x03	; 3
    34aa:	9c 93       	st	X, r25
    34ac:	8e 93       	st	-X, r24
    34ae:	12 97       	sbiw	r26, 0x02	; 2
    34b0:	2c c0       	rjmp	.+88     	; 0x350a <malloc+0x9c>
    34b2:	90 93 43 05 	sts	0x0543, r25
    34b6:	80 93 42 05 	sts	0x0542, r24
    34ba:	27 c0       	rjmp	.+78     	; 0x350a <malloc+0x9c>
    34bc:	21 15       	cp	r18, r1
    34be:	31 05       	cpc	r19, r1
    34c0:	19 f0       	breq	.+6      	; 0x34c8 <malloc+0x5a>
    34c2:	82 17       	cp	r24, r18
    34c4:	93 07       	cpc	r25, r19
    34c6:	18 f4       	brcc	.+6      	; 0x34ce <malloc+0x60>
    34c8:	9c 01       	movw	r18, r24
    34ca:	bd 01       	movw	r22, r26
    34cc:	ef 01       	movw	r28, r30
    34ce:	92 81       	ldd	r25, Z+2	; 0x02
    34d0:	83 81       	ldd	r24, Z+3	; 0x03
    34d2:	df 01       	movw	r26, r30
    34d4:	e9 2f       	mov	r30, r25
    34d6:	f8 2f       	mov	r31, r24
    34d8:	30 97       	sbiw	r30, 0x00	; 0
    34da:	d1 f6       	brne	.-76     	; 0x3490 <malloc+0x22>
    34dc:	21 15       	cp	r18, r1
    34de:	31 05       	cpc	r19, r1
    34e0:	f9 f0       	breq	.+62     	; 0x3520 <malloc+0xb2>
    34e2:	c9 01       	movw	r24, r18
    34e4:	84 1b       	sub	r24, r20
    34e6:	95 0b       	sbc	r25, r21
    34e8:	84 30       	cpi	r24, 0x04	; 4
    34ea:	91 05       	cpc	r25, r1
    34ec:	80 f4       	brcc	.+32     	; 0x350e <malloc+0xa0>
    34ee:	8a 81       	ldd	r24, Y+2	; 0x02
    34f0:	9b 81       	ldd	r25, Y+3	; 0x03
    34f2:	61 15       	cp	r22, r1
    34f4:	71 05       	cpc	r23, r1
    34f6:	21 f0       	breq	.+8      	; 0x3500 <malloc+0x92>
    34f8:	fb 01       	movw	r30, r22
    34fa:	93 83       	std	Z+3, r25	; 0x03
    34fc:	82 83       	std	Z+2, r24	; 0x02
    34fe:	04 c0       	rjmp	.+8      	; 0x3508 <malloc+0x9a>
    3500:	90 93 43 05 	sts	0x0543, r25
    3504:	80 93 42 05 	sts	0x0542, r24
    3508:	fe 01       	movw	r30, r28
    350a:	32 96       	adiw	r30, 0x02	; 2
    350c:	42 c0       	rjmp	.+132    	; 0x3592 <malloc+0x124>
    350e:	fe 01       	movw	r30, r28
    3510:	e8 0f       	add	r30, r24
    3512:	f9 1f       	adc	r31, r25
    3514:	41 93       	st	Z+, r20
    3516:	51 93       	st	Z+, r21
    3518:	02 97       	sbiw	r24, 0x02	; 2
    351a:	99 83       	std	Y+1, r25	; 0x01
    351c:	88 83       	st	Y, r24
    351e:	39 c0       	rjmp	.+114    	; 0x3592 <malloc+0x124>
    3520:	80 91 40 05 	lds	r24, 0x0540
    3524:	90 91 41 05 	lds	r25, 0x0541
    3528:	00 97       	sbiw	r24, 0x00	; 0
    352a:	41 f4       	brne	.+16     	; 0x353c <malloc+0xce>
    352c:	80 91 32 02 	lds	r24, 0x0232
    3530:	90 91 33 02 	lds	r25, 0x0233
    3534:	90 93 41 05 	sts	0x0541, r25
    3538:	80 93 40 05 	sts	0x0540, r24
    353c:	20 91 30 02 	lds	r18, 0x0230
    3540:	30 91 31 02 	lds	r19, 0x0231
    3544:	21 15       	cp	r18, r1
    3546:	31 05       	cpc	r19, r1
    3548:	41 f4       	brne	.+16     	; 0x355a <malloc+0xec>
    354a:	2d b7       	in	r18, 0x3d	; 61
    354c:	3e b7       	in	r19, 0x3e	; 62
    354e:	80 91 34 02 	lds	r24, 0x0234
    3552:	90 91 35 02 	lds	r25, 0x0235
    3556:	28 1b       	sub	r18, r24
    3558:	39 0b       	sbc	r19, r25
    355a:	e0 91 40 05 	lds	r30, 0x0540
    355e:	f0 91 41 05 	lds	r31, 0x0541
    3562:	e2 17       	cp	r30, r18
    3564:	f3 07       	cpc	r31, r19
    3566:	98 f4       	brcc	.+38     	; 0x358e <malloc+0x120>
    3568:	2e 1b       	sub	r18, r30
    356a:	3f 0b       	sbc	r19, r31
    356c:	24 17       	cp	r18, r20
    356e:	35 07       	cpc	r19, r21
    3570:	70 f0       	brcs	.+28     	; 0x358e <malloc+0x120>
    3572:	ca 01       	movw	r24, r20
    3574:	02 96       	adiw	r24, 0x02	; 2
    3576:	28 17       	cp	r18, r24
    3578:	39 07       	cpc	r19, r25
    357a:	48 f0       	brcs	.+18     	; 0x358e <malloc+0x120>
    357c:	8e 0f       	add	r24, r30
    357e:	9f 1f       	adc	r25, r31
    3580:	90 93 41 05 	sts	0x0541, r25
    3584:	80 93 40 05 	sts	0x0540, r24
    3588:	41 93       	st	Z+, r20
    358a:	51 93       	st	Z+, r21
    358c:	02 c0       	rjmp	.+4      	; 0x3592 <malloc+0x124>
    358e:	e0 e0       	ldi	r30, 0x00	; 0
    3590:	f0 e0       	ldi	r31, 0x00	; 0
    3592:	cf 01       	movw	r24, r30
    3594:	df 91       	pop	r29
    3596:	cf 91       	pop	r28
    3598:	08 95       	ret

0000359a <free>:
    359a:	0f 93       	push	r16
    359c:	1f 93       	push	r17
    359e:	cf 93       	push	r28
    35a0:	df 93       	push	r29
    35a2:	9c 01       	movw	r18, r24
    35a4:	00 97       	sbiw	r24, 0x00	; 0
    35a6:	09 f4       	brne	.+2      	; 0x35aa <free+0x10>
    35a8:	8c c0       	rjmp	.+280    	; 0x36c2 <free+0x128>
    35aa:	dc 01       	movw	r26, r24
    35ac:	12 97       	sbiw	r26, 0x02	; 2
    35ae:	13 96       	adiw	r26, 0x03	; 3
    35b0:	1c 92       	st	X, r1
    35b2:	1e 92       	st	-X, r1
    35b4:	12 97       	sbiw	r26, 0x02	; 2
    35b6:	60 91 42 05 	lds	r22, 0x0542
    35ba:	70 91 43 05 	lds	r23, 0x0543
    35be:	61 15       	cp	r22, r1
    35c0:	71 05       	cpc	r23, r1
    35c2:	89 f4       	brne	.+34     	; 0x35e6 <free+0x4c>
    35c4:	8d 91       	ld	r24, X+
    35c6:	9c 91       	ld	r25, X
    35c8:	11 97       	sbiw	r26, 0x01	; 1
    35ca:	82 0f       	add	r24, r18
    35cc:	93 1f       	adc	r25, r19
    35ce:	20 91 40 05 	lds	r18, 0x0540
    35d2:	30 91 41 05 	lds	r19, 0x0541
    35d6:	28 17       	cp	r18, r24
    35d8:	39 07       	cpc	r19, r25
    35da:	69 f5       	brne	.+90     	; 0x3636 <free+0x9c>
    35dc:	b0 93 41 05 	sts	0x0541, r27
    35e0:	a0 93 40 05 	sts	0x0540, r26
    35e4:	6e c0       	rjmp	.+220    	; 0x36c2 <free+0x128>
    35e6:	fb 01       	movw	r30, r22
    35e8:	40 e0       	ldi	r20, 0x00	; 0
    35ea:	50 e0       	ldi	r21, 0x00	; 0
    35ec:	01 c0       	rjmp	.+2      	; 0x35f0 <free+0x56>
    35ee:	fc 01       	movw	r30, r24
    35f0:	ea 17       	cp	r30, r26
    35f2:	fb 07       	cpc	r31, r27
    35f4:	30 f4       	brcc	.+12     	; 0x3602 <free+0x68>
    35f6:	82 81       	ldd	r24, Z+2	; 0x02
    35f8:	93 81       	ldd	r25, Z+3	; 0x03
    35fa:	af 01       	movw	r20, r30
    35fc:	00 97       	sbiw	r24, 0x00	; 0
    35fe:	b9 f7       	brne	.-18     	; 0x35ee <free+0x54>
    3600:	1f c0       	rjmp	.+62     	; 0x3640 <free+0xa6>
    3602:	e9 01       	movw	r28, r18
    3604:	22 97       	sbiw	r28, 0x02	; 2
    3606:	fb 83       	std	Y+3, r31	; 0x03
    3608:	ea 83       	std	Y+2, r30	; 0x02
    360a:	08 81       	ld	r16, Y
    360c:	19 81       	ldd	r17, Y+1	; 0x01
    360e:	c9 01       	movw	r24, r18
    3610:	80 0f       	add	r24, r16
    3612:	91 1f       	adc	r25, r17
    3614:	8e 17       	cp	r24, r30
    3616:	9f 07       	cpc	r25, r31
    3618:	59 f4       	brne	.+22     	; 0x3630 <free+0x96>
    361a:	80 81       	ld	r24, Z
    361c:	91 81       	ldd	r25, Z+1	; 0x01
    361e:	80 0f       	add	r24, r16
    3620:	91 1f       	adc	r25, r17
    3622:	02 96       	adiw	r24, 0x02	; 2
    3624:	99 83       	std	Y+1, r25	; 0x01
    3626:	88 83       	st	Y, r24
    3628:	82 81       	ldd	r24, Z+2	; 0x02
    362a:	93 81       	ldd	r25, Z+3	; 0x03
    362c:	9b 83       	std	Y+3, r25	; 0x03
    362e:	8a 83       	std	Y+2, r24	; 0x02
    3630:	41 15       	cp	r20, r1
    3632:	51 05       	cpc	r21, r1
    3634:	29 f4       	brne	.+10     	; 0x3640 <free+0xa6>
    3636:	b0 93 43 05 	sts	0x0543, r27
    363a:	a0 93 42 05 	sts	0x0542, r26
    363e:	41 c0       	rjmp	.+130    	; 0x36c2 <free+0x128>
    3640:	fa 01       	movw	r30, r20
    3642:	b3 83       	std	Z+3, r27	; 0x03
    3644:	a2 83       	std	Z+2, r26	; 0x02
    3646:	c1 91       	ld	r28, Z+
    3648:	d1 91       	ld	r29, Z+
    364a:	ec 0f       	add	r30, r28
    364c:	fd 1f       	adc	r31, r29
    364e:	ae 17       	cp	r26, r30
    3650:	bf 07       	cpc	r27, r31
    3652:	81 f4       	brne	.+32     	; 0x3674 <free+0xda>
    3654:	f9 01       	movw	r30, r18
    3656:	92 91       	ld	r25, -Z
    3658:	82 91       	ld	r24, -Z
    365a:	8c 0f       	add	r24, r28
    365c:	9d 1f       	adc	r25, r29
    365e:	02 96       	adiw	r24, 0x02	; 2
    3660:	da 01       	movw	r26, r20
    3662:	11 96       	adiw	r26, 0x01	; 1
    3664:	9c 93       	st	X, r25
    3666:	8e 93       	st	-X, r24
    3668:	82 81       	ldd	r24, Z+2	; 0x02
    366a:	93 81       	ldd	r25, Z+3	; 0x03
    366c:	13 96       	adiw	r26, 0x03	; 3
    366e:	9c 93       	st	X, r25
    3670:	8e 93       	st	-X, r24
    3672:	12 97       	sbiw	r26, 0x02	; 2
    3674:	e0 e0       	ldi	r30, 0x00	; 0
    3676:	f0 e0       	ldi	r31, 0x00	; 0
    3678:	02 c0       	rjmp	.+4      	; 0x367e <free+0xe4>
    367a:	fb 01       	movw	r30, r22
    367c:	bc 01       	movw	r22, r24
    367e:	db 01       	movw	r26, r22
    3680:	12 96       	adiw	r26, 0x02	; 2
    3682:	8d 91       	ld	r24, X+
    3684:	9c 91       	ld	r25, X
    3686:	13 97       	sbiw	r26, 0x03	; 3
    3688:	00 97       	sbiw	r24, 0x00	; 0
    368a:	b9 f7       	brne	.-18     	; 0x367a <free+0xe0>
    368c:	cb 01       	movw	r24, r22
    368e:	02 96       	adiw	r24, 0x02	; 2
    3690:	2d 91       	ld	r18, X+
    3692:	3c 91       	ld	r19, X
    3694:	11 97       	sbiw	r26, 0x01	; 1
    3696:	82 0f       	add	r24, r18
    3698:	93 1f       	adc	r25, r19
    369a:	20 91 40 05 	lds	r18, 0x0540
    369e:	30 91 41 05 	lds	r19, 0x0541
    36a2:	28 17       	cp	r18, r24
    36a4:	39 07       	cpc	r19, r25
    36a6:	69 f4       	brne	.+26     	; 0x36c2 <free+0x128>
    36a8:	30 97       	sbiw	r30, 0x00	; 0
    36aa:	29 f4       	brne	.+10     	; 0x36b6 <free+0x11c>
    36ac:	10 92 43 05 	sts	0x0543, r1
    36b0:	10 92 42 05 	sts	0x0542, r1
    36b4:	02 c0       	rjmp	.+4      	; 0x36ba <free+0x120>
    36b6:	13 82       	std	Z+3, r1	; 0x03
    36b8:	12 82       	std	Z+2, r1	; 0x02
    36ba:	70 93 41 05 	sts	0x0541, r23
    36be:	60 93 40 05 	sts	0x0540, r22
    36c2:	df 91       	pop	r29
    36c4:	cf 91       	pop	r28
    36c6:	1f 91       	pop	r17
    36c8:	0f 91       	pop	r16
    36ca:	08 95       	ret

000036cc <_exit>:
    36cc:	f8 94       	cli

000036ce <__stop_program>:
    36ce:	ff cf       	rjmp	.-2      	; 0x36ce <__stop_program>
